{"version":3,"file":"index.umd.js","sources":["../src/storage/CacheManager.ts","../src/storage/SearchStorage.ts","../src/storage/IndexedDocument.ts","../src/mappers/DataMapper.ts","../src/algorithms/trie/TrieNode.ts","../src/algorithms/trie/TrieSearch.ts","../src/mappers/IndexMapper.ts","../src/utils/SearchUtils.ts","../src/utils/ValidationUtils.ts","../src/storage/IndexManager.ts","../src/core/QueryProcessor.ts","../src/core/SearchEngine.ts","../src/types/errors.ts","../src/types/events.ts","../src/types/cache.ts","../src/index.ts","../src/types/defaults.ts","../src/storage/IndexedDBService.ts","../src/utils/PerformanceUtils.ts"],"sourcesContent":["import { CacheEntry, CacheStatus, CacheStrategy, SearchResult } from \"@/types\";\r\n\r\n\r\n\r\nexport class CacheManager {\r\n    public getSize(): number {\r\n        return this.cache.size;\r\n    }\r\n\r\n    public getStatus(): CacheStatus {\r\n        const timestamps = Array.from(this.cache.values()).map(entry => entry.timestamp);\r\n        const now = Date.now();\r\n        \r\n        // Calculate memory usage estimation\r\n        const memoryBytes = this.calculateMemoryUsage();\r\n        \r\n        return {\r\n            size: this.cache.size,\r\n            maxSize: this.maxSize,\r\n            strategy: this.strategy,\r\n            ttl: this.ttl,\r\n            utilization: this.cache.size / this.maxSize,\r\n            oldestEntryAge: timestamps.length ? now - Math.min(...timestamps) : null,\r\n            newestEntryAge: timestamps.length ? now - Math.max(...timestamps) : null,\r\n            memoryUsage: {\r\n                bytes: memoryBytes,\r\n                formatted: this.formatBytes(memoryBytes)\r\n            }\r\n        };\r\n    }\r\n\r\n    private calculateMemoryUsage(): number {\r\n        let totalSize = 0;\r\n\r\n        // Estimate size of cache entries\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            // Key size (2 bytes per character in UTF-16)\r\n            totalSize += key.length * 2;\r\n\r\n            // Entry overhead (timestamp, lastAccessed, accessCount)\r\n            totalSize += 8 * 3; // 8 bytes per number\r\n\r\n            // Estimate size of cached data\r\n            totalSize += this.estimateDataSize(entry.data);\r\n        }\r\n\r\n        // Add overhead for Map structure and class properties\r\n        totalSize += 8 * (\r\n            1 + // maxSize\r\n            1 + // ttl\r\n            1 + // strategy string reference\r\n            this.accessOrder.length + // access order array\r\n            3   // stats object numbers\r\n        );\r\n\r\n        return totalSize;\r\n    }\r\n\r\n    private estimateDataSize(data: SearchResult<unknown>[]): number {\r\n        let size = 0;\r\n        \r\n        for (const result of data) {\r\n            // Basic properties\r\n            size += 8; // score (number)\r\n            size += result.matches.join('').length * 2; // matches array strings\r\n            \r\n            // Estimate item size (conservative estimate)\r\n            size += JSON.stringify(result.item).length * 2;\r\n            \r\n            // Metadata if present\r\n            if (result.metadata) {\r\n                size += JSON.stringify(result.metadata).length * 2;\r\n            }\r\n        }\r\n\r\n        return size;\r\n    }\r\n\r\n    private formatBytes(bytes: number): string {\r\n        const units = ['B', 'KB', 'MB', 'GB'];\r\n        let size = bytes;\r\n        let unitIndex = 0;\r\n\r\n        while (size >= 1024 && unitIndex < units.length - 1) {\r\n            size /= 1024;\r\n            unitIndex++;\r\n        }\r\n\r\n        return `${size.toFixed(2)} ${units[unitIndex]}`;\r\n    }\r\n    private cache: Map<string, CacheEntry>;\r\n    private readonly maxSize: number;\r\n    private readonly ttl: number;\r\n    private strategy: CacheStrategy; // Changed from readonly to private\r\n    private accessOrder: string[];\r\n    private stats: {\r\n        hits: number;\r\n        misses: number;\r\n        evictions: number;\r\n    };\r\n\r\n    constructor(\r\n        maxSize: number = 1000, \r\n        ttlMinutes: number = 5, \r\n        initialStrategy: CacheStrategy = 'LRU'\r\n    ) {\r\n        this.cache = new Map();\r\n        this.maxSize = maxSize;\r\n        this.ttl = ttlMinutes * 60 * 1000;\r\n        this.strategy = initialStrategy;\r\n        this.accessOrder = [];\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            evictions: 0\r\n        };\r\n    }\r\n\r\n    set(key: string, data: SearchResult<unknown>[]): void {\r\n        if (this.cache.size >= this.maxSize) {\r\n            this.evict();\r\n        }\r\n\r\n        const entry: CacheEntry = {\r\n            data,\r\n            timestamp: Date.now(),\r\n            lastAccessed: Date.now(),\r\n            accessCount: 1\r\n        };\r\n\r\n        this.cache.set(key, entry);\r\n        this.updateAccessOrder(key);\r\n    }\r\n\r\n    get(key: string): SearchResult<unknown>[] | null {\r\n        const entry = this.cache.get(key);\r\n\r\n        if (!entry) {\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n\r\n        if (this.isExpired(entry.timestamp)) {\r\n            this.cache.delete(key);\r\n            this.removeFromAccessOrder(key);\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n\r\n        entry.lastAccessed = Date.now();\r\n        entry.accessCount++;\r\n        this.updateAccessOrder(key);\r\n        this.stats.hits++;\r\n\r\n        return entry.data;\r\n    }\r\n\r\n    clear(): void {\r\n        this.cache.clear();\r\n        this.accessOrder = [];\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            evictions: 0\r\n        };\r\n    }\r\n\r\n    getStats() {\r\n        return {\r\n            ...this.stats,\r\n            size: this.cache.size,\r\n            maxSize: this.maxSize,\r\n            hitRate: this.stats.hits / (this.stats.hits + this.stats.misses),\r\n            strategy: this.strategy\r\n        };\r\n    }\r\n\r\n    private isExpired(timestamp: number): boolean {\r\n        return Date.now() - timestamp > this.ttl;\r\n    }\r\n\r\n    private evict(): void {\r\n        const keyToEvict = this.strategy === 'LRU' \r\n            ? this.findLRUKey()\r\n            : this.findMRUKey();\r\n\r\n        if (keyToEvict) {\r\n            this.cache.delete(keyToEvict);\r\n            this.removeFromAccessOrder(keyToEvict);\r\n            this.stats.evictions++;\r\n        }\r\n    }\r\n\r\n    private findLRUKey(): string | null {\r\n        return this.accessOrder[0] || null;\r\n    }\r\n\r\n    private findMRUKey(): string | null {\r\n        return this.accessOrder[this.accessOrder.length - 1] || null;\r\n    }\r\n\r\n    private updateAccessOrder(key: string): void {\r\n        this.removeFromAccessOrder(key);\r\n\r\n        if (this.strategy === 'LRU') {\r\n            this.accessOrder.push(key); // Most recently used at end\r\n        } else {\r\n            this.accessOrder.unshift(key); // Most recently used at start\r\n        }\r\n    }\r\n\r\n    private removeFromAccessOrder(key: string): void {\r\n        const index = this.accessOrder.indexOf(key);\r\n        if (index !== -1) {\r\n            this.accessOrder.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    setStrategy(newStrategy: CacheStrategy): void {\r\n        if (newStrategy === this.strategy) return;\r\n        \r\n        this.strategy = newStrategy;\r\n        const entries = [...this.accessOrder];\r\n        this.accessOrder = [];\r\n        entries.forEach(key => this.updateAccessOrder(key));\r\n    }\r\n\r\n    prune(): number {\r\n        let prunedCount = 0;\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            if (this.isExpired(entry.timestamp)) {\r\n                this.cache.delete(key);\r\n                this.removeFromAccessOrder(key);\r\n                prunedCount++;\r\n            }\r\n        }\r\n        return prunedCount;\r\n    }\r\n\r\n    analyze(): {\r\n        hitRate: number;\r\n        averageAccessCount: number;\r\n        mostAccessedKeys: Array<{ key: string; count: number }>;\r\n    } {\r\n        const totalAccesses = this.stats.hits + this.stats.misses;\r\n        const hitRate = totalAccesses > 0 ? this.stats.hits / totalAccesses : 0;\r\n\r\n        let totalAccessCount = 0;\r\n        const accessCounts = new Map<string, number>();\r\n\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            totalAccessCount += entry.accessCount;\r\n            accessCounts.set(key, entry.accessCount);\r\n        }\r\n\r\n        const averageAccessCount = this.cache.size > 0 \r\n            ? totalAccessCount / this.cache.size \r\n            : 0;\r\n\r\n        const mostAccessedKeys = Array.from(accessCounts.entries())\r\n            .sort((a, b) => b[1] - a[1])\r\n            .slice(0, 5)\r\n            .map(([key, count]) => ({ key, count }));\r\n\r\n        return {\r\n            hitRate,\r\n            averageAccessCount,\r\n            mostAccessedKeys\r\n        };\r\n    }\r\n}","import { openDB, IDBPDatabase } from 'idb';\nimport type { SearchDBSchema, StorageOptions } from '@/types';\n\nexport class SearchStorage {\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\n    private memoryStorage: Map<string, unknown> = new Map();\n    private storageType: 'indexeddb' | 'memory';\n    \n    constructor(options: StorageOptions = {\n        type: 'memory'\n    }) {\n        this.storageType = this.determineStorageType(options);\n    }\n\n    private determineStorageType(options: StorageOptions): 'indexeddb' | 'memory' {\n        // Use memory storage if explicitly specified or if in Node.js environment\n        if (options.type === 'memory' || !this.isIndexedDBAvailable()) {\n            return 'memory';\n        }\n        return 'indexeddb';\n    }\n\n    private isIndexedDBAvailable(): boolean {\n        try {\n            return typeof indexedDB !== 'undefined' && indexedDB !== null;\n        } catch {\n            return false;\n        }\n    }\n\n    async initialize(): Promise<void> {\n        if (this.storageType === 'memory') {\n            // No initialization needed for memory storage\n            return;\n        }\n\n        try {\n            this.db = await openDB<SearchDBSchema>('nexus-search-db', 1, {\n                upgrade(db) {\n                    const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\n                    indexStore.createIndex('timestamp', 'timestamp');\n\n                    const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\n                    metaStore.createIndex('lastUpdated', 'lastUpdated');\n                }\n            });\n        } catch (error) {\n            // Fallback to memory storage if IndexedDB fails\n            this.storageType = 'memory';\n            console.warn('Failed to initialize IndexedDB, falling back to memory storage:', error);\n        }\n    }\n\n    async storeIndex(name: string, data: unknown): Promise<void> {\n        if (this.storageType === 'memory') {\n            this.memoryStorage.set(name, data);\n            return;\n        }\n\n        try {\n            await this.db?.put('searchIndices', {\n                id: name,\n                data,\n                timestamp: Date.now()\n            });\n        } catch (error) {\n            console.error('Storage error:', error);\n            // Fallback to memory storage\n            this.memoryStorage.set(name, data);\n        }\n    }\n\n    async getIndex(name: string): Promise<unknown> {\n        if (this.storageType === 'memory') {\n            return this.memoryStorage.get(name);\n        }\n\n        try {\n            const entry = await this.db?.get('searchIndices', name);\n            return entry?.data;\n        } catch (error) {\n            console.error('Retrieval error:', error);\n            // Fallback to memory storage\n            return this.memoryStorage.get(name);\n        }\n    }\n\n    async clearIndices(): Promise<void> {\n        if (this.storageType === 'memory') {\n            this.memoryStorage.clear();\n            return;\n        }\n\n        try {\n            await this.db?.clear('searchIndices');\n        } catch (error) {\n            console.error('Clear error:', error);\n            this.memoryStorage.clear();\n        }\n    }\n\n    async close(): Promise<void> {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n        }\n        this.memoryStorage.clear();\n    }\n}","import { \r\n    IndexedDocument as IIndexedDocument, \r\n    DocumentMetadata, \r\n    IndexableDocumentFields \r\n} from \"@/types/document\";\r\n\r\n\r\n\r\nexport class IndexedDocument implements IIndexedDocument {\r\n    readonly id: string;\r\n    fields: IndexableDocumentFields & {\r\n        title: string;\r\n        content: string;\r\n        author: string;\r\n        tags: string[];\r\n        [key: string]: string | string[] | number | boolean | null;\r\n    };\r\n    metadata?: DocumentMetadata;\r\n    versions: any[] = [];\r\n    relations: any[] = [];\r\n    content: any;\r\n\r\n    constructor(\r\n        id: string,\r\n        fields: IndexableDocumentFields & {\r\n            title: string;\r\n            content: string;\r\n            author: string;\r\n            tags: string[];\r\n            [key: string]: string | string[] | number | boolean | null;\r\n        },\r\n        metadata?: DocumentMetadata\r\n    ) {\r\n        this.id = id;\r\n        this.fields = this.normalizeFields(fields);\r\n        this.metadata = this.normalizeMetadata(metadata);\r\n    }\r\n\r\n    private normalizeFields(fields: IndexableDocumentFields): IndexableDocumentFields & {\r\n        title: string;\r\n        content: string;\r\n        author: string;\r\n        tags: string[];\r\n        [key: string]: string | string[] | number | boolean | null;\r\n    } {\r\n        const normalizedFields: IndexableDocumentFields = {\r\n            title: \"\",\r\n            content: \"\",\r\n            author: \"\",\r\n            tags: [],\r\n            version: \"\"\r\n        };\r\n    \r\n        for (const key in fields) {\r\n            if (fields[key] !== undefined) {\r\n                normalizedFields[key] = fields[key];\r\n            }\r\n        }\r\n    \r\n        return {\r\n            ...normalizedFields,\r\n            title: fields.title || '',\r\n            content: fields.content || '',\r\n            author: fields.author || '',\r\n            tags: fields.tags || []\r\n        };\r\n    }\r\n\r\n    private normalizeMetadata(metadata?: DocumentMetadata): DocumentMetadata {\r\n        return {\r\n            indexed: Date.now(),\r\n            lastModified: Date.now(),\r\n            ...metadata\r\n        };\r\n    }\r\n\r\n    toObject(): any {\r\n        return {\r\n            id: this.id,\r\n            fields: {\r\n                ...this.fields,\r\n                tags: [...this.fields.tags]\r\n            },\r\n            metadata: this.metadata ? { ...this.metadata } : undefined,\r\n            versions: [...this.versions],\r\n            relations: [...this.relations],\r\n            content: this.content,\r\n            document: () => this,\r\n            clone: () => this.clone(),\r\n            update: (updates: Partial<IIndexedDocument>) => this.update(updates)\r\n        };\r\n    }\r\n\r\n    clone(): IndexedDocument {\r\n        return new IndexedDocument(\r\n            this.id,\r\n            { ...this.fields, tags: [...this.fields.tags] },\r\n            this.metadata ? { ...this.metadata } : undefined\r\n        );\r\n    }\r\n\r\n    update(updates: Partial<IIndexedDocument>): IndexedDocument {\r\n        const updatedFields = {\r\n            ...this.fields\r\n        };\r\n\r\n        if (updates.fields) {\r\n            Object.entries(updates.fields).forEach(([key, value]) => {\r\n                if (value !== undefined) {\r\n                    // Type assertion to handle string index signature\r\n                    (updatedFields as any)[key] = value;\r\n                }\r\n            });\r\n        }\r\n\r\n        return new IndexedDocument(\r\n            this.id,\r\n            updatedFields,\r\n            {\r\n                ...this.metadata,\r\n                ...updates.metadata,\r\n                lastModified: Date.now()\r\n            }\r\n        );\r\n    }\r\n\r\n    getField<T extends keyof IndexableDocumentFields>(\r\n        field: T\r\n    ): IndexableDocumentFields[T] {\r\n        return this.fields[field];\r\n    }\r\n\r\n    setField<T extends keyof IndexableDocumentFields>(\r\n        field: T,\r\n        value: IndexableDocumentFields[T]\r\n    ): void {\r\n        (this.fields as any)[field] = value;\r\n    }\r\n\r\n    document(): IIndexedDocument {\r\n        return this;\r\n    }\r\n\r\n    static create(data: {\r\n        id: string;\r\n        fields: IndexableDocumentFields & {\r\n            title: string;\r\n            content: string;\r\n            author: string;\r\n            tags: string[];\r\n            [key: string]: string | string[] | number | boolean | null;\r\n        };\r\n        metadata?: DocumentMetadata;\r\n    }): IndexedDocument {\r\n        return new IndexedDocument(\r\n            data.id,\r\n            data.fields,\r\n            data.metadata\r\n        );\r\n    }\r\n\r\n    static fromObject(obj: Partial<IIndexedDocument> & { \r\n        id: string; \r\n        fields: IndexableDocumentFields;\r\n    }): IndexedDocument {\r\n        return IndexedDocument.create({\r\n            id: obj.id,\r\n            fields: {\r\n                ...obj.fields,\r\n                title: obj.fields.title,\r\n                content: obj.fields.content,\r\n                author: obj.fields.author,\r\n                tags: obj.fields.tags\r\n            },\r\n            metadata: obj.metadata\r\n        });\r\n    }\r\n\r\n    toJSON(): Record<string, any> {\r\n        return {\r\n            id: this.id,\r\n            fields: this.fields,\r\n            metadata: this.metadata,\r\n            versions: this.versions,\r\n            relations: this.relations\r\n        };\r\n    }\r\n\r\n    toString(): string {\r\n        return `IndexedDocument(${this.id})`;\r\n    }\r\n}","export class DataMapper {\r\n  private dataMap: Map<string, Set<string>>;\r\n\r\n  constructor() {\r\n    this.dataMap = new Map();\r\n  }\r\n\r\n  mapData(key: string, documentId: string): void {\r\n    if (!this.dataMap.has(key)) {\r\n      this.dataMap.set(key, new Set());\r\n    }\r\n    this.dataMap.get(key)!.add(documentId);\r\n  }\r\n\r\n  getDocuments(key: string): Set<string> {\r\n    return this.dataMap.get(key) || new Set();\r\n  }\r\n\r\n  getDocumentById(documentId: string): Set<string> {\r\n    const documents = new Set<string>();\r\n    this.dataMap.forEach(value => {\r\n      if (value.has(documentId)) {\r\n        documents.add(documentId);\r\n      }\r\n    }\r\n    );\r\n    return documents;\r\n  }\r\n\r\n  getAllKeys(): string[] {\r\n    return Array.from(this.dataMap.keys());\r\n  }\r\n\r\n  removeDocument(documentId: string): void {\r\n    this.dataMap.forEach(value => {\r\n      value.delete(documentId);\r\n    });\r\n  }\r\n\r\n\r\n\r\n  removeKey(key: string): void {\r\n    this.dataMap.delete(key);\r\n  }\r\n  \r\n  exportState(): Record<string, string[]> {\r\n    const serializedMap: Record<string, string[]> = {};\r\n    \r\n    this.dataMap.forEach((value, key) => {\r\n      serializedMap[key] = Array.from(value);\r\n    });\r\n\r\n    return serializedMap;\r\n  }\r\n\r\n  importState(state: Record<string, string[]>): void {\r\n    this.dataMap.clear();\r\n    \r\n    Object.entries(state).forEach(([key, value]) => {\r\n      this.dataMap.set(key, new Set(value));\r\n    });\r\n  }\r\n\r\n  clear(): void {\r\n    this.dataMap.clear();\r\n  }\r\n}","export class TrieNode {\r\n  children: Map<string, TrieNode>;\r\n  isEndOfWord: boolean;\r\n  documentRefs: Set<string>;\r\n  weight: number;\r\n\r\n  constructor() {\r\n      this.children = new Map();\r\n      this.isEndOfWord = false;\r\n      this.documentRefs = new Set();\r\n      this.weight = 0.0;\r\n  }\r\n}\r\n","import {  IndexedDocument, DocumentLink, SerializedState, SerializedTrieNode } from \"@/types\";\r\nimport { TrieNode } from \"./TrieNode\";\r\n\r\nexport class TrieSearch {\r\n    private root: TrieNode;\r\n    private documents: Map<string, IndexedDocument>;\r\n    private documentLinks: Map<string, DocumentLink[]>;\r\n\r\n    constructor() {\r\n        this.root = new TrieNode();\r\n        this.documents = new Map();\r\n        this.documentLinks = new Map();\r\n    }\r\n\r\n    public insert(text: string, documentId: string): void {\r\n        if (!text || !documentId) return;\r\n\r\n        const words = text.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            let current = this.root;\r\n\r\n            for (const char of word) {\r\n                if (!current.children.has(char)) {\r\n                    current.children.set(char, new TrieNode());\r\n                }\r\n                current = current.children.get(char)!;\r\n            }\r\n\r\n            current.isEndOfWord = true;\r\n            current.documentRefs.add(documentId);\r\n            current.weight += 1.0;\r\n        }\r\n    }\r\n\r\n    public search(query: string, maxResults: number = 10): Set<string> {\r\n        if (!query) return new Set();\r\n\r\n        const results = new Set<string>();\r\n        const words = query.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            let current = this.root;\r\n            let found = true;\r\n\r\n            for (const char of word) {\r\n                if (!current.children.has(char)) {\r\n                    found = false;\r\n                    break;\r\n                }\r\n                current = current.children.get(char)!;\r\n            }\r\n\r\n            if (found && current.isEndOfWord) {\r\n                this.collectDocumentRefs(current, results, maxResults);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public remove(documentId: string): void {\r\n        for (const [, node] of this.root.children) {\r\n            this.removeHelper(documentId, node);\r\n        }\r\n\r\n        this.documents.delete(documentId);\r\n        this.documentLinks.delete(documentId);\r\n    }\r\n\r\n    private removeHelper(documentId: string, node: TrieNode): void {\r\n        if (node.documentRefs.has(documentId)) {\r\n            node.documentRefs.delete(documentId);\r\n            node.weight -= 1.0;\r\n        }\r\n\r\n        for (const [, child] of node.children) {\r\n            this.removeHelper(documentId, child);\r\n        }\r\n\r\n        if (node.children.size === 0 && node.documentRefs.size === 0 && node.weight === 0) {\r\n            node.children.clear();\r\n        }\r\n    }\r\n\r\n    public linkDocument(documentId: string, links: DocumentLink[]): void {\r\n        this.documentLinks.set(documentId, links);\r\n    }\r\n\r\n    public getDocumentLinks(documentId: string): DocumentLink[] {\r\n        return this.documentLinks.get(documentId) ?? [];\r\n    }   \r\n    public removeData(documentId: string): void {\r\n        this.remove(documentId);\r\n    }\r\n\r\n    public fuzzySearch(query: string, maxDistance: number = 2): Set<string> {\r\n        if (!query) return new Set();\r\n\r\n        const results = new Set<string>();\r\n        const words = query.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            this.fuzzySearchHelper(word, this.root, '', maxDistance, results);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    private collectDocumentRefs(node: TrieNode, results: Set<string>, maxResults: number): void {\r\n        if (node.isEndOfWord) {\r\n            for (const docId of node.documentRefs) {\r\n                if (results.size >= maxResults) return;\r\n                results.add(docId);\r\n            }\r\n        }\r\n\r\n        for (const child of node.children.values()) {\r\n            if (results.size >= maxResults) return;\r\n            this.collectDocumentRefs(child, results, maxResults);\r\n        }\r\n    }\r\n\r\n    private fuzzySearchHelper(\r\n        word: string,\r\n        node: TrieNode,\r\n        currentWord: string,\r\n        maxDistance: number,\r\n        results: Set<string>\r\n    ): void {\r\n        if (maxDistance < 0) return;\r\n\r\n        if (node.isEndOfWord) {\r\n            const distance = this.calculateLevenshteinDistance(word, currentWord);\r\n            if (distance <= maxDistance) {\r\n                node.documentRefs.forEach(id => results.add(id));\r\n            }\r\n        }\r\n\r\n        for (const [char, childNode] of node.children) {\r\n            const newDistance = word[currentWord.length] !== char ? maxDistance - 1 : maxDistance;\r\n            this.fuzzySearchHelper(word, childNode, currentWord + char, newDistance, results);\r\n\r\n            if (maxDistance > 0) {\r\n                this.fuzzySearchHelper(word, childNode, currentWord, maxDistance - 1, results);\r\n            }\r\n        }\r\n    }\r\n\r\n    private calculateLevenshteinDistance(s1: string, s2: string): number {\r\n        const dp: number[][] = Array(s1.length + 1).fill(0)\r\n            .map(() => Array(s2.length + 1).fill(0));\r\n\r\n        for (let i = 0; i <= s1.length; i++) dp[i][0] = i;\r\n        for (let j = 0; j <= s2.length; j++) dp[0][j] = j;\r\n\r\n        for (let i = 1; i <= s1.length; i++) {\r\n            for (let j = 1; j <= s2.length; j++) {\r\n                dp[i][j] = Math.min(\r\n                    dp[i - 1][j] + 1,\r\n                    dp[i][j - 1] + 1,\r\n                    dp[i - 1][j - 1] + (s1[i - 1] !== s2[j - 1] ? 1 : 0)\r\n                );\r\n            }\r\n        }\r\n\r\n        return dp[s1.length][s2.length];\r\n    }\r\n\r\n    public exportState(): SerializedState {\r\n        return {\r\n            trie: this.serializeNode(this.root),\r\n            documents: Array.from(this.documents.entries()),\r\n            documentLinks: Array.from(this.documentLinks.entries())\r\n        };\r\n    }\r\n\r\n    public importState(state: SerializedState): void {\r\n        this.root = this.deserializeNode(state.trie);\r\n        this.documents = new Map(state.documents);\r\n        this.documentLinks = new Map(state.documentLinks);\r\n    }\r\n\r\n    private serializeNode(node: TrieNode): SerializedTrieNode {\r\n        const children: { [key: string]: SerializedTrieNode } = {};\r\n\r\n        node.children.forEach((childNode, char) => {\r\n            children[char] = this.serializeNode(childNode);\r\n        });\r\n\r\n        return {\r\n            isEndOfWord: node.isEndOfWord,\r\n            documentRefs: Array.from(node.documentRefs),\r\n            weight: node.weight,\r\n            children\r\n        };\r\n    }\r\n\r\n    private deserializeNode(serialized: SerializedTrieNode): TrieNode {\r\n        const node = new TrieNode();\r\n        node.isEndOfWord = serialized.isEndOfWord;\r\n        node.documentRefs = new Set(serialized.documentRefs);\r\n        node.weight = serialized.weight ?? 0;\r\n\r\n        Object.entries(serialized.children).forEach(([char, childData]) => {\r\n            node.children.set(char, this.deserializeNode(childData));\r\n        });\r\n\r\n        return node;\r\n    }\r\n\r\n    public clear(): void {\r\n        this.root = new TrieNode();\r\n        this.documents.clear();\r\n        this.documentLinks.clear();\r\n    }\r\n\r\n    public getSize(): number {\r\n        return this.documents.size;\r\n    }\r\n}","import { TrieSearch } from \"@/algorithms/trie\";\r\nimport {  IndexedDocument, SearchableDocument, SearchResult, SerializedState } from \"@/types\";\r\nimport { DataMapper } from \"./DataMapper\";\r\n\r\n\r\n/**\r\n * IndexMapper class\r\n * @description IndexMapper class that indexes documents and performs search operations\r\n * @class IndexMapper\r\n * @implements {IndexMapper}\r\n * @method indexDocument\r\n * @method search\r\n * \r\n */\r\nexport class IndexMapper {\r\n  private dataMapper: DataMapper;\r\n  private trieSearch: TrieSearch;\r\n\r\n  constructor() {\r\n    this.dataMapper = new DataMapper();\r\n    this.trieSearch = new TrieSearch();\r\n  }\r\n\r\n  indexDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n    fields.forEach(field => {\r\n        const value = document[field];\r\n        if (typeof value === 'string') {\r\n            const words = this.tokenizeText(value);\r\n            words.forEach(word => {\r\n                this.trieSearch.insert(word, id);\r\n                this.dataMapper.mapData(word.toLowerCase(), id);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n  search(query: string, options: { fuzzy?: boolean; maxResults?: number } = {}): SearchResult<string>[] {\r\n    const { fuzzy = false, maxResults = 10 } = options;\r\n    const searchTerms = this.tokenizeText(query);\r\n    \r\n    const documentScores = new Map<string, { score: number; matches: Set<string> }>();\r\n\r\n    searchTerms.forEach(term => {\r\n      const documentIds = fuzzy\r\n        ? this.trieSearch.fuzzySearch(term)\r\n        : this.trieSearch.search(term, maxResults);\r\n\r\n      documentIds.forEach(id => {\r\n        const current = documentScores.get(id) || { score: 0, matches: new Set<string>() };\r\n        current.score += this.calculateScore(id, term);\r\n        current.matches.add(term);\r\n        documentScores.set(id, current);\r\n      });\r\n    });\r\n\r\n    const results = Array.from(documentScores.entries())\r\n      .map(([id, { score, matches }]) => ({\r\n        id: id,\r\n        document: this.dataMapper.getDocumentById(id) as unknown as IndexedDocument,\r\n        item: id,\r\n        score: score / searchTerms.length,\r\n        matches: Array.from(matches)\r\n      }))\r\n      .sort((a, b) => b.score - a.score);\r\n\r\n    return results.slice(0, maxResults);\r\n  }\r\n\r\n  exportState(): unknown {\r\n    return {\r\n      trie: this.trieSearch.exportState(),\r\n      dataMap: this.dataMapper.exportState()\r\n    };\r\n  }\r\n\r\n  importState(state: { trie: SerializedState; dataMap: Record<string, string[]> }): void {\r\n    if (!state || !state.trie || !state.dataMap) {\r\n        throw new Error('Invalid index state');\r\n    }\r\n\r\n    this.trieSearch = new TrieSearch();\r\n    this.trieSearch.importState(state.trie );\r\n    this.dataMapper = new DataMapper();\r\n    this.dataMapper.importState(state.dataMap);\r\n}\r\n\r\n\r\n  private tokenizeText(text: string): string[] {\r\n    return text\r\n      .toLowerCase()\r\n      .replace(/[^\\w\\s]/g, ' ')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 0);\r\n  }\r\n\r\n\r\n  private calculateScore(documentId: string, term: string): number {\r\n    const baseScore = this.dataMapper.getDocuments(term.toLowerCase()).has(documentId) ? 1.0 : 0.5;\r\n    return baseScore\r\n  \r\n  }\r\n  removeDocument(id: string): void {\r\n    this.trieSearch.remove(id);\r\n    this.dataMapper.removeDocument(id);\r\n  }\r\n\r\n\r\n  \r\n  addDocument(id: string, fields: string[], document: SearchableDocument): void {\r\n    this.indexDocument(document, id, fields);\r\n  }\r\n\r\n  updateDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n    this.removeDocument(id);\r\n    this.indexDocument(document, id, fields);\r\n  }\r\n\r\n  clear(): void {\r\n    this.trieSearch = new TrieSearch();\r\n    this.dataMapper = new DataMapper();\r\n  }\r\n}\r\n","import { IndexedDocument } from \"@/storage\";\r\nimport { IndexNode, OptimizationResult, SearchableDocument } from \"@/types\";\r\nimport { DocumentContent, DocumentValue } from \"@/types/document\";\r\n\r\n\r\n/**\r\n * Creates searchable fields from a document based on specified field paths.\r\n * Handles nested paths and various value types.\r\n */\r\nexport function createSearchableFields(\r\n    document: SearchableDocument,\r\n    fields: string[]\r\n): Record<string, string> {\r\n    if (!document || !document.content || !Array.isArray(fields)) {\r\n        return {};\r\n    }\r\n\r\n    const searchableFields: Record<string, string> = {};\r\n    \r\n    for (const field of fields) {\r\n        try {\r\n            const value = getNestedValue(document.content, field);\r\n            if (value !== undefined) {\r\n                searchableFields[field] = normalizeFieldValue(value);\r\n            }\r\n        } catch (error) {\r\n            console.warn(`Error processing field ${field}:`, error);\r\n        }\r\n    }\r\n\r\n    return searchableFields;\r\n}\r\n\r\n/**\r\n * Normalizes field values into searchable strings.\r\n * Handles various data types and nested structures.\r\n */\r\nexport function normalizeFieldValue(value: DocumentValue): string {\r\n    try {\r\n        if (value === null || value === undefined) {\r\n            return '';\r\n        }\r\n\r\n        if (typeof value === 'string') {\r\n            return value.toLowerCase().trim();\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n            return value\r\n                .map(v => normalizeFieldValue(v))\r\n                .filter(Boolean)\r\n                .join(' ');\r\n        }\r\n\r\n        if (typeof value === 'object') {\r\n            return Object.values(value)\r\n                .map(v => normalizeFieldValue(v))\r\n                .filter(Boolean)\r\n                .join(' ');\r\n        }\r\n\r\n        return String(value).toLowerCase().trim();\r\n    } catch (error) {\r\n        console.warn('Error normalizing field value:', error);\r\n        return '';\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieves a nested value from an object using dot notation path.\r\n * Handles arrays and nested objects safely.\r\n */\r\nexport function getNestedValue(\r\n    obj: DocumentContent,\r\n    path: string\r\n): DocumentValue | undefined {\r\n    if (!obj || !path) {\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        const keys = path.split('.');\r\n        let current: DocumentValue | DocumentContent = obj;\r\n\r\n        for (const key of keys) {\r\n            if (!current || typeof current !== 'object') {\r\n                return undefined;\r\n            }\r\n\r\n            if (Array.isArray(current)) {\r\n                // Handle array indexing\r\n                const index = parseInt(key, 10);\r\n                if (isNaN(index)) {\r\n                    return undefined;\r\n                }\r\n                current = current[index];\r\n            } else {\r\n                current = current[key];\r\n            }\r\n        }\r\n\r\n        return current as DocumentValue;\r\n    } catch (error) {\r\n        console.warn(`Error getting nested value for path ${path}:`, error);\r\n        return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Optimizes an array of indexable documents by removing duplicates \r\n * and sorting them efficiently.\r\n * \r\n * @template T - The type of the indexable document.\r\n * @param {T[]} data - Array of indexable documents to optimize.\r\n * @returns {OptimizationResult<T>} Optimized data and optimization statistics.\r\n */\r\nexport function optimizeIndex<T extends IndexedDocument>(\r\n    data: T[]\r\n): OptimizationResult<T> {\r\n    if (!Array.isArray(data)) {\r\n        return {\r\n            data: [],\r\n            stats: {\r\n                originalSize: 0,\r\n                optimizedSize: 0,\r\n                compressionRatio: 1\r\n            }\r\n        };\r\n    }\r\n\r\n    try {\r\n        // Use Map for more efficient duplicate removal\r\n        const uniqueMap = new Map<string, T>();\r\n        \r\n        for (const item of data) {\r\n            const key = JSON.stringify(sortObjectKeys(item));\r\n            uniqueMap.set(key, item);\r\n        }\r\n\r\n        const sorted = Array.from(uniqueMap.values()).sort((a, b) => {\r\n            const aKey = generateSortKey(a);\r\n            const bKey = generateSortKey(b);\r\n            return aKey.localeCompare(bKey);\r\n        });\r\n\r\n        return {\r\n            data: sorted,\r\n            stats: {\r\n                originalSize: data.length,\r\n                optimizedSize: sorted.length,\r\n                compressionRatio: data.length ? sorted.length / data.length : 1\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.warn('Error optimizing index:', error);\r\n        return {\r\n            data: [...data],\r\n            stats: {\r\n                originalSize: data.length,\r\n                optimizedSize: data.length,\r\n                compressionRatio: 1\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to sort object keys recursively for consistent serialization.\r\n */\r\nexport function sortObjectKeys<T extends object>(obj: T): T {\r\n    if (Array.isArray(obj)) {\r\n        return obj.map(sortObjectKeys) as unknown as T;\r\n    }\r\n    \r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    return Object.keys(obj)\r\n        .sort()\r\n        .reduce((sorted, key) => {\r\n            (sorted as any)[key] = sortObjectKeys((obj as any)[key]);\r\n            return sorted;\r\n        }, {} as T);\r\n}\r\n\r\n/**\r\n * Helper function to generate consistent sort keys for documents.\r\n */\r\nexport function generateSortKey(doc: IndexedDocument): string {\r\n    if (!doc.id || !doc.content) {\r\n        return '';\r\n    }\r\n\r\n    try {\r\n        return `${doc.id}:${Object.keys(doc.content).sort().join(',')}`;\r\n    } catch {\r\n        return doc.id;\r\n    }\r\n}\r\n\r\n/**\r\n * Create a document that can be indexed\r\n * @param {Object} params Document parameters\r\n * @param {string} params.id Document ID\r\n * @param {Object} params.fields Document fields\r\n * @param {Object} [params.metadata] Optional metadata\r\n * @returns {Object} Indexed document\r\n */\r\nexport function createDocument({ id, fields, metadata = {} }: { id: string; fields: Record<string, any>; metadata?: Record<string, any> }) {\r\n    return {\r\n        id,\r\n        fields,\r\n        metadata: {\r\n            indexed: Date.now(),\r\n            lastModified: Date.now(),\r\n            ...metadata\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Create a document that can be searched  \r\n */\r\nexport function createSearchableDocument({ id, content, metadata = {} }: { id: string; content: Record<string, DocumentValue>; metadata?: Record<string, DocumentValue> }) {\r\n    return {\r\n        id,\r\n        content,\r\n        metadata\r\n    };\r\n}\r\n\r\n\r\n\r\n/**\r\n * Performs Breadth-First Search traversal on a trie structure with regex matching.\r\n * @param root Starting node of the trie\r\n * @param regex Regular expression to match\r\n * @param maxResults Maximum number of results to return\r\n * @returns Array of matching document IDs with their scores\r\n */\r\nexport function bfsRegexTraversal(\r\n    root: IndexNode,\r\n    regex: RegExp,\r\n    maxResults: number = 10\r\n): Array<{ id: string; score: number }> {\r\n    const results: Array<{ id: string; score: number }> = [];\r\n    const queue: Array<{ node: IndexNode; matched: string }> = [];\r\n    const visited = new Set<string>();\r\n\r\n    // Initialize queue with root node\r\n    queue.push({ node: root, matched: '' });\r\n\r\n    while (queue.length > 0 && results.length < maxResults) {\r\n        const { node, matched } = queue.shift()!;\r\n\r\n        // Check if we've found a complete match\r\n        if (regex.test(matched) && node.id && !visited.has(node.id)) {\r\n            results.push({ id: node.id, score: node.score });\r\n            visited.add(node.id);\r\n        }\r\n\r\n        // Add children to queue\r\n        for (const [char, childNode] of node.children.entries()) {\r\n            queue.push({\r\n                node: childNode,\r\n                matched: matched + char\r\n            });\r\n        }\r\n    }\r\n\r\n    return results.sort((a, b) => b.score - a.score);\r\n}\r\n\r\n/**\r\n * Performs Depth-First Search traversal on a trie structure with regex matching.\r\n * @param root Starting node of the trie\r\n * @param regex Regular expression to match\r\n * @param maxResults Maximum number of results to return\r\n * @returns Array of matching document IDs with their scores\r\n */\r\nexport function dfsRegexTraversal(\r\n    root: IndexNode,\r\n    regex: RegExp,\r\n    maxResults: number = 10\r\n): Array<{ id: string; score: number }> {\r\n    const results: Array<{ id: string; score: number }> = [];\r\n    const visited = new Set<string>();\r\n\r\n    function dfs(node: IndexNode, matched: string): void {\r\n        if (results.length >= maxResults) return;\r\n\r\n        // Check if we've found a complete match\r\n        if (regex.test(matched) && node.id && !visited.has(node.id)) {\r\n            results.push({ id: node.id, score: node.score });\r\n            visited.add(node.id);\r\n        }\r\n\r\n        // Explore children\r\n        for (const [char, childNode] of node.children.entries()) {\r\n            dfs(childNode, matched + char);\r\n        }\r\n    }\r\n\r\n    dfs(root, '');\r\n    return results.sort((a, b) => b.score - a.score);\r\n}","import { SearchOptions, IndexConfig, SearchableDocument } from \"@/types\";\r\nimport { getNestedValue } from \"./SearchUtils\";\r\n\r\nexport function validateSearchOptions(options: SearchOptions): void {\r\n    if (options.maxResults && options.maxResults < 1) {\r\n        throw new Error('maxResults must be greater than 0');\r\n    }\r\n    if (options.threshold && (options.threshold < 0 || options.threshold > 1)) {\r\n        throw new Error('threshold must be between 0 and 1');\r\n    }\r\n    if (options.fields && !Array.isArray(options.fields)) {\r\n        throw new Error('fields must be an array');\r\n    }\r\n}\r\n\r\nexport function validateIndexConfig(config: IndexConfig): void {\r\n    if (!config.name) {\r\n        throw new Error('Index name is required');\r\n    }\r\n    if (!config.version || typeof config.version !== 'number') {\r\n        throw new Error('Valid version number is required');\r\n    }\r\n    if (!Array.isArray(config.fields) || config.fields.length === 0) {\r\n        throw new Error('At least one field must be specified for indexing');\r\n    }\r\n}\r\n\r\nexport function validateDocument(document: SearchableDocument, fields: string[]): boolean {\r\n    return fields.every(field => {\r\n        const value = getNestedValue(document.content, field);\r\n        return value !== undefined;\r\n    });\r\n}","import { IndexMapper } from \"@/mappers\";\r\nimport { \r\n    IndexConfig, \r\n    SearchOptions, \r\n    SearchResult, \r\n    IndexedDocument, \r\n    SearchableDocument, \r\n    SerializedState,\r\n} from \"@/types\";\r\nimport { SerializedIndex } from \"@/types/core\";\r\nimport { DocumentValue } from \"@/types/document\";\r\nimport { createSearchableFields } from \"@/utils\";\r\n\r\nexport class IndexManager {\r\n   getSize() {\r\n        return this.documents.size;\r\n    }\r\n    \r\n    getAllDocuments() {\r\n        return this.documents;\r\n        \r\n    }\r\n    private indexMapper: IndexMapper;\r\n    private config: IndexConfig;\r\n    private documents: Map<string, IndexedDocument>;\r\n\r\n    constructor(config: IndexConfig) {\r\n        this.config = config;\r\n        this.indexMapper = new IndexMapper();\r\n        this.documents = new Map();\r\n    }\r\n\r\n    \r\n\r\n    exportIndex(): SerializedIndex {\r\n        return {\r\n            documents: Array.from(this.documents.entries()).map(([key, value]) => ({\r\n                key,\r\n                value: this.serializeDocument(value)\r\n            })),\r\n            indexState: this.indexMapper.exportState(),\r\n            config: this.config\r\n        };\r\n    }\r\n\r\n    importIndex(data: unknown): void {\r\n        if (!this.isValidIndexData(data)) {\r\n            throw new Error('Invalid index data format');\r\n        }\r\n\r\n        try {\r\n            const typedData = data as SerializedIndex;\r\n            this.documents = new Map(\r\n                typedData.documents.map(item => [item.key, item.value])\r\n            );\r\n            this.config = typedData.config;\r\n            this.indexMapper = new IndexMapper();\r\n            \r\n            if (this.isValidIndexState(typedData.indexState)) {\r\n                this.indexMapper.importState({\r\n                    trie: typedData.indexState.trie,\r\n                    dataMap: typedData.indexState.dataMap\r\n                });\r\n            } else {\r\n                throw new Error('Invalid index state format');\r\n            }\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to import index: ${message}`);\r\n        }\r\n    }\r\n\r\n   \r\n\r\n    clear(): void {\r\n        this.documents.clear();\r\n        this.indexMapper = new IndexMapper();\r\n    }\r\n\r\n    private generateDocumentId(index: number): string {\r\n        return `${this.config.name}-${index}-${Date.now()}`;\r\n    }\r\n\r\n    private isValidIndexData(data: unknown): data is SerializedIndex {\r\n        if (!data || typeof data !== 'object') return false;\r\n        \r\n        const indexData = data as Partial<SerializedIndex>;\r\n        return Boolean(\r\n            indexData.documents &&\r\n            Array.isArray(indexData.documents) &&\r\n            indexData.indexState !== undefined &&\r\n            indexData.config &&\r\n            typeof indexData.config === 'object'\r\n        );\r\n    }\r\n\r\n    private isValidIndexState(state: unknown): state is { trie: SerializedState; dataMap: Record<string, string[]> } {\r\n        return (\r\n            state !== null &&\r\n            typeof state === 'object' &&\r\n            'trie' in state &&\r\n            'dataMap' in state\r\n        );\r\n    }\r\n\r\n    private serializeDocument(doc: IndexedDocument): IndexedDocument {\r\n        return JSON.parse(JSON.stringify(doc));\r\n    }\r\n\r\n    async addDocuments<T extends IndexedDocument>(documents: T[]): Promise<void> {\r\n        for (const doc of documents) {\r\n            // Use document's existing ID if available, otherwise generate new one\r\n            const id = doc.id || this.generateDocumentId(this.documents.size);\r\n\r\n            try {\r\n                // Convert document fields to Record<string, DocumentValue>\r\n                const contentRecord: Record<string, DocumentValue> = {};\r\n                for (const field of this.config.fields) {\r\n                    if (field in doc.fields) {\r\n                        contentRecord[field] = doc.fields[field] as DocumentValue;\r\n                    }\r\n                }\r\n\r\n                // Create searchable document\r\n                const searchableDoc: SearchableDocument = {\r\n                    id,\r\n                    content: createSearchableFields({\r\n                        content: contentRecord,\r\n                        id\r\n                    }, this.config.fields),\r\n                    metadata: doc.metadata\r\n                };\r\n\r\n                // Store original document with ID\r\n                this.documents.set(id, { ...doc, id });\r\n\r\n                // Index the document\r\n                await this.indexMapper.indexDocument(searchableDoc, id, this.config.fields);\r\n            } catch (error) {\r\n                console.warn(`Failed to index document ${id}:`, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    async updateDocument<T extends IndexedDocument>(document: T): Promise<void> {\r\n        const id = document.id;\r\n        if (!this.documents.has(id)) {\r\n            throw new Error(`Document ${id} not found`);\r\n        }\r\n\r\n        try {\r\n            // Update the document in storage\r\n            this.documents.set(id, document);\r\n\r\n            // Convert fields for indexing\r\n            const contentRecord: Record<string, DocumentValue> = {};\r\n            for (const field of this.config.fields) {\r\n                if (field in document.fields) {\r\n                    contentRecord[field] = document.fields[field] as DocumentValue;\r\n                }\r\n            }\r\n\r\n            // Create searchable document\r\n            const searchableDoc: SearchableDocument = {\r\n                id,\r\n                content: createSearchableFields({\r\n                    content: contentRecord,\r\n                    id\r\n                }, this.config.fields),\r\n                metadata: document.metadata\r\n            };\r\n\r\n            // Update the index\r\n            await this.indexMapper.updateDocument(searchableDoc, id, this.config.fields);\r\n        } catch (error) {\r\n            console.error(`Failed to update document ${id}:`, error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async removeDocument(documentId: string): Promise<void> {\r\n        try {\r\n            if (this.documents.has(documentId)) {\r\n                await this.indexMapper.removeDocument(documentId);\r\n                this.documents.delete(documentId);\r\n            }\r\n        } catch (error) {\r\n            console.error(`Failed to remove document ${documentId}:`, error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async search<T extends IndexedDocument>(\r\n        query: string, \r\n        options: SearchOptions = {}\r\n    ): Promise<SearchResult<T>[]> {\r\n        // Handle null or undefined query\r\n        if (!query?.trim()) return [];\r\n\r\n        try {\r\n            const searchResults = await this.indexMapper.search(query, {\r\n                fuzzy: options.fuzzy ?? false,\r\n                maxResults: options.maxResults ?? 10\r\n            });\r\n\r\n            return searchResults\r\n                .filter(result => this.documents.has(result.item))\r\n                .map(result => {\r\n                    const item = this.documents.get(result.item) as T;\r\n                    return {\r\n                        id: item.id,\r\n                        document: item,\r\n                        metadata: item.metadata,\r\n                        item,\r\n                        score: result.score,\r\n                        matches: result.matches\r\n                    };\r\n                })\r\n                .filter(result => result.score >= (options.threshold ?? 0.5));\r\n\r\n        } catch (error) {\r\n            console.error('Search error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    // Helper method for tests to check if a document exists\r\n    hasDocument(id: string): boolean {\r\n        return this.documents.has(id);\r\n    }\r\n}","import { QueryToken } from \"@/types\";\r\n\r\nexport class QueryProcessor {\r\n  private readonly STOP_WORDS = new Set([\r\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for',\r\n    'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on',\r\n    'that', 'the', 'to', 'was', 'were', 'will', 'with'\r\n  ]);\r\n\r\n  process(query: string | null | undefined): string {\r\n    if (query == null) return '';\r\n    if (typeof query !== 'string') return String(query);\r\n\r\n    // Extract quoted phrases\r\n    let tempQuery = query;\r\n    // const quotes = new Map<string, string>();\r\n    let quoteMatch;\r\n    const quoteRegex = /\"[^\"]+\"|\"[^\"]*$/g;\r\n\r\n    while ((quoteMatch = quoteRegex.exec(tempQuery)) !== null) {\r\n      const quote = quoteMatch[0];\r\n      tempQuery = tempQuery.replace(quote, ` ${quote} `);\r\n    }\r\n\r\n    const tokens = this.tokenize(tempQuery);\r\n    const processedTokens = this.processTokens(tokens);\r\n    return this.optimizeQuery(processedTokens);\r\n  }\r\n\r\n  private tokenize(query: string): QueryToken[] {\r\n    return query\r\n      .split(/\\s+/)\r\n      .filter(term => term.length > 0)\r\n      .map(term => {\r\n        // Preserve quotes as-is\r\n        if (term.startsWith('\"') && term.endsWith('\"')) {\r\n          return { type: 'term', value: term };\r\n        }\r\n        return this.classifyToken(term.toLowerCase());\r\n      });\r\n  }\r\n\r\n  private classifyToken(term: string): QueryToken {\r\n    if (term.startsWith('+') || term.startsWith('-')) {\r\n      return { type: 'operator', value: term };\r\n    }\r\n    if (term.includes(':')) {\r\n      return { type: 'modifier', value: term };\r\n    }\r\n    return { type: 'term', value: term };\r\n  }\r\n\r\n  private processTokens(tokens: QueryToken[]): QueryToken[] {\r\n    return tokens\r\n      .filter(token => {\r\n        if (token.type !== 'term') return true;\r\n        if (token.value.startsWith('\"')) return true;\r\n        return !this.STOP_WORDS.has(token.value);\r\n      })\r\n      .map(token => this.normalizeToken(token));\r\n  }\r\n\r\n  private normalizeToken(token: QueryToken): QueryToken {\r\n    if (token.type === 'term' && !token.value.startsWith('\"')) {\r\n      let value = token.value;\r\n      \r\n      // Handle 'ing' ending\r\n      if (value.endsWith('ing')) {\r\n        // Keep root word - remove 'ing' and restore any dropped consonant\r\n        value = value.endsWith('ying') ? value.slice(0, -4) + 'y' :\r\n               value.endsWith('pping') ? value.slice(0, -4) :\r\n               value.slice(0, -3);\r\n      }\r\n      \r\n      // Handle 'ies' plurals\r\n      if (value.endsWith('ies')) {\r\n        value = value.slice(0, -3) + 'y';\r\n      }\r\n      // Handle regular plurals but not words ending in 'ss'\r\n      else if (value.endsWith('s') && !value.endsWith('ss')) {\r\n        value = value.slice(0, -1);\r\n      }\r\n      \r\n      // Handle 'ed' ending\r\n      if (value.endsWith('ed')) {\r\n        value = value.slice(0, -2);\r\n      }\r\n\r\n      return { ...token, value };\r\n    }\r\n    return token;\r\n  }\r\n\r\n  private optimizeQuery(tokens: QueryToken[]): string {\r\n    return tokens\r\n      .map(token => token.value)\r\n      .join(' ')\r\n      .trim()\r\n      .replace(/\\s+/g, ' ');  // normalize spaces\r\n  }\r\n}","import {  CacheManager, IndexedDocument, SearchStorage } from \"@/storage\";\r\nimport { \r\n    SearchOptions, \r\n    SearchResult, \r\n    SearchEngineConfig,\r\n    SearchEventListener,\r\n    SearchEvent,\r\n    IndexNode} from \"@/types\";\r\nimport { validateSearchOptions, createSearchableFields, bfsRegexTraversal, dfsRegexTraversal } from \"@/utils\";\r\nimport { IndexManager } from \"../storage/IndexManager\";\r\nimport { QueryProcessor } from \"./QueryProcessor\";\r\nimport { TrieSearch } from \"@/algorithms/trie\";\r\n\r\nexport class SearchEngine {\r\n    private readonly indexManager: IndexManager;\r\n    private readonly queryProcessor: QueryProcessor;\r\n    private storage: SearchStorage;\r\n    private readonly cache: CacheManager;\r\n    private readonly config: SearchEngineConfig;\r\n    private readonly eventListeners: Set<SearchEventListener>;\r\n    private trie: TrieSearch;\r\n    private isInitialized: boolean = false;\r\n    private documents: Map<string, IndexedDocument>;\r\n    private trieRoot: IndexNode;\r\n\r\n    constructor(config: SearchEngineConfig) {\r\n        this.config = config;\r\n        this.indexManager = new IndexManager(config);\r\n        this.queryProcessor = new QueryProcessor();\r\n        this.storage = new SearchStorage(config.storage);\r\n        this.cache = new CacheManager();\r\n        this.eventListeners = new Set();\r\n        this.trie = new TrieSearch();\r\n        this.documents = new Map();\r\n        this.trieRoot = { id: '', value: '', score: 0, children: new Map() };\r\n    }\r\n\r\n    public async initialize(): Promise<void> {\r\n        if (this.isInitialized) return;\r\n\r\n        try {\r\n            try {\r\n                await this.storage.initialize();\r\n            } catch (storageError) {\r\n                this.emitEvent({\r\n                    type: 'storage:error',\r\n                    timestamp: Date.now(),\r\n                    error: storageError instanceof Error ? storageError : new Error(String(storageError))\r\n                });\r\n                \r\n                this.storage = new SearchStorage({ type: 'memory' });\r\n                await this.storage.initialize();\r\n            }\r\n\r\n            await this.loadIndexes();\r\n            this.isInitialized = true;\r\n\r\n            this.emitEvent({\r\n                type: 'engine:initialized',\r\n                timestamp: Date.now()\r\n            });\r\n        } catch (error) {\r\n            throw new Error(`Failed to initialize search engine: ${String(error)}`);\r\n        }\r\n    }\r\n\r\n    public async addDocuments(documents: IndexedDocument[]): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        this.emitEvent({\r\n            type: 'index:start',\r\n            timestamp: Date.now(),\r\n            data: { documentCount: documents.length }\r\n        });\r\n\r\n        try {\r\n            for (const doc of documents) {\r\n                const docId = doc.id || this.generateDocumentId();\r\n                const indexedDoc = new IndexedDocument(docId, doc.fields, {\r\n                    ...doc.metadata,\r\n                    indexed: Date.now(),\r\n                    lastModified: Date.now()\r\n                });\r\n\r\n                this.documents.set(docId, indexedDoc);\r\n                const searchableContent = createSearchableFields(\r\n                    { content: indexedDoc.fields, id: docId },\r\n                    this.config.fields\r\n                );\r\n\r\n                for (const field of this.config.fields) {\r\n                    if (searchableContent[field]) {\r\n                        const words = searchableContent[field]\r\n                            .toLowerCase()\r\n                            .split(/\\s+/)\r\n                            .filter(Boolean);\r\n\r\n                        for (const word of words) {\r\n                            this.trie.insert(word, docId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            await this.indexManager.addDocuments(documents);\r\n            await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n            this.cache.clear();\r\n\r\n            this.emitEvent({\r\n                type: 'index:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentCount: documents.length }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'index:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to add documents: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async search(\r\n        query: string,\r\n        options: SearchOptions = {}\r\n    ): Promise<SearchResult<IndexedDocument>[]> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        validateSearchOptions(options);\r\n\r\n        const searchStartTime = Date.now();\r\n        this.emitEvent({\r\n            type: 'search:start',\r\n            timestamp: searchStartTime,\r\n            data: { query, options }\r\n        });\r\n\r\n        const cacheKey = this.generateCacheKey(query, options);\r\n        const cachedResults = this.cache.get(cacheKey);\r\n        if (cachedResults) {\r\n            return cachedResults as SearchResult<IndexedDocument>[];\r\n        }\r\n\r\n        try {\r\n            let results: Array<{ id: string; score: number }>;\r\n\r\n            if (options.regex) {\r\n                const regex = typeof options.regex === 'string' ? \r\n                    new RegExp(options.regex) : options.regex;\r\n\r\n                if (this.isComplexRegex(regex)) {\r\n                    results = dfsRegexTraversal(\r\n                        this.trieRoot,\r\n                        regex,\r\n                        options.maxResults || 10\r\n                    );\r\n                } else {\r\n                    results = bfsRegexTraversal(\r\n                        this.trieRoot,\r\n                        regex,\r\n                        options.maxResults || 10\r\n                    );\r\n                }\r\n            } else {\r\n                const processedQuery = this.queryProcessor.process(query);\r\n                const searchTerms = processedQuery.toLowerCase().split(/\\s+/).filter(Boolean);\r\n                results = await this.performBasicSearch(searchTerms, options);\r\n            }\r\n\r\n            const searchResults = await this.processSearchResults(results, options);\r\n            this.cache.set(cacheKey, searchResults);\r\n\r\n            this.emitEvent({\r\n                type: 'search:complete',\r\n                timestamp: Date.now(),\r\n                data: {\r\n                    query,\r\n                    options,\r\n                    resultCount: searchResults.length,\r\n                    searchTime: Date.now() - searchStartTime\r\n                }\r\n            });\r\n\r\n            return searchResults;\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'search:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Search failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async updateDocument(document: IndexedDocument): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        const documentId = document.id;\r\n        if (!documentId || !this.documents.has(documentId)) {\r\n            throw new Error(`Document ${documentId} not found`);\r\n        }\r\n\r\n        try {\r\n            await this.removeDocument(documentId);\r\n            await this.addDocuments([document]);\r\n\r\n            this.emitEvent({\r\n                type: 'update:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentId }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'update:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to update document: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async removeDocument(documentId: string): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        if (!this.documents.has(documentId)) {\r\n            throw new Error(`Document ${documentId} not found`);\r\n        }\r\n\r\n        try {\r\n            this.documents.delete(documentId);\r\n            this.trie.removeData(documentId);\r\n            await this.indexManager.removeDocument(documentId);\r\n            this.cache.clear();\r\n\r\n            try {\r\n                await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n            } catch (storageError) {\r\n                this.emitEvent({\r\n                    type: 'storage:error',\r\n                    timestamp: Date.now(),\r\n                    error: storageError instanceof Error ? storageError : new Error(String(storageError))\r\n                });\r\n            }\r\n\r\n            this.emitEvent({\r\n                type: 'remove:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentId }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'remove:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to remove document: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async clearIndex(): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            await this.storage.clearIndices();\r\n            this.documents.clear();\r\n            this.trie = new TrieSearch();\r\n            this.indexManager.clear();\r\n            this.cache.clear();\r\n\r\n            this.emitEvent({\r\n                type: 'index:clear',\r\n                timestamp: Date.now()\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'index:clear:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to clear index: ${error}`);\r\n        }\r\n    }\r\n\r\n    private async performBasicSearch(\r\n        searchTerms: string[],\r\n        options: SearchOptions\r\n    ): Promise<Array<{ id: string; score: number }>> {\r\n        const results = new Map<string, { score: number; matches: Set<string> }>();\r\n\r\n        for (const term of searchTerms) {\r\n            const matches = options.fuzzy ?\r\n                this.trie.fuzzySearch(term) :\r\n                this.trie.search(term);\r\n\r\n            for (const docId of matches) {\r\n                const current = results.get(docId) || { score: 0, matches: new Set<string>() };\r\n                current.score += this.calculateTermScore(term, docId, options);\r\n                current.matches.add(term);\r\n                results.set(docId, current);\r\n            }\r\n        }\r\n\r\n        return Array.from(results.entries())\r\n            .map(([id, { score }]) => ({ id, score }))\r\n            .sort((a, b) => b.score - a.score);\r\n    }\r\n\r\n    private async processSearchResults(\r\n        results: Array<{ id: string; score: number }>,\r\n        options: SearchOptions\r\n    ): Promise<SearchResult<IndexedDocument>[]> {\r\n        const processedResults: SearchResult<IndexedDocument>[] = [];\r\n\r\n        for (const { id, score } of results) {\r\n            const doc = this.documents.get(id);\r\n            if (!doc) continue;\r\n\r\n            const searchResult: SearchResult<IndexedDocument> = {\r\n                id,\r\n                item: doc,\r\n\r\n                score: this.normalizeScore(score),\r\n                matches: [],\r\n                metadata: {\r\n                    ...doc.metadata,\r\n                    lastAccessed: Date.now()\r\n                },\r\n                document: doc\r\n            };\r\n\r\n            if (options.includeMatches) {\r\n                searchResult.matches = this.extractMatches(doc, options);\r\n            }\r\n\r\n            processedResults.push(searchResult);\r\n        }\r\n\r\n        return this.applyPagination(processedResults, options);\r\n    }\r\n\r\n    private calculateTermScore(term: string, docId: string, options: SearchOptions): number {\r\n        const doc = this.documents.get(docId);\r\n        if (!doc) return 0;\r\n\r\n        const searchFields = options.fields || this.config.fields;\r\n        let score = 0;\r\n\r\n        for (const field of searchFields) {\r\n            const fieldContent = String(doc.fields[field] || '').toLowerCase();\r\n            const fieldBoost = (options.boost?.[field] || 1);\r\n            const termFrequency = (fieldContent.match(new RegExp(term, 'gi')) || []).length;\r\n            score += termFrequency * fieldBoost;\r\n        }\r\n\r\n        return score;\r\n    }\r\n\r\n    private normalizeScore(score: number): number {\r\n        return Math.min(Math.max(score / 100, 0), 1);\r\n    }\r\n\r\n    private extractMatches(doc: IndexedDocument, options: SearchOptions): string[] {\r\n        const matches = new Set<string>();\r\n        const searchFields = options.fields || this.config.fields;\r\n\r\n        for (const field of searchFields) {\r\n            const fieldContent = String(doc.fields[field] || '').toLowerCase();\r\n            \r\n            if (options.regex) {\r\n                const regex = typeof options.regex === 'string' ?\r\n                    new RegExp(options.regex, 'gi') :\r\n                    new RegExp(options.regex.source, 'gi');\r\n                \r\n                const fieldMatches = fieldContent.match(regex) || [];\r\n                fieldMatches.forEach(match => matches.add(match));\r\n            }\r\n        }\r\n\r\n        return Array.from(matches);\r\n    }\r\n\r\n    private applyPagination(\r\n        results: SearchResult<IndexedDocument>[],\r\n        options: SearchOptions\r\n    ): SearchResult<IndexedDocument>[] {\r\n        const page = options.page || 1;\r\n        const pageSize = options.pageSize || 10;\r\n        const start = (page - 1) * pageSize;\r\n        return results.slice(start, start + pageSize);\r\n    }\r\n\r\n    private isComplexRegex(regex: RegExp): boolean {\r\n        const pattern = regex.source;\r\n        return (\r\n            pattern.includes('{') || \r\n            pattern.includes('+') || \r\n            pattern.includes('*') || \r\n            pattern.includes('?') || \r\n            pattern.includes('|') || \r\n            pattern.includes('(?') || \r\n            pattern.includes('[')\r\n        );\r\n    }\r\n\r\n    private async loadIndexes(): Promise<void> {\r\n        try {\r\n            const storedIndex = await this.storage.getIndex(this.config.name);\r\n            if (storedIndex) {\r\n                this.indexManager.importIndex(storedIndex);\r\n                const indexedDocs = this.indexManager.getAllDocuments();\r\n                for (const doc of indexedDocs) {\r\n                    this.documents.set(doc[1].id, IndexedDocument.fromObject(doc[1]));\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.warn('Failed to load stored index, starting fresh:', error);\r\n        }\r\n    }\r\n\r\n    private generateCacheKey(query: string, options: SearchOptions): string {\r\n        return `${this.config.name}-${query}-${JSON.stringify(options)}`;\r\n    }\r\n\r\n    private generateDocumentId(): string {\r\n        return `${this.config.name}-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\r\n    }\r\n\r\n    public addEventListener(listener: SearchEventListener): void {\r\n        this.eventListeners.add(listener);\r\n    }\r\n\r\n    public removeEventListener(listener: SearchEventListener): void {\r\n        this.eventListeners.delete(listener);\r\n    }\r\n\r\n    private emitEvent(event: SearchEvent): void {\r\n        this.eventListeners.forEach(listener => {\r\n            try {\r\n                listener(event);\r\n            } catch (error) {\r\n                console.error('Error in event listener:', error);\r\n            }\r\n        });\r\n    }\r\n\r\n    public async close(): Promise<void> {\r\n        try { \r\n        await this.storage.close();\r\n        this.cache.clear();\r\n        this.documents.clear();\r\n        this.isInitialized = false;\r\n\r\n        this.emitEvent({\r\n            type: 'engine:closed',\r\n            timestamp: Date.now()\r\n        });\r\n    } catch (error) {\r\n        console.warn('Error during close:', error);\r\n    }\r\n}\r\n\r\npublic getIndexedDocumentCount(): number {\r\n    return this.documents.size;\r\n}\r\n\r\npublic getTrieState(): unknown {\r\n    return this.trie.exportState();\r\n}\r\n\r\npublic async bulkUpdate(updates: Map<string, Partial<IndexedDocument>>): Promise<void> {\r\n    if (!this.isInitialized) {\r\n        await this.initialize();\r\n    }\r\n\r\n    const updatePromises: Promise<void>[] = [];\r\n\r\n    for (const [id, update] of updates) {\r\n        const existingDoc = this.documents.get(id);\r\n        if (existingDoc) {\r\n            const updatedDoc = new IndexedDocument(\r\n                id,\r\n                { ...existingDoc.fields, ...update.fields },\r\n                { ...existingDoc.metadata, ...update.metadata }\r\n            );\r\n            updatePromises.push(this.updateDocument(updatedDoc));\r\n        }\r\n    }\r\n\r\n    try {\r\n        await Promise.all(updatePromises);\r\n        this.emitEvent({\r\n            type: 'bulk:update:complete',\r\n            timestamp: Date.now(),\r\n            data: { updateCount: updates.size }\r\n        });\r\n    } catch (error) {\r\n        this.emitEvent({\r\n            type: 'bulk:update:error',\r\n            timestamp: Date.now(),\r\n            error: error instanceof Error ? error : new Error(String(error))\r\n        });\r\n        throw new Error(`Bulk update failed: ${error}`);\r\n    }\r\n}\r\n\r\npublic async importIndex(indexData: unknown): Promise<void> {\r\n    if (!this.isInitialized) {\r\n        await this.initialize();\r\n    }\r\n\r\n    try {\r\n        await this.clearIndex();\r\n        this.indexManager.importIndex(indexData);\r\n       \r\n        const indexedDocuments = Array.from(this.documents.values()).map(doc => IndexedDocument.fromObject(doc));\r\n\r\n        await this.addDocuments(indexedDocuments);\r\n\r\n        this.emitEvent({\r\n            type: 'import:complete',\r\n            timestamp: Date.now(),\r\n            data: { documentCount: this.documents.size }\r\n        });\r\n    } catch (error) {\r\n        this.emitEvent({\r\n            type: 'import:error',\r\n            timestamp: Date.now(),\r\n            error: error instanceof Error ? error : new Error(String(error))\r\n        });\r\n        throw new Error(`Import failed: ${error}`);\r\n    }\r\n}\r\n\r\npublic exportIndex(): unknown {\r\n    if (!this.isInitialized) {\r\n        throw new Error('Search engine not initialized');\r\n    }\r\n    return this.indexManager.exportIndex();\r\n}\r\n\r\npublic getDocument(id: string): IndexedDocument | undefined {\r\n    return this.documents.get(id);\r\n}\r\n\r\npublic getAllDocuments(): IndexedDocument[] {\r\n    return Array.from(this.documents.values());\r\n}\r\n\r\npublic async reindexAll(): Promise<void> {\r\n    if (!this.isInitialized) {\r\n        await this.initialize();\r\n    }\r\n\r\n    try {\r\n        const documents = this.getAllDocuments();\r\n        await this.clearIndex();\r\n        await this.addDocuments(documents);\r\n\r\n        this.emitEvent({\r\n            type: 'reindex:complete',\r\n            timestamp: Date.now(),\r\n            data: { documentCount: documents.length }\r\n        });\r\n    } catch (error) {\r\n        this.emitEvent({\r\n            type: 'reindex:error',\r\n            timestamp: Date.now(),\r\n            error: error instanceof Error ? error : new Error(String(error))\r\n        });\r\n        throw new Error(`Reindex failed: ${error}`);\r\n    }\r\n}\r\n\r\npublic async optimizeIndex(): Promise<void> {\r\n    if (!this.isInitialized) {\r\n        await this.initialize();\r\n    }\r\n\r\n    try {\r\n        // Trigger cache cleanup\r\n        this.cache.clear();\r\n\r\n        // Compact storage if possible\r\n        if (this.storage instanceof SearchStorage) {\r\n            await this.storage.clearIndices();\r\n            await this.storage.storeIndex(\r\n                this.config.name,\r\n                this.indexManager.exportIndex()\r\n            );\r\n        }\r\n\r\n        this.emitEvent({\r\n            type: 'optimize:complete',\r\n            timestamp: Date.now()\r\n        });\r\n    } catch (error) {\r\n        this.emitEvent({\r\n            type: 'optimize:error',\r\n            timestamp: Date.now(),\r\n            error: error instanceof Error ? error : new Error(String(error))\r\n        });\r\n        throw new Error(`Optimization failed: ${error}`);\r\n    }\r\n}\r\n\r\npublic getStats(): {\r\n    documentCount: number;\r\n    indexSize: number;\r\n    cacheSize: number;\r\n    initialized: boolean;\r\n} {\r\n    return {\r\n        documentCount: this.documents.size,\r\n        indexSize: this.indexManager.getSize(),\r\n        cacheSize: this.cache.getSize(),\r\n        initialized: this.isInitialized\r\n    };\r\n}\r\n\r\npublic isReady(): boolean {\r\n    return this.isInitialized;\r\n}\r\n}","export class SearchError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'SearchError';\r\n  }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class StorageError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'StorageError';\r\n  }\r\n}","export type SearchEventType =\r\n    // Engine lifecycle events\r\n    | 'engine:initialized'\r\n    | 'engine:closed'\r\n    \r\n    // Index operations\r\n    | 'index:start'\r\n    | 'index:complete'\r\n    | 'index:error'\r\n    | 'index:clear'\r\n    | 'index:clear:error'\r\n    \r\n    // Search operations\r\n    | 'search:start'\r\n    | 'search:complete'\r\n    | 'search:error'\r\n    \r\n    // Document operations\r\n    | 'update:start'\r\n    | 'update:complete'\r\n    | 'update:error'\r\n    | 'remove:start'\r\n    | 'remove:complete'\r\n    | 'remove:error'\r\n    \r\n    // Bulk operations\r\n    | 'bulk:update:start'\r\n    | 'bulk:update:complete'\r\n    | 'bulk:update:error'\r\n    \r\n    // Import/Export operations\r\n    | 'import:start'\r\n    | 'import:complete'\r\n    | 'import:error'\r\n    | 'export:start'\r\n    | 'export:complete'\r\n    | 'export:error'\r\n    \r\n    // Optimization operations\r\n    | 'optimize:start'\r\n    | 'optimize:complete'\r\n    | 'optimize:error'\r\n    \r\n    // Reindex operations\r\n    | 'reindex:start'\r\n    | 'reindex:complete'\r\n    | 'reindex:error'\r\n    \r\n    // Storage operations\r\n    | 'storage:error'\r\n    | 'storage:clear'\r\n    | 'storage:clear:error';\r\n\r\nexport interface BaseEvent {\r\n    timestamp: number;\r\n    region?: string;\r\n}\r\n\r\nexport interface SuccessEvent extends BaseEvent {\r\n    data?: {\r\n        documentCount?: number;\r\n        searchTime?: number;\r\n        resultCount?: number;\r\n        documentId?: string;\r\n        updateCount?: number;\r\n        query?: string;\r\n        options?: unknown;\r\n    };\r\n}\r\n\r\nexport interface ErrorEvent extends BaseEvent {\r\n    error: Error;\r\n    details?: {\r\n        documentId?: string;\r\n        operation?: string;\r\n        phase?: string;\r\n    };\r\n}\r\n\r\nexport interface SearchEvent extends BaseEvent {\r\n    type: SearchEventType;\r\n    data?: unknown;\r\n    error?: Error;\r\n    regex?: RegExp;\r\n}\r\n\r\nexport interface IndexNode {\r\n    id?: string;\r\n    value?: unknown;\r\n    score: number;\r\n    children: Map<string, IndexNode>;\r\n}\r\n\r\nexport interface SearchEventListener {\r\n    (event: SearchEvent): void;\r\n}\r\n\r\nexport interface SearchEventEmitter {\r\n    addEventListener(listener: SearchEventListener): void;\r\n    removeEventListener(listener: SearchEventListener): void;\r\n    emitEvent(event: SearchEvent): void;\r\n}\r\n\r\nexport class SearchEventError extends Error {\r\n    constructor(\r\n        message: string,\r\n        public readonly type: SearchEventType,\r\n        public readonly details?: unknown\r\n    ) {\r\n        super(message);\r\n        this.name = 'SearchEventError';\r\n    }\r\n}","import { SearchResult } from \"./search\";\r\n\r\nexport interface CacheOptions {\r\n    maxSize: number;\r\n    ttlMinutes: number;\r\n}\r\nexport interface CacheEntry {\r\n    data: SearchResult<unknown>[];\r\n    timestamp: number;\r\n    lastAccessed: number;\r\n    accessCount: number;\r\n}\r\n\r\n\r\n\r\nexport interface CacheOptions {\r\n    strategy: CacheStrategyType;\r\n    maxSize: number;\r\n    ttlMinutes: number;\r\n}\r\n\r\nexport enum CacheStrategyType {\r\n    LRU = 'LRU',\r\n    MRU = 'MRU'\r\n  }\r\n\r\n  export type CacheStrategy = keyof typeof CacheStrategyType;\r\n  \r\n  export interface CacheStatus {\r\n    size: number;\r\n    maxSize: number;\r\n    strategy: CacheStrategy;\r\n    ttl: number;\r\n    utilization: number;\r\n    oldestEntryAge: number | null;\r\n    newestEntryAge: number | null;\r\n    memoryUsage: {\r\n        bytes: number;\r\n        formatted: string;\r\n    };\r\n}","/// <reference types=\"node\"/>\r\nimport type {\r\n    IndexConfig,\r\n    SearchContext,\r\n    SearchOptions,\r\n    SearchResult,\r\n    SearchStats,\r\n    SearchEventType,\r\n    SearchEvent,\r\n    DocumentLink,\r\n    DocumentRank,\r\n} from './types/index';\r\nimport { DEFAULT_SEARCH_OPTIONS , DEFAULT_INDEX_OPTIONS} from './types/defaults';\r\n// Export type declarations\r\nexport { DocumentLink, DocumentRank, SearchEvent, SearchEventType, SearchStats, SearchContext };\r\n\r\n// Core imports\r\nimport { SearchEngine } from '@core/SearchEngine';\r\nimport { IndexManager } from '@storage/IndexManager';\r\nimport { QueryProcessor } from '@core/QueryProcessor';\r\n\r\n// Algorithm imports\r\nimport { TrieNode } from '@algorithms/trie/TrieNode';\r\nimport { TrieSearch } from '@algorithms/trie/TrieSearch';\r\n\r\n// Mapper imports\r\nimport { DataMapper } from '@/mappers/DataMapper';\r\nimport { IndexMapper } from '@/mappers/IndexMapper';\r\n\r\n// Storage imports\r\nimport { CacheManager } from '@storage/CacheManager';\r\nimport { IndexedDB } from '@storage/IndexedDBService';\r\n\r\n// Utility imports\r\nimport {\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n} from '@utils/index';\r\n\r\n// Export all types\r\nexport * from './types/';\r\n\r\n\r\n// Custom error classes\r\nexport class SearchError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'SearchError';\r\n    }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'IndexError';\r\n    }\r\n}\r\n\r\n// Type guards with improved type checking\r\nexport function isSearchOptions(obj: unknown): obj is SearchOptions {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const options = obj as Partial<SearchOptions>;\r\n    \r\n    return (\r\n        (typeof options.fuzzy === 'undefined' || typeof options.fuzzy === 'boolean') &&\r\n        (typeof options.maxResults === 'undefined' || typeof options.maxResults === 'number') &&\r\n        (typeof options.threshold === 'undefined' || typeof options.threshold === 'number') &&\r\n        (typeof options.fields === 'undefined' || Array.isArray(options.fields)) &&\r\n        (typeof options.sortBy === 'undefined' || typeof options.sortBy === 'string') &&\r\n        (typeof options.sortOrder === 'undefined' || ['asc', 'desc'].includes(options.sortOrder)) &&\r\n        (typeof options.page === 'undefined' || typeof options.page === 'number') &&\r\n        (typeof options.pageSize === 'undefined' || typeof options.pageSize === 'number') &&\r\n        (typeof options.regex === 'undefined' || typeof options.regex === 'string' || options.regex instanceof RegExp) &&\r\n        (typeof options.boost === 'undefined' || (typeof options.boost === 'object' && options.boost !== null))\r\n    );\r\n}\r\n\r\nexport function isIndexConfig(obj: unknown): obj is IndexConfig {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const config = obj as Partial<IndexConfig>;\r\n    \r\n    return Boolean(\r\n        typeof config.name === 'string' &&\r\n        typeof config.version === 'number' &&\r\n        Array.isArray(config.fields)\r\n    );\r\n}\r\n\r\nexport function isSearchResult<T>(obj: unknown): obj is SearchResult<T> {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const result = obj as Partial<SearchResult<T>>;\r\n    \r\n    return Boolean(\r\n        'id' in result &&\r\n        'item' in result &&\r\n        'document' in result &&\r\n        typeof result.score === 'number' &&\r\n        Array.isArray(result.matches)\r\n    );\r\n}\r\n\r\n// Global type declaration\r\ndeclare global {\r\n    interface Window {\r\n        NexusSearch: typeof NexusSearchNamespace;\r\n    }\r\n}\r\n\r\n\r\n// Create namespace with proper type definition\r\nconst NexusSearchNamespace = {\r\n    DEFAULT_INDEX_OPTIONS,\r\n    DEFAULT_SEARCH_OPTIONS,\r\n    SearchError,\r\n    IndexError,\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    isSearchOptions,\r\n    isIndexConfig,\r\n    isSearchResult,\r\n} as const;\r\n\r\n// Export individual components\r\nexport {\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    DataMapper,\r\n    IndexMapper,\r\n    CacheManager,\r\n    IndexedDB,\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n};\r\n\r\n// Browser environment check and global initialization\r\nif (typeof window !== 'undefined') {\r\n    window.NexusSearch = NexusSearchNamespace;\r\n}\r\n\r\n// Export namespace\r\nexport const NexusSearch = NexusSearchNamespace;\r\nexport default NexusSearch;","// src/constants/defaults.ts\r\nimport { SearchOptions } from '../types/search';\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n    // Basic search options\r\n    fuzzy: false,\r\n    fields: [],\r\n    boost: {}, // Empty object to satisfy Required type\r\n    maxResults: 10,\r\n    threshold: 0.5,\r\n\r\n    // Sorting and pagination\r\n    sortBy: 'score',\r\n    sortOrder: 'desc',\r\n    page: 1,\r\n    pageSize: 10,\r\n\r\n    // Advanced features\r\n    regex: '',\r\n    highlight: false,\r\n\r\n    // Result customization\r\n    includeMatches: false,\r\n    includeScore: false,\r\n    includeStats: false\r\n};\r\n\r\nexport const DEFAULT_INDEX_OPTIONS = {\r\n    fields: []\r\n};\r\n\r\n\r\n// Helper function to merge options\r\nexport function mergeSearchOptions(\r\n    options?: Partial<SearchOptions>\r\n): Required<SearchOptions> {\r\n    return {\r\n        ...DEFAULT_SEARCH_OPTIONS,\r\n        ...options,\r\n        // Ensure boost is always an object\r\n        boost: options?.boost || {}\r\n    };\r\n}\r\n\r\n// Type guard for search options\r\nexport function isValidSearchOptions(options: unknown): options is SearchOptions {\r\n    if (!options || typeof options !== 'object') return false;\r\n    const opt = options as Partial<SearchOptions>;\r\n    \r\n    return (\r\n        (opt.fuzzy === undefined || typeof opt.fuzzy === 'boolean') &&\r\n        (opt.fields === undefined || Array.isArray(opt.fields)) &&\r\n        (opt.boost === undefined || (typeof opt.boost === 'object' && opt.boost !== null)) &&\r\n        (opt.maxResults === undefined || typeof opt.maxResults === 'number') &&\r\n        (opt.threshold === undefined || typeof opt.threshold === 'number') &&\r\n        (opt.sortBy === undefined || typeof opt.sortBy === 'string') &&\r\n        (opt.sortOrder === undefined || ['asc', 'desc'].includes(opt.sortOrder)) &&\r\n        (opt.page === undefined || typeof opt.page === 'number') &&\r\n        (opt.pageSize === undefined || typeof opt.pageSize === 'number') &&\r\n        (opt.regex === undefined || typeof opt.regex === 'string' || opt.regex instanceof RegExp) &&\r\n        (opt.highlight === undefined || typeof opt.highlight === 'boolean') &&\r\n        (opt.includeMatches === undefined || typeof opt.includeMatches === 'boolean') &&\r\n        (opt.includeScore === undefined || typeof opt.includeScore === 'boolean') &&\r\n        (opt.includeStats === undefined || typeof opt.includeStats === 'boolean')\r\n    );\r\n}","import { SearchDBSchema, IndexConfig, MetadataEntry } from \"@/types\";\r\nimport { IDBPDatabase, openDB } from \"idb\";\r\n\r\nexport class IndexedDB {\r\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n    private readonly DB_NAME = 'nexus_search_db';\r\n    private readonly DB_VERSION = 1;\r\n    private initPromise: Promise<void> | null = null;\r\n\r\n    constructor() {\r\n        this.initPromise = this.initialize();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        if (this.db) return;\r\n\r\n        try {\r\n            this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n                upgrade(db) {\r\n                    // Handle version upgrades\r\n                    if (!db.objectStoreNames.contains('searchIndices')) {\r\n                        const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n                        indexStore.createIndex('timestamp', 'timestamp');\r\n                    }\r\n\r\n                    if (!db.objectStoreNames.contains('metadata')) {\r\n                        const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n                        metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n                    }\r\n                },\r\n                blocked() {\r\n                    console.warn('Database upgrade was blocked');\r\n                },\r\n                blocking() {\r\n                    console.warn('Current database version is blocking a newer version');\r\n                },\r\n                terminated() {\r\n                    console.error('Database connection was terminated');\r\n                }\r\n            });\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Storage initialization failed: ${message}`);\r\n        }\r\n    }\r\n\r\n    private async ensureConnection(): Promise<void> {\r\n        if (this.initPromise) {\r\n            await this.initPromise;\r\n        }\r\n\r\n        if (!this.db) {\r\n            throw new Error('Database connection not available');\r\n        }\r\n    }\r\n\r\n    async storeIndex(key: string, data: unknown): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const entry = {\r\n                id: key,\r\n                data,\r\n                timestamp: Date.now(),\r\n            };\r\n\r\n            await this.db!.put('searchIndices', entry);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to store index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async getIndex(key: string): Promise<unknown | null> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const entry = await this.db!.get('searchIndices', key);\r\n            return entry?.data ?? null;\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to retrieve index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async updateMetadata(config: IndexConfig): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const metadata: MetadataEntry = {\r\n                id: 'config',\r\n                config,\r\n                lastUpdated: Date.now()\r\n            };\r\n\r\n            await this.db!.put('metadata', metadata);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to update metadata: ${message}`);\r\n        }\r\n    }\r\n\r\n    async getMetadata(): Promise<MetadataEntry | null> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const result = await this.db!.get('metadata', 'config');\r\n            return result ?? null;\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to retrieve metadata: ${message}`);\r\n        }\r\n    }\r\n\r\n    async clearIndices(): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            await this.db!.clear('searchIndices');\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to clear indices: ${message}`);\r\n        }\r\n    }\r\n\r\n    async deleteIndex(key: string): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            await this.db!.delete('searchIndices', key);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to delete index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async close(): Promise<void> {\r\n        if (this.db) {\r\n            this.db.close();\r\n            this.db = null;\r\n        }\r\n    }\r\n}\r\n\r\nexport class SearchStorage {\r\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n    private readonly DB_NAME = 'nexus_search_db';\r\n    private readonly DB_VERSION = 1;\r\n    private initPromise: Promise<void> | null = null;\r\n\r\n    constructor() {\r\n        this.initPromise = this.initialize();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        if (this.db) return;\r\n\r\n        try {\r\n            this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n                upgrade(db) {\r\n                    if (!db.objectStoreNames.contains('searchIndices')) {\r\n                        const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n                        indexStore.createIndex('timestamp', 'timestamp');\r\n                    }\r\n\r\n                    if (!db.objectStoreNames.contains('metadata')) {\r\n                        const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n                        metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n                    }\r\n                },\r\n                blocked() {\r\n                    console.warn('Database upgrade was blocked');\r\n                },\r\n                blocking() {\r\n                    console.warn('Current database version is blocking a newer version');\r\n                },\r\n                terminated() {\r\n                    console.error('Database connection was terminated');\r\n                }\r\n            });\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Storage initialization failed: ${message}`);\r\n        }\r\n    }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n    \r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n  \r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        id: 'config', // Set id field directly\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n  \r\n      await this.db!.put('metadata', metadata); // Use metadata directly\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n  \r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const result = await this.db!.get('metadata', 'config');\r\n      return result || null; // Return `null` if `result` is `undefined`\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}\r\n","import { MetricsResult, PerformanceMetric } from \"@/types\";\r\n\r\nexport class PerformanceMonitor {\r\n    private metrics: Map<string, number[]>;\r\n\r\n    constructor() {\r\n        this.metrics = new Map();\r\n    }\r\n\r\n    async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {\r\n        const start = performance.now();\r\n        try {\r\n            return await fn();\r\n        } finally {\r\n            const duration = performance.now() - start;\r\n            this.recordMetric(name, duration);\r\n        }\r\n    }\r\n\r\n    private recordMetric(name: string, duration: number): void {\r\n        if (!this.metrics.has(name)) {\r\n            this.metrics.set(name, []);\r\n        }\r\n        this.metrics.get(name)!.push(duration);\r\n    }\r\n\r\n    getMetrics(): MetricsResult {\r\n        const results: MetricsResult = {};\r\n\r\n        this.metrics.forEach((durations, name) => {\r\n            results[name] = {\r\n                avg: this.average(durations),\r\n                min: Math.min(...durations),\r\n                max: Math.max(...durations),\r\n                count: durations.length\r\n            } as PerformanceMetric;\r\n        });\r\n\r\n        return results;\r\n    }\r\n\r\n    private average(numbers: number[]): number {\r\n        return numbers.reduce((a, b) => a + b, 0) / numbers.length;\r\n    }\r\n\r\n    clear(): void {\r\n        this.metrics.clear();\r\n    }\r\n}"],"names":["CacheManager","getSize","this","cache","size","getStatus","timestamps","Array","from","values","map","entry","timestamp","now","Date","memoryBytes","calculateMemoryUsage","maxSize","strategy","ttl","utilization","oldestEntryAge","length","Math","min","newestEntryAge","max","memoryUsage","bytes","formatted","formatBytes","totalSize","key","entries","estimateDataSize","data","accessOrder","result","matches","join","JSON","stringify","item","metadata","units","unitIndex","toFixed","constructor","ttlMinutes","initialStrategy","Map","stats","hits","misses","evictions","set","evict","lastAccessed","accessCount","updateAccessOrder","get","isExpired","delete","removeFromAccessOrder","clear","getStats","hitRate","keyToEvict","findLRUKey","findMRUKey","push","unshift","index","indexOf","splice","setStrategy","newStrategy","forEach","prune","prunedCount","analyze","totalAccesses","totalAccessCount","accessCounts","averageAccessCount","mostAccessedKeys","sort","a","b","slice","count","SearchStorage","options","type","db","memoryStorage","storageType","determineStorageType","isIndexedDBAvailable","indexedDB","_a","initialize","openDB","upgrade","createObjectStore","keyPath","createIndex","error","console","warn","storeIndex","name","put","id","getIndex","clearIndices","close","IndexedDocument","fields","versions","relations","normalizeFields","normalizeMetadata","normalizedFields","title","content","author","tags","version","undefined","indexed","lastModified","toObject","document","clone","update","updates","updatedFields","Object","value","getField","field","setField","create","fromObject","obj","toJSON","toString","DataMapper","dataMap","mapData","documentId","has","Set","add","getDocuments","getDocumentById","documents","getAllKeys","keys","removeDocument","removeKey","exportState","serializedMap","importState","state","TrieNode","children","isEndOfWord","documentRefs","weight","TrieSearch","root","documentLinks","insert","text","words","toLowerCase","split","filter","Boolean","word","current","char","search","query","maxResults","results","found","collectDocumentRefs","remove","node","removeHelper","child","linkDocument","links","getDocumentLinks","removeData","fuzzySearch","maxDistance","fuzzySearchHelper","docId","currentWord","calculateLevenshteinDistance","childNode","newDistance","s1","s2","dp","fill","i","j","trie","serializeNode","deserializeNode","serialized","childData","IndexMapper","dataMapper","trieSearch","indexDocument","tokenizeText","fuzzy","searchTerms","documentScores","term","score","calculateScore","Error","replace","addDocument","updateDocument","createSearchableFields","isArray","searchableFields","getNestedValue","normalizeFieldValue","trim","v","String","path","parseInt","isNaN","sortObjectKeys","reduce","sorted","generateSortKey","doc","validateSearchOptions","threshold","IndexManager","getAllDocuments","config","indexMapper","exportIndex","serializeDocument","indexState","importIndex","isValidIndexData","typedData","isValidIndexState","message","generateDocumentId","indexData","parse","addDocuments","contentRecord","searchableDoc","_b","hasDocument","QueryProcessor","STOP_WORDS","process","quoteMatch","tempQuery","quoteRegex","exec","quote","tokens","tokenize","processedTokens","processTokens","optimizeQuery","startsWith","endsWith","classifyToken","includes","token","normalizeToken","SearchEngine","isInitialized","indexManager","queryProcessor","storage","eventListeners","trieRoot","storageError","emitEvent","loadIndexes","documentCount","indexedDoc","searchableContent","searchStartTime","cacheKey","generateCacheKey","cachedResults","regex","RegExp","isComplexRegex","visited","dfs","matched","test","dfsRegexTraversal","queue","shift","bfsRegexTraversal","performBasicSearch","searchResults","processSearchResults","resultCount","searchTime","clearIndex","calculateTermScore","processedResults","searchResult","normalizeScore","includeMatches","extractMatches","applyPagination","searchFields","fieldContent","fieldBoost","boost","match","source","page","pageSize","start","pattern","storedIndex","indexedDocs","random","substring","addEventListener","listener","removeEventListener","event","getIndexedDocumentCount","getTrieState","bulkUpdate","updatePromises","existingDoc","updatedDoc","Promise","all","updateCount","indexedDocuments","getDocument","reindexAll","optimizeIndex","indexSize","cacheSize","initialized","isReady","ValidationError","super","StorageError","SearchEventError","details","CacheStrategyType","SearchError","IndexError","isSearchOptions","sortBy","sortOrder","isIndexConfig","isSearchResult","NexusSearchNamespace","DEFAULT_INDEX_OPTIONS","DEFAULT_SEARCH_OPTIONS","highlight","includeScore","includeStats","window","NexusSearch","DB_NAME","DB_VERSION","initPromise","objectStoreNames","contains","blocked","blocking","terminated","ensureConnection","updateMetadata","lastUpdated","getMetadata","deleteIndex","metrics","measure","fn","performance","duration","recordMetric","getMetrics","durations","avg","average","numbers","originalSize","optimizedSize","compressionRatio","uniqueMap","aKey","bKey","localeCompare","every"],"mappings":"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"}