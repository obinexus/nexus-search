{"version":3,"file":"index.umd.js","sources":["../src/storage/CacheManager.ts","../node_modules/idb/build/index.js","../src/storage/IndexedDBService.ts","../src/utils/SearchUtils.ts","../src/utils/ValidationUtils.ts","../src/mappers/DataMapper.ts","../src/algorithms/trie/TrieNode.ts","../src/algorithms/trie/TrieSearch.ts","../src/mappers/IndexMapper.ts","../src/core/IndexManager.ts","../src/core/QueryProcessor.ts","../src/core/SearchEngine.ts","../src/types/errors.ts","../src/index.ts","../src/utils/PerformanceUtils.ts"],"sourcesContent":["import { SearchResult } from \"@/types\";\r\n\r\n\r\n\r\nexport class CacheManager {\r\n  private cache: Map<string, { data: SearchResult<any>[]; timestamp: number }>;\r\n  private readonly maxSize: number;\r\n  private readonly ttl: number; // Time to live in milliseconds\r\n\r\n  constructor(maxSize: number = 1000, ttlMinutes: number = 5) {\r\n    this.cache = new Map();\r\n    this.maxSize = maxSize;\r\n    this.ttl = ttlMinutes * 60 * 1000;\r\n  }\r\n\r\n  set(key: string, data: SearchResult<any>[]): void {\r\n    if (this.cache.size >= this.maxSize) {\r\n      this.evictOldest();\r\n    }\r\n\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: Date.now(),\r\n    });\r\n  }\r\n\r\n  get(key: string): SearchResult<any>[] | null {\r\n    const entry = this.cache.get(key);\r\n    \r\n    if (!entry) return null;\r\n    \r\n    if (this.isExpired(entry.timestamp)) {\r\n      this.cache.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return entry.data;\r\n  }\r\n\r\n  private isExpired(timestamp: number): boolean {\r\n    return Date.now() - timestamp > this.ttl;\r\n  }\r\n\r\n  private evictOldest(): void {\r\n    let oldestKey: string | null = null;\r\n    let oldestTime = Infinity;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.timestamp < oldestTime) {\r\n        oldestTime = entry.timestamp;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      this.cache.delete(oldestKey);\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n}","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","import { IndexOptions, SearchOptions, SearchDBSchema, IndexConfig, MetadataEntry } from \"@/types\";\r\nimport { IDBPDatabase, openDB } from \"idb\";\r\n\r\n\r\nexport const DEFAULT_INDEX_OPTIONS: Required<IndexOptions> = {\r\n  caseSensitive: false,\r\n  stemming: true,\r\n  stopWords: ['the', 'a', 'an', 'and', 'or', 'but'],\r\n  minWordLength: 2,\r\n  maxWordLength: 50,\r\n  fuzzyThreshold: 0.8\r\n};\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n  fuzzy: false,\r\n  maxResults: 10,\r\n  threshold: 0.5,\r\n  fields: [],\r\n  sortBy: 'score',\r\n  sortOrder: 'desc',\r\n  page: 1,\r\n  pageSize: 10\r\n  \r\n};\r\n\r\nexport class IndexedDB {\r\n  private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n  private readonly DB_NAME = 'nexus_search_db';\r\n  private readonly DB_VERSION = 1;\r\n  private initPromise: Promise<void> | null = null;\r\n\r\n  constructor() {\r\n    // Initialize immediately to catch early failures\r\n    this.initPromise = this.initialize();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.db) return;\r\n\r\n    try {\r\n      this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n        upgrade(db, oldVersion, newVersion, transaction) {\r\n          // Handle version upgrades\r\n          if (!db.objectStoreNames.contains('searchIndices')) {\r\n            const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n            indexStore.createIndex('timestamp', 'timestamp');\r\n          }\r\n\r\n          if (!db.objectStoreNames.contains('metadata')) {\r\n            const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n            metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n          }\r\n        },\r\n        blocked() {\r\n          console.warn('Database upgrade was blocked');\r\n        },\r\n        blocking() {\r\n          console.warn('Current database version is blocking a newer version');\r\n        },\r\n        terminated() {\r\n          console.error('Database connection was terminated');\r\n        }\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Storage initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n\r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        id: 'config', // Set id field\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n\r\n      await this.db!.put('metadata', metadata); // No need to spread, directly use metadata\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      const result = await this.db!.get('metadata', 'config');\r\n      return result || null; // Return `null` if `result` is `undefined`\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async deleteIndex(key: string): Promise<void> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      await this.db!.delete('searchIndices', key);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to delete index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport class SearchStorage {\r\n  private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n  private readonly DB_NAME = 'nexus_search_db';\r\n  private readonly DB_VERSION = 1;\r\n  private initPromise: Promise<void> | null = null;\r\n\r\n  constructor() {\r\n    // Initialize immediately to catch early failures\r\n    this.initPromise = this.initialize();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.db) return;\r\n\r\n    try {\r\n      this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n        upgrade(db, oldVersion, newVersion, transaction) {\r\n          // Handle version upgrades\r\n          if (!db.objectStoreNames.contains('searchIndices')) {\r\n            const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n            indexStore.createIndex('timestamp', 'timestamp');\r\n          }\r\n\r\n          if (!db.objectStoreNames.contains('metadata')) {\r\n            const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n            metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n          }\r\n        },\r\n        blocked() {\r\n          console.warn('Database upgrade was blocked');\r\n        },\r\n        blocking() {\r\n          console.warn('Current database version is blocking a newer version');\r\n        },\r\n        terminated() {\r\n          console.error('Database connection was terminated');\r\n        }\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Storage initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n    \r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n  \r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        id: 'config', // Set id field directly\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n  \r\n      await this.db!.put('metadata', metadata); // Use metadata directly\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n  \r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const result = await this.db!.get('metadata', 'config');\r\n      return result || null; // Return `null` if `result` is `undefined`\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}\r\n","import { DocumentValue, IndexableDocument, OptimizationResult } from \"@/types\";\r\n\r\ntype DocumentContent = {\r\n    [key: string]: DocumentValue | DocumentContent;\r\n};\r\n\r\nexport function createSearchableFields<T extends IndexableDocument>(\r\n    document: T,\r\n    fields: string[]\r\n): Record<string, string> {\r\n    const searchableFields: Record<string, string> = {};\r\n    fields.forEach(field => {\r\n        const value = getNestedValue(document.content, field);\r\n        if (value !== undefined) {\r\n            searchableFields[field] = normalizeFieldValue(value);\r\n        }\r\n    });\r\n    return searchableFields;\r\n}\r\n\r\nexport function normalizeFieldValue(value: DocumentValue): string {\r\n    if (typeof value === 'string') {\r\n        return value.toLowerCase().trim();\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.map(v => normalizeFieldValue(v)).join(' ');\r\n    }\r\n    if (typeof value === 'object' && value !== null) {\r\n        return Object.values(value).map(v => normalizeFieldValue(v)).join(' ');\r\n    }\r\n    return String(value);\r\n}\r\n\r\nexport function getNestedValue(obj: DocumentContent, path: string): DocumentValue | undefined {\r\n    const keys = path.split('.');\r\n    let current: DocumentValue | DocumentContent = obj;\r\n\r\n    for (const key of keys) {\r\n        if (current && typeof current === 'object' && !Array.isArray(current) && key in current) {\r\n            current = current[key];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    return current as DocumentValue;\r\n}\r\n\r\nexport function optimizeIndex<T extends IndexableDocument>(data: T[]): OptimizationResult<T> {\r\n    const uniqueData = Array.from(new Set(data.map(item =>\r\n        JSON.stringify(item)\r\n    ))).map(item => JSON.parse(item)) as T[];\r\n\r\n    const sorted = uniqueData.sort((a, b) =>\r\n        JSON.stringify(a).localeCompare(JSON.stringify(b))\r\n    );\r\n\r\n    return {\r\n        data: sorted,\r\n        stats: {\r\n            originalSize: data.length,\r\n            optimizedSize: sorted.length,\r\n            compressionRatio: sorted.length / data.length\r\n        }\r\n    };\r\n}","import { SearchOptions, IndexConfig, SearchableDocument } from \"@/types\";\r\nimport { getNestedValue } from \"./SearchUtils\";\r\n\r\nexport function validateSearchOptions(options: SearchOptions): void {\r\n    if (options.maxResults && options.maxResults < 1) {\r\n        throw new Error('maxResults must be greater than 0');\r\n    }\r\n    if (options.threshold && (options.threshold < 0 || options.threshold > 1)) {\r\n        throw new Error('threshold must be between 0 and 1');\r\n    }\r\n    if (options.fields && !Array.isArray(options.fields)) {\r\n        throw new Error('fields must be an array');\r\n    }\r\n}\r\n\r\nexport function validateIndexConfig(config: IndexConfig): void {\r\n    if (!config.name) {\r\n        throw new Error('Index name is required');\r\n    }\r\n    if (!config.version || typeof config.version !== 'number') {\r\n        throw new Error('Valid version number is required');\r\n    }\r\n    if (!Array.isArray(config.fields) || config.fields.length === 0) {\r\n        throw new Error('At least one field must be specified for indexing');\r\n    }\r\n}\r\n\r\nexport function validateDocument(document: SearchableDocument, fields: string[]): boolean {\r\n    return fields.every(field => {\r\n        const value = getNestedValue(document.content, field);\r\n        return value !== undefined;\r\n    });\r\n}","export class DataMapper {\r\n  private dataMap: Map<string, Set<string>>;\r\n\r\n  constructor() {\r\n    this.dataMap = new Map();\r\n  }\r\n\r\n  mapData(key: string, documentId: string): void {\r\n    if (!this.dataMap.has(key)) {\r\n      this.dataMap.set(key, new Set());\r\n    }\r\n    this.dataMap.get(key)!.add(documentId);\r\n  }\r\n\r\n  getDocuments(key: string): Set<string> {\r\n    return this.dataMap.get(key) || new Set();\r\n  }\r\n\r\n  getAllKeys(): string[] {\r\n    return Array.from(this.dataMap.keys());\r\n  }\r\n\r\n  exportState(): Record<string, string[]> {\r\n    const serializedMap: Record<string, string[]> = {};\r\n    \r\n    this.dataMap.forEach((value, key) => {\r\n      serializedMap[key] = Array.from(value);\r\n    });\r\n\r\n    return serializedMap;\r\n  }\r\n\r\n  importState(state: Record<string, string[]>): void {\r\n    this.dataMap.clear();\r\n    \r\n    Object.entries(state).forEach(([key, value]) => {\r\n      this.dataMap.set(key, new Set(value));\r\n    });\r\n  }\r\n\r\n  clear(): void {\r\n    this.dataMap.clear();\r\n  }\r\n}","export class TrieNode {\r\n  children: Map<string, TrieNode>;\r\n  isEndOfWord: boolean;\r\n  documentRefs: Set<string>;\r\n  weight: number;\r\n\r\n  constructor() {\r\n      this.children = new Map();\r\n      this.isEndOfWord = false;\r\n      this.documentRefs = new Set();\r\n      this.weight = 0.0;\r\n  }\r\n}","import { TrieNode } from './TrieNode';\r\nimport { DocumentLink } from '../../types/document';\r\nimport { IndexableDocument } from '../../types/utils';\r\nimport { SerializedState, SerializedTrieNode } from '@/types';\r\n\r\n\r\n\r\nexport class TrieSearch {\r\n    private root: TrieNode;\r\n    private documents: Map<string, IndexableDocument>;\r\n    private documentLinks: Map<string, DocumentLink[]>;\r\n\r\n    constructor() {\r\n        this.root = new TrieNode();\r\n        this.documents = new Map();\r\n        this.documentLinks = new Map();\r\n    }\r\n\r\n    // Main methods remain the same\r\n\r\n    public exportState(): SerializedState {\r\n        return {\r\n            trie: this.serializeNode(this.root),\r\n            documents: Array.from(this.documents.entries()),\r\n            documentLinks: Array.from(this.documentLinks.entries())\r\n        };\r\n    }\r\n\r\n    public importState(state: SerializedState): void {\r\n        this.root = this.deserializeNode(state.trie);\r\n\r\n        if (state.documents) {\r\n            this.documents = new Map(state.documents);\r\n        }\r\n\r\n        if (state.documentLinks) {\r\n            this.documentLinks = new Map(state.documentLinks);\r\n        }\r\n    }\r\n    \r\n    insert(word: string, documentId: string): void {\r\n        let current = this.root;\r\n        \r\n        for (const char of word.toLowerCase()) {\r\n            if (!current.children.has(char)) {\r\n                current.children.set(char, new TrieNode());\r\n            }\r\n            current = current.children.get(char)!;\r\n        }\r\n        \r\n        current.isEndOfWord = true;\r\n        current.documentRefs.add(documentId);\r\n    }\r\n\r\n    search(prefix: string, maxResults: number = 10): Set<string> {\r\n        const results = new Set<string>();\r\n        let current = this.root;\r\n\r\n        // Navigate to prefix endpoint\r\n        for (const char of prefix.toLowerCase()) {\r\n            if (!current.children.has(char)) {\r\n                return results;\r\n            }\r\n            current = current.children.get(char)!;\r\n        }\r\n\r\n        // Collect all document references below this point\r\n        this.collectDocumentRefs(current, results, maxResults);\r\n        return results;\r\n    }\r\n\r\n    fuzzySearch(word: string, maxDistance: number = 2): Set<string> {\r\n        const results = new Set<string>();\r\n        this.fuzzySearchHelper(word.toLowerCase(), this.root, '', maxDistance, results);\r\n        return results;\r\n    }\r\n\r\n    private collectDocumentRefs(node: TrieNode, results: Set<string>, maxResults: number): void {\r\n        if (node.isEndOfWord) {\r\n            for (const docId of node.documentRefs) {\r\n                if (results.size >= maxResults) return;\r\n                results.add(docId);\r\n            }\r\n        }\r\n\r\n        for (const child of node.children.values()) {\r\n            if (results.size >= maxResults) return;\r\n            this.collectDocumentRefs(child, results, maxResults);\r\n        }\r\n    }\r\n\r\n    private fuzzySearchHelper(\r\n        word: string,\r\n        node: TrieNode,\r\n        currentWord: string,\r\n        maxDistance: number,\r\n        results: Set<string>\r\n    ): void {\r\n        if (maxDistance < 0) return;\r\n\r\n        if (node.isEndOfWord) {\r\n            const distance = this.calculateLevenshteinDistance(word, currentWord);\r\n            if (distance <= maxDistance) {\r\n                node.documentRefs.forEach(id => results.add(id));\r\n            }\r\n        }\r\n\r\n        if (maxDistance > 0) {\r\n            for (const [char, childNode] of node.children) {\r\n                // Handle substitution\r\n                const newDistance = word[currentWord.length] !== char ? maxDistance - 1 : maxDistance;\r\n                this.fuzzySearchHelper(word, childNode, currentWord + char, newDistance, results);\r\n            }\r\n        }\r\n    }\r\n\r\n    private calculateLevenshteinDistance(s1: string, s2: string): number {\r\n        const dp: number[][] = Array(s1.length + 1).fill(0)\r\n            .map(() => Array(s2.length + 1).fill(0));\r\n\r\n        for (let i = 0; i <= s1.length; i++) dp[i][0] = i;\r\n        for (let j = 0; j <= s2.length; j++) dp[0][j] = j;\r\n\r\n        for (let i = 1; i <= s1.length; i++) {\r\n            for (let j = 1; j <= s2.length; j++) {\r\n                dp[i][j] = Math.min(\r\n                    dp[i - 1][j] + 1,\r\n                    dp[i][j - 1] + 1,\r\n                    dp[i - 1][j - 1] + (s1[i - 1] !== s2[j - 1] ? 1 : 0)\r\n                );\r\n            }\r\n        }\r\n\r\n        return dp[s1.length][s2.length];\r\n    }\r\n\r\n     \r\n\r\n    /**\r\n     * Serializes a TrieNode for persistence\r\n     */\r\n    private serializeNode(node: TrieNode): SerializedTrieNode {\r\n        const children: { [key: string]: SerializedTrieNode } = {};\r\n        \r\n        node.children.forEach((childNode, char) => {\r\n            children[char] = this.serializeNode(childNode);\r\n        });\r\n\r\n        return {\r\n            isEndOfWord: node.isEndOfWord,\r\n            documentRefs: Array.from(node.documentRefs),\r\n            children\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserializes a node from its serialized form\r\n     */\r\n    private deserializeNode(serialized: SerializedTrieNode): TrieNode {\r\n        const node = new TrieNode();\r\n        node.isEndOfWord = serialized.isEndOfWord;\r\n        node.documentRefs = new Set(serialized.documentRefs);\r\n\r\n        Object.entries(serialized.children).forEach(([char, childData]) => {\r\n            node.children.set(char, this.deserializeNode(childData));\r\n        });\r\n\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Clears all data from the trie\r\n     */\r\n    clear(): void {\r\n        this.root = new TrieNode();\r\n        this.documents.clear();\r\n        this.documentLinks.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the current size of the trie\r\n     */\r\n    getSize(): number {\r\n        return this.documents.size;\r\n    }\r\n}","import { TrieSearch } from \"@/algorithms/trie\";\r\nimport {  SearchableDocument, SearchResult, SerializedState } from \"@/types\";\r\nimport { DataMapper } from \"./DataMapper\";\r\n\r\nexport class IndexMapper {\r\n  private dataMapper: DataMapper;\r\n  private trieSearch: TrieSearch;\r\n\r\n  constructor() {\r\n    this.dataMapper = new DataMapper();\r\n    this.trieSearch = new TrieSearch();\r\n  }\r\n\r\n  indexDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n    fields.forEach(field => {\r\n        const value = document[field];\r\n        if (typeof value === 'string') {\r\n            const words = this.tokenizeText(value);\r\n            words.forEach(word => {\r\n                this.trieSearch.insert(word, id);\r\n                this.dataMapper.mapData(word.toLowerCase(), id);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n  search(query: string, options: { fuzzy?: boolean; maxResults?: number } = {}): SearchResult<string>[] {\r\n    const { fuzzy = false, maxResults = 10 } = options;\r\n    const searchTerms = this.tokenizeText(query);\r\n    \r\n    const documentScores = new Map<string, { score: number; matches: Set<string> }>();\r\n\r\n    searchTerms.forEach(term => {\r\n      const documentIds = fuzzy\r\n        ? this.trieSearch.fuzzySearch(term)\r\n        : this.trieSearch.search(term, maxResults);\r\n\r\n      documentIds.forEach(id => {\r\n        const current = documentScores.get(id) || { score: 0, matches: new Set<string>() };\r\n        current.score += this.calculateScore(id, term);\r\n        current.matches.add(term);\r\n        documentScores.set(id, current);\r\n      });\r\n    });\r\n\r\n    const results = Array.from(documentScores.entries())\r\n      .map(([id, { score, matches }]) => ({\r\n        item: id,\r\n        score: score / searchTerms.length,\r\n        matches: Array.from(matches)\r\n      }))\r\n      .sort((a, b) => b.score - a.score);\r\n\r\n    return results.slice(0, maxResults);\r\n  }\r\n\r\n  exportState(): unknown {\r\n    return {\r\n      trie: this.trieSearch.exportState(),\r\n      dataMap: this.dataMapper.exportState()\r\n    };\r\n  }\r\n\r\n  importState(state: { trie: SerializedState; dataMap: Record<string, string[]> }): void {\r\n    if (!state || !state.trie || !state.dataMap) {\r\n        throw new Error('Invalid index state');\r\n    }\r\n\r\n    this.trieSearch = new TrieSearch();\r\n    this.trieSearch.importState(state.trie );\r\n    this.dataMapper = new DataMapper();\r\n    this.dataMapper.importState(state.dataMap);\r\n}\r\n\r\n\r\n  private tokenizeText(text: string): string[] {\r\n    return text\r\n      .toLowerCase()\r\n      .replace(/[^\\w\\s]/g, ' ')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 0);\r\n  }\r\n\r\n  private calculateScore(documentId: string, term: string): number {\r\n    const baseScore = this.dataMapper.getDocuments(term.toLowerCase()).has(documentId) ? 1.0 : 0.5;\r\n    return baseScore\r\n  \r\n  }\r\n  clear(): void {\r\n    this.trieSearch = new TrieSearch();\r\n    this.dataMapper = new DataMapper();\r\n  }\r\n}\r\n","import { IndexMapper } from \"@/mappers\";\r\nimport { IndexConfig, SearchOptions, SearchResult, IndexedDocument, SearchableDocument, SerializedState } from \"@/types\";\r\nimport { SerializedIndex } from \"@/types/core\";\r\nimport { createSearchableFields } from \"@/utils\";\r\n\r\n\r\nexport class IndexManager {\r\n    private indexMapper: IndexMapper;\r\n    private config: IndexConfig;\r\n    private documents: Map<string, IndexedDocument>;\r\n\r\n    constructor(config: IndexConfig) {\r\n        this.config = config;\r\n        this.indexMapper = new IndexMapper();\r\n        this.documents = new Map();\r\n    }\r\n\r\n    async addDocuments<T extends IndexedDocument>(documents: T[]): Promise<void> {\r\n        documents.forEach((doc, index) => {\r\n            const id = this.generateDocumentId(index);\r\n            const searchableDoc: SearchableDocument = {\r\n                id,\r\n                content: createSearchableFields({\r\n                    content: doc.fields,\r\n                    id: \"\"\r\n                }, this.config.fields),\r\n                metadata: doc.metadata\r\n            };\r\n            this.documents.set(id, { ...doc, id }); \r\n            this.indexMapper.indexDocument(searchableDoc, id, this.config.fields);\r\n        });\r\n    }\r\n\r\n    async search<T extends IndexedDocument>(query: string, options: SearchOptions): Promise<SearchResult<T>[]> {\r\n        const searchResults = this.indexMapper.search(query, {\r\n            fuzzy: options.fuzzy,\r\n            maxResults: options.maxResults\r\n        });\r\n\r\n        return searchResults.map(result => ({\r\n            item: this.documents.get(result.item) as T,\r\n            score: result.score,\r\n            matches: result.matches\r\n        }));\r\n    }\r\n\r\n    exportIndex(): SerializedIndex {\r\n        return {\r\n            documents: Array.from(this.documents.entries()).map(([key, value]) => ({\r\n                key,\r\n                value: this.serializeDocument(value)\r\n            })),\r\n            indexState: this.indexMapper.exportState(),\r\n            config: this.config\r\n        };\r\n    }\r\n    \r\n    importIndex(data: unknown): void {\r\n        if (!this.isValidIndexData(data)) {\r\n            throw new Error('Invalid index data format');\r\n        }\r\n        try {\r\n            this.documents = new Map(\r\n                (data as SerializedIndex).documents.map(item => [item.key, item.value])\r\n            );\r\n            this.config = (data as SerializedIndex).config;\r\n            this.indexMapper = new IndexMapper();\r\n    \r\n            const indexState = (data as SerializedIndex).indexState;\r\n            if (indexState && typeof indexState === 'object' && 'trie' in indexState && 'dataMap' in indexState) {\r\n                this.indexMapper.importState({\r\n                    trie: indexState.trie as SerializedState,\r\n                    dataMap: indexState.dataMap as Record<string, string[]>\r\n                });\r\n            } else {\r\n                throw new Error('Invalid index state format');\r\n            }\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to import index: ${message}`);\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        this.documents.clear();\r\n        this.indexMapper = new IndexMapper();\r\n    }\r\n\r\n    private generateDocumentId(index: number): string {\r\n        return `${this.config.name}-${index}-${Date.now()}`;\r\n    }\r\n\r\n    private isValidIndexData(data: unknown): data is SerializedIndex {\r\n        if (!data || typeof data !== 'object') return false;\r\n        \r\n        const indexData = data as Partial<SerializedIndex>;\r\n        return Boolean(\r\n            indexData.documents &&\r\n            Array.isArray(indexData.documents) &&\r\n            indexData.indexState !== undefined &&\r\n            indexData.config &&\r\n            typeof indexData.config === 'object'\r\n        );\r\n    }\r\n\r\n    private serializeDocument(doc: IndexedDocument): IndexedDocument {\r\n        return JSON.parse(JSON.stringify(doc));\r\n    }\r\n}","import { QueryToken } from \"@/types\";\r\n\r\n\r\nexport class QueryProcessor {\r\n  private readonly STOP_WORDS = new Set([\r\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for',\r\n    'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on',\r\n    'that', 'the', 'to', 'was', 'were', 'will', 'with'\r\n  ]);\r\n\r\n  process(query: string): string {\r\n    const tokens = this.tokenize(query);\r\n    const processedTokens = this.processTokens(tokens);\r\n    return this.optimizeQuery(processedTokens);\r\n  }\r\n\r\n  private tokenize(query: string): QueryToken[] {\r\n    return query\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(term => term.length > 0)\r\n      .map(term => this.classifyToken(term));\r\n  }\r\n\r\n  private classifyToken(term: string): QueryToken {\r\n    if (term.startsWith('+') || term.startsWith('-')) {\r\n      return { type: 'operator', value: term };\r\n    }\r\n    if (term.includes(':')) {\r\n      return { type: 'modifier', value: term };\r\n    }\r\n    return { type: 'term', value: term };\r\n  }\r\n\r\n  private processTokens(tokens: QueryToken[]): QueryToken[] {\r\n    return tokens\r\n      .filter(token => \r\n        token.type !== 'term' || !this.STOP_WORDS.has(token.value)\r\n      )\r\n      .map(token => this.normalizeToken(token));\r\n  }\r\n\r\n  private normalizeToken(token: QueryToken): QueryToken {\r\n    if (token.type === 'term') {\r\n      // Basic stemming (could be enhanced with proper stemming algorithm)\r\n      let value = token.value;\r\n      if (value.endsWith('ing')) value = value.slice(0, -3);\r\n      if (value.endsWith('s')) value = value.slice(0, -1);\r\n      return { ...token, value };\r\n    }\r\n    return token;\r\n  }\r\n\r\n  private optimizeQuery(tokens: QueryToken[]): string {\r\n    return tokens\r\n      .map(token => token.value)\r\n      .join(' ');\r\n  }\r\n}","import { CacheManager } from \"@/storage\";\r\nimport { SearchStorage } from \"@/storage/IndexedDBService\";\r\nimport { IndexConfig, SearchOptions, SearchResult, IndexedDocument } from \"@/types\";\r\nimport { validateSearchOptions } from \"@/utils\";\r\nimport { IndexManager } from \"./IndexManager\";\r\nimport { QueryProcessor } from \"./QueryProcessor\";\r\n\r\nexport class SearchEngine {\r\n    private indexManager: IndexManager;\r\n    private queryProcessor: QueryProcessor;\r\n    private storage: SearchStorage;\r\n    private cache: CacheManager;\r\n    private config: IndexConfig;\r\n\r\n    constructor(config: IndexConfig) {\r\n        this.config = config;\r\n        this.indexManager = new IndexManager(config);\r\n        this.queryProcessor = new QueryProcessor();\r\n        this.storage = new SearchStorage();\r\n        this.cache = new CacheManager();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        try {\r\n            await this.storage.initialize();\r\n            await this.loadIndexes();\r\n        } catch (error) {\r\n            throw new Error(`Failed to initialize search engine: ${error}`);\r\n        }\r\n    }\r\n\r\n    async addDocuments<T extends IndexedDocument>(documents: T[]): Promise<void> {\r\n        try {\r\n            await this.indexManager.addDocuments(documents);\r\n            await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n        } catch (error) {\r\n            throw new Error(`Failed to add documents: ${error}`);\r\n        }\r\n    }\r\n\r\n    async search<T extends IndexedDocument>(query: string, options: SearchOptions = {}): Promise<SearchResult<T>[]> {\r\n        validateSearchOptions(options);\r\n\r\n        const cacheKey = this.generateCacheKey(query, options);\r\n        const cachedResults = this.cache.get(cacheKey);\r\n\r\n        if (cachedResults) {\r\n            return cachedResults as SearchResult<T>[];\r\n        }\r\n\r\n        const processedQuery = this.queryProcessor.process(query);\r\n        const results = await this.indexManager.search<T>(processedQuery, options);\r\n\r\n        this.cache.set(cacheKey, results);\r\n        return results;\r\n    }\r\n\r\n    private async loadIndexes(): Promise<void> {\r\n        const storedIndex = await this.storage.getIndex(this.config.name);\r\n        if (storedIndex) {\r\n            this.indexManager.importIndex(storedIndex);\r\n        }\r\n    }\r\n\r\n    private generateCacheKey(query: string, options: SearchOptions): string {\r\n        return `${query}-${JSON.stringify(options)}`;\r\n    }\r\n\r\n    async clearIndex(): Promise<void> {\r\n        await this.storage.clearIndices();\r\n        this.indexManager.clear();\r\n        this.cache.clear();\r\n    }\r\n}","export class SearchError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'SearchError';\r\n  }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class StorageError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'StorageError';\r\n  }\r\n}","// Import all types from a single barrel file\r\nimport type {\r\n    IndexConfig,\r\n    IndexOptions,\r\n    SearchContext,\r\n    SearchOptions,\r\n    SearchResult,\r\n    SearchStats,\r\n    SearchEventType,\r\n    SearchEvent,\r\n    DocumentLink,\r\n    DocumentRank,\r\n} from './types/index';\r\n\r\n// Core imports\r\nimport { SearchEngine } from './core/SearchEngine';\r\nimport { IndexManager } from './core/IndexManager';\r\nimport { QueryProcessor } from './core/QueryProcessor';\r\n\r\n// Algorithm imports\r\nimport { TrieNode } from './algorithms/trie/TrieNode';\r\nimport { TrieSearch } from './algorithms/trie/TrieSearch';\r\n\r\n// Mapper imports\r\nimport { DataMapper } from './mappers/DataMapper';\r\nimport { IndexMapper } from './mappers/IndexMapper';\r\n\r\n// Storage imports\r\nimport { CacheManager } from './storage/CacheManager';\r\nimport { IndexedDB } from './storage/IndexedDBService';\r\n\r\n// Utility imports\r\nimport {\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n} from './utils/index';\r\n\r\n// Re-export all types\r\nexport * from './types/index';\r\n\r\n// Constants\r\nexport const DEFAULT_INDEX_OPTIONS: Required<IndexOptions> = {\r\n    caseSensitive: false,\r\n    stemming: true,\r\n    stopWords: ['the', 'a', 'an', 'and', 'or', 'but'],\r\n    minWordLength: 2,\r\n    maxWordLength: 50,\r\n    fuzzyThreshold: 0.8\r\n};\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n    fuzzy: false,\r\n    maxResults: 10,\r\n    threshold: 0.5,\r\n    fields: [],\r\n    sortBy: 'score',\r\n    sortOrder: 'desc',\r\n    page: 1,\r\n    pageSize: 10\r\n};\r\n\r\n// Error classes\r\nexport class SearchError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'SearchError';\r\n    }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'IndexError';\r\n    }\r\n}\r\n\r\n// Type guards\r\nexport function isSearchOptions(obj: unknown): obj is SearchOptions {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const options = obj as Partial<SearchOptions>;\r\n    \r\n    return (\r\n        (typeof options.fuzzy === 'undefined' || typeof options.fuzzy === 'boolean') &&\r\n        (typeof options.maxResults === 'undefined' || typeof options.maxResults === 'number')\r\n    );\r\n}\r\n\r\nexport function isIndexConfig(obj: unknown): obj is IndexConfig {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const config = obj as Partial<IndexConfig>;\r\n    \r\n    return Boolean(\r\n        typeof config.name === 'string' &&\r\n        typeof config.version === 'number' &&\r\n        Array.isArray(config.fields)\r\n    );\r\n}\r\n\r\nexport function isSearchResult<T>(obj: unknown): obj is SearchResult<T> {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const result = obj as Partial<SearchResult<T>>;\r\n    \r\n    return Boolean(\r\n        'item' in result &&\r\n        typeof result.score === 'number' &&\r\n        Array.isArray(result.matches)\r\n    );\r\n}\r\n\r\n// Export individual components\r\nexport {\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    DataMapper,\r\n    IndexMapper,\r\n    CacheManager,\r\n    IndexedDB,\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n};\r\n\r\n// Create consolidated export object\r\nexport const NexusSearch = {\r\n    DEFAULT_INDEX_OPTIONS,\r\n    DEFAULT_SEARCH_OPTIONS,\r\n    SearchError,\r\n    IndexError,\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    isSearchOptions,\r\n    isIndexConfig,\r\n    isSearchResult\r\n} as const;\r\n\r\nexport default NexusSearch;","import { MetricsResult, PerformanceMetric } from \"@/types\";\r\n\r\nexport class PerformanceMonitor {\r\n    private metrics: Map<string, number[]>;\r\n\r\n    constructor() {\r\n        this.metrics = new Map();\r\n    }\r\n\r\n    async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {\r\n        const start = performance.now();\r\n        try {\r\n            return await fn();\r\n        } finally {\r\n            const duration = performance.now() - start;\r\n            this.recordMetric(name, duration);\r\n        }\r\n    }\r\n\r\n    private recordMetric(name: string, duration: number): void {\r\n        if (!this.metrics.has(name)) {\r\n            this.metrics.set(name, []);\r\n        }\r\n        this.metrics.get(name)!.push(duration);\r\n    }\r\n\r\n    getMetrics(): MetricsResult {\r\n        const results: MetricsResult = {};\r\n\r\n        this.metrics.forEach((durations, name) => {\r\n            results[name] = {\r\n                avg: this.average(durations),\r\n                min: Math.min(...durations),\r\n                max: Math.max(...durations),\r\n                count: durations.length\r\n            } as PerformanceMetric;\r\n        });\r\n\r\n        return results;\r\n    }\r\n\r\n    private average(numbers: number[]): number {\r\n        return numbers.reduce((a, b) => a + b, 0) / numbers.length;\r\n    }\r\n\r\n    clear(): void {\r\n        this.metrics.clear();\r\n    }\r\n}"],"names":["CacheManager","constructor","maxSize","ttlMinutes","this","cache","Map","ttl","set","key","data","size","evictOldest","timestamp","Date","now","get","entry","isExpired","delete","oldestKey","oldestTime","Infinity","entries","clear","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","transactionDoneMap","WeakMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","wrap","value","has","replaceTraps","callback","wrapFunction","func","IDBCursor","prototype","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","request","transformCachableValue","tx","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBDatabase","IDBObjectStore","IDBIndex","Proxy","IDBRequest","promise","success","result","promisifyRequest","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","transaction","then","db","catch","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","all","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","isIteratorProp","Symbol","asyncIterator","SearchStorage","DB_NAME","DB_VERSION","initPromise","initialize","contains","createObjectStore","keyPath","createIndex","console","warn","message","Error","ensureConnection","storeIndex","id","put","getIndex","updateMetadata","config","metadata","lastUpdated","getMetadata","clearIndices","close","createSearchableFields","document","fields","searchableFields","forEach","field","getNestedValue","content","normalizeFieldValue","toLowerCase","trim","Array","isArray","map","v","join","Object","values","String","obj","path","keys","split","current","validateSearchOptions","options","maxResults","threshold","DataMapper","dataMap","mapData","documentId","Set","add","getDocuments","getAllKeys","from","exportState","serializedMap","importState","state","TrieNode","children","isEndOfWord","documentRefs","weight","TrieSearch","root","documents","documentLinks","trie","serializeNode","deserializeNode","insert","word","char","search","prefix","results","collectDocumentRefs","fuzzySearch","maxDistance","fuzzySearchHelper","node","docId","child","currentWord","calculateLevenshteinDistance","childNode","newDistance","length","s1","s2","dp","fill","i","j","Math","min","serialized","childData","getSize","IndexMapper","dataMapper","trieSearch","indexDocument","tokenizeText","query","fuzzy","searchTerms","documentScores","term","score","matches","calculateScore","item","sort","a","b","slice","text","filter","IndexManager","indexMapper","addDocuments","doc","generateDocumentId","searchableDoc","exportIndex","serializeDocument","indexState","importIndex","isValidIndexData","indexData","Boolean","JSON","parse","stringify","QueryProcessor","STOP_WORDS","process","tokens","tokenize","processedTokens","processTokens","optimizeQuery","classifyToken","startsWith","type","token","normalizeToken","endsWith","SearchEngine","indexManager","queryProcessor","storage","loadIndexes","cacheKey","generateCacheKey","cachedResults","processedQuery","storedIndex","clearIndex","ValidationError","super","StorageError","DEFAULT_INDEX_OPTIONS","caseSensitive","stemming","stopWords","minWordLength","maxWordLength","fuzzyThreshold","DEFAULT_SEARCH_OPTIONS","sortBy","sortOrder","page","pageSize","SearchError","IndexError","isSearchOptions","isIndexConfig","isSearchResult","NexusSearch","deleteIndex","metrics","measure","fn","start","performance","duration","recordMetric","push","getMetrics","durations","avg","average","max","count","numbers","reduce","sorted","localeCompare","stats","originalSize","optimizedSize","compressionRatio","every"],"mappings":"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","x_google_ignoreList":[1]}