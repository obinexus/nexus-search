{"version":3,"file":"index.umd.js","sources":["../src/storage/CacheManager.ts","../src/storage/SearchStorage.ts","../src/storage/IndexedDocument.ts","../src/mappers/DataMapper.ts","../src/algorithms/trie/TrieNode.ts","../src/algorithms/trie/TrieSearch.ts","../src/mappers/IndexMapper.ts","../src/utils/SearchUtils.ts","../src/utils/ValidationUtils.ts","../src/storage/IndexManager.ts","../src/core/QueryProcessor.ts","../src/adapters/NexusDocumentAdapter.ts","../src/core/SearchEngine.ts","../src/types/errors.ts","../src/types/events.ts","../src/types/cache.ts","../src/index.ts","../src/types/defaults.ts","../src/storage/IndexedDBService.ts","../src/utils/PerformanceUtils.ts"],"sourcesContent":["import { CacheEntry, CacheStatus, CacheStrategy, SearchResult } from \"@/types\";\r\n\r\n\r\n\r\nexport class CacheManager {\r\n    public getSize(): number {\r\n        return this.cache.size;\r\n    }\r\n\r\n    public getStatus(): CacheStatus {\r\n        const timestamps = Array.from(this.cache.values()).map(entry => entry.timestamp);\r\n        const now = Date.now();\r\n        \r\n        // Calculate memory usage estimation\r\n        const memoryBytes = this.calculateMemoryUsage();\r\n        \r\n        return {\r\n            size: this.cache.size,\r\n            maxSize: this.maxSize,\r\n            strategy: this.strategy,\r\n            ttl: this.ttl,\r\n            utilization: this.cache.size / this.maxSize,\r\n            oldestEntryAge: timestamps.length ? now - Math.min(...timestamps) : null,\r\n            newestEntryAge: timestamps.length ? now - Math.max(...timestamps) : null,\r\n            memoryUsage: {\r\n                bytes: memoryBytes,\r\n                formatted: this.formatBytes(memoryBytes)\r\n            }\r\n        };\r\n    }\r\n\r\n    private calculateMemoryUsage(): number {\r\n        let totalSize = 0;\r\n\r\n        // Estimate size of cache entries\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            // Key size (2 bytes per character in UTF-16)\r\n            totalSize += key.length * 2;\r\n\r\n            // Entry overhead (timestamp, lastAccessed, accessCount)\r\n            totalSize += 8 * 3; // 8 bytes per number\r\n\r\n            // Estimate size of cached data\r\n            totalSize += this.estimateDataSize(entry.data);\r\n        }\r\n\r\n        // Add overhead for Map structure and class properties\r\n        totalSize += 8 * (\r\n            1 + // maxSize\r\n            1 + // ttl\r\n            1 + // strategy string reference\r\n            this.accessOrder.length + // access order array\r\n            3   // stats object numbers\r\n        );\r\n\r\n        return totalSize;\r\n    }\r\n\r\n    private estimateDataSize(data: SearchResult<unknown>[]): number {\r\n        let size = 0;\r\n        \r\n        for (const result of data) {\r\n            // Basic properties\r\n            size += 8; // score (number)\r\n            size += result.matches.join('').length * 2; // matches array strings\r\n            \r\n            // Estimate item size (conservative estimate)\r\n            size += JSON.stringify(result.item).length * 2;\r\n            \r\n            // Metadata if present\r\n            if (result.metadata) {\r\n                size += JSON.stringify(result.metadata).length * 2;\r\n            }\r\n        }\r\n\r\n        return size;\r\n    }\r\n\r\n    private formatBytes(bytes: number): string {\r\n        const units = ['B', 'KB', 'MB', 'GB'];\r\n        let size = bytes;\r\n        let unitIndex = 0;\r\n\r\n        while (size >= 1024 && unitIndex < units.length - 1) {\r\n            size /= 1024;\r\n            unitIndex++;\r\n        }\r\n\r\n        return `${size.toFixed(2)} ${units[unitIndex]}`;\r\n    }\r\n    private cache: Map<string, CacheEntry>;\r\n    private readonly maxSize: number;\r\n    private readonly ttl: number;\r\n    private strategy: CacheStrategy; // Changed from readonly to private\r\n    private accessOrder: string[];\r\n    private stats: {\r\n        hits: number;\r\n        misses: number;\r\n        evictions: number;\r\n    };\r\n\r\n    constructor(\r\n        maxSize: number = 1000, \r\n        ttlMinutes: number = 5, \r\n        initialStrategy: CacheStrategy = 'LRU'\r\n    ) {\r\n        this.cache = new Map();\r\n        this.maxSize = maxSize;\r\n        this.ttl = ttlMinutes * 60 * 1000;\r\n        this.strategy = initialStrategy;\r\n        this.accessOrder = [];\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            evictions: 0\r\n        };\r\n    }\r\n\r\n    set(key: string, data: SearchResult<unknown>[]): void {\r\n        if (this.cache.size >= this.maxSize) {\r\n            this.evict();\r\n        }\r\n\r\n        const entry: CacheEntry = {\r\n            data,\r\n            timestamp: Date.now(),\r\n            lastAccessed: Date.now(),\r\n            accessCount: 1\r\n        };\r\n\r\n        this.cache.set(key, entry);\r\n        this.updateAccessOrder(key);\r\n    }\r\n\r\n    get(key: string): SearchResult<unknown>[] | null {\r\n        const entry = this.cache.get(key);\r\n\r\n        if (!entry) {\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n\r\n        if (this.isExpired(entry.timestamp)) {\r\n            this.cache.delete(key);\r\n            this.removeFromAccessOrder(key);\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n\r\n        entry.lastAccessed = Date.now();\r\n        entry.accessCount++;\r\n        this.updateAccessOrder(key);\r\n        this.stats.hits++;\r\n\r\n        return entry.data;\r\n    }\r\n\r\n    clear(): void {\r\n        this.cache.clear();\r\n        this.accessOrder = [];\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            evictions: 0\r\n        };\r\n    }\r\n\r\n    getStats() {\r\n        return {\r\n            ...this.stats,\r\n            size: this.cache.size,\r\n            maxSize: this.maxSize,\r\n            hitRate: this.stats.hits / (this.stats.hits + this.stats.misses),\r\n            strategy: this.strategy\r\n        };\r\n    }\r\n\r\n    private isExpired(timestamp: number): boolean {\r\n        return Date.now() - timestamp > this.ttl;\r\n    }\r\n\r\n    private evict(): void {\r\n        const keyToEvict = this.strategy === 'LRU' \r\n            ? this.findLRUKey()\r\n            : this.findMRUKey();\r\n\r\n        if (keyToEvict) {\r\n            this.cache.delete(keyToEvict);\r\n            this.removeFromAccessOrder(keyToEvict);\r\n            this.stats.evictions++;\r\n        }\r\n    }\r\n\r\n    private findLRUKey(): string | null {\r\n        return this.accessOrder[0] || null;\r\n    }\r\n\r\n    private findMRUKey(): string | null {\r\n        return this.accessOrder[this.accessOrder.length - 1] || null;\r\n    }\r\n\r\n    private updateAccessOrder(key: string): void {\r\n        this.removeFromAccessOrder(key);\r\n\r\n        if (this.strategy === 'LRU') {\r\n            this.accessOrder.push(key); // Most recently used at end\r\n        } else {\r\n            this.accessOrder.unshift(key); // Most recently used at start\r\n        }\r\n    }\r\n\r\n    private removeFromAccessOrder(key: string): void {\r\n        const index = this.accessOrder.indexOf(key);\r\n        if (index !== -1) {\r\n            this.accessOrder.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    setStrategy(newStrategy: CacheStrategy): void {\r\n        if (newStrategy === this.strategy) return;\r\n        \r\n        this.strategy = newStrategy;\r\n        const entries = [...this.accessOrder];\r\n        this.accessOrder = [];\r\n        entries.forEach(key => this.updateAccessOrder(key));\r\n    }\r\n\r\n    prune(): number {\r\n        let prunedCount = 0;\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            if (this.isExpired(entry.timestamp)) {\r\n                this.cache.delete(key);\r\n                this.removeFromAccessOrder(key);\r\n                prunedCount++;\r\n            }\r\n        }\r\n        return prunedCount;\r\n    }\r\n\r\n    analyze(): {\r\n        hitRate: number;\r\n        averageAccessCount: number;\r\n        mostAccessedKeys: Array<{ key: string; count: number }>;\r\n    } {\r\n        const totalAccesses = this.stats.hits + this.stats.misses;\r\n        const hitRate = totalAccesses > 0 ? this.stats.hits / totalAccesses : 0;\r\n\r\n        let totalAccessCount = 0;\r\n        const accessCounts = new Map<string, number>();\r\n\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            totalAccessCount += entry.accessCount;\r\n            accessCounts.set(key, entry.accessCount);\r\n        }\r\n\r\n        const averageAccessCount = this.cache.size > 0 \r\n            ? totalAccessCount / this.cache.size \r\n            : 0;\r\n\r\n        const mostAccessedKeys = Array.from(accessCounts.entries())\r\n            .sort((a, b) => b[1] - a[1])\r\n            .slice(0, 5)\r\n            .map(([key, count]) => ({ key, count }));\r\n\r\n        return {\r\n            hitRate,\r\n            averageAccessCount,\r\n            mostAccessedKeys\r\n        };\r\n    }\r\n}","import { openDB, IDBPDatabase } from 'idb';\nimport type { SearchDBSchema, StorageOptions } from '@/types';\n\nexport class SearchStorage {\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\n    private memoryStorage: Map<string, unknown> = new Map();\n    private storageType: 'indexeddb' | 'memory';\n    \n    constructor(options: StorageOptions = {\n        type: 'memory'\n    }) {\n        this.storageType = this.determineStorageType(options);\n    }\n\n    private determineStorageType(options: StorageOptions): 'indexeddb' | 'memory' {\n        // Use memory storage if explicitly specified or if in Node.js environment\n        if (options.type === 'memory' || !this.isIndexedDBAvailable()) {\n            return 'memory';\n        }\n        return 'indexeddb';\n    }\n\n    private isIndexedDBAvailable(): boolean {\n        try {\n            return typeof indexedDB !== 'undefined' && indexedDB !== null;\n        } catch {\n            return false;\n        }\n    }\n\n    async initialize(): Promise<void> {\n        if (this.storageType === 'memory') {\n            // No initialization needed for memory storage\n            return;\n        }\n\n        try {\n            this.db = await openDB<SearchDBSchema>('nexus-search-db', 1, {\n                upgrade(db) {\n                    const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\n                    indexStore.createIndex('timestamp', 'timestamp');\n\n                    const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\n                    metaStore.createIndex('lastUpdated', 'lastUpdated');\n                }\n            });\n        } catch (error) {\n            // Fallback to memory storage if IndexedDB fails\n            this.storageType = 'memory';\n            console.warn('Failed to initialize IndexedDB, falling back to memory storage:', error);\n        }\n    }\n\n    async storeIndex(name: string, data: unknown): Promise<void> {\n        if (this.storageType === 'memory') {\n            this.memoryStorage.set(name, data);\n            return;\n        }\n\n        try {\n            await this.db?.put('searchIndices', {\n                id: name,\n                data,\n                timestamp: Date.now()\n            });\n        } catch (error) {\n            console.error('Storage error:', error);\n            // Fallback to memory storage\n            this.memoryStorage.set(name, data);\n        }\n    }\n\n    async getIndex(name: string): Promise<unknown> {\n        if (this.storageType === 'memory') {\n            return this.memoryStorage.get(name);\n        }\n\n        try {\n            const entry = await this.db?.get('searchIndices', name);\n            return entry?.data;\n        } catch (error) {\n            console.error('Retrieval error:', error);\n            // Fallback to memory storage\n            return this.memoryStorage.get(name);\n        }\n    }\n\n    async clearIndices(): Promise<void> {\n        if (this.storageType === 'memory') {\n            this.memoryStorage.clear();\n            return;\n        }\n\n        try {\n            await this.db?.clear('searchIndices');\n        } catch (error) {\n            console.error('Clear error:', error);\n            this.memoryStorage.clear();\n        }\n    }\n\n    async close(): Promise<void> {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n        }\n        this.memoryStorage.clear();\n    }\n}","import { \r\n    DocumentContent,\r\n    DocumentMetadata, \r\n    DocumentVersion,\r\n    DocumentRelation,\r\n    BaseFields,\r\n    IndexedDocument as IIndexedDocument,\r\n    IndexedDocumentData\r\n} from \"@/types/document\";\r\n\r\n\r\n/**\r\n * Enhanced IndexedDocument implementation with proper type handling \r\n * and versioning support\r\n */\r\nexport class IndexedDocument implements IIndexedDocument {\r\n    readonly id: string;\r\n    fields: BaseFields;\r\n    metadata?: DocumentMetadata;\r\n    versions: Array<DocumentVersion>;\r\n    relations: Array<DocumentRelation>;\r\n    content: DocumentContent;\r\n    links?: string[];\r\n    ranks?: number[];\r\n    \r\n    constructor(\r\n        id: string,\r\n        fields: BaseFields,\r\n        metadata?: DocumentMetadata,\r\n        versions: Array<DocumentVersion> = [],\r\n        relations: Array<DocumentRelation> = []\r\n    ) {\r\n        this.id = id;\r\n        this.fields = this.normalizeFields(fields);\r\n        this.metadata = this.normalizeMetadata(metadata);\r\n        this.versions = versions;\r\n        this.relations = relations;\r\n        this.content = this.normalizeContent(this.fields.content); // Add this line\r\n    }\r\n    /**\r\n     * Implement required document() method from interface\r\n     */\r\n    document(): IIndexedDocument {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Normalize document fields ensuring required fields exist\r\n     */\r\n    private normalizeFields(fields: BaseFields): BaseFields {\r\n        const normalizedFields: BaseFields = {\r\n            ...fields,\r\n            title: fields.title || '',\r\n            author: fields.author || '',\r\n            tags: Array.isArray(fields.tags) ? [...fields.tags] : [],\r\n            version: fields.version || '1.0'\r\n        };\r\n\r\n        return normalizedFields;\r\n    }\r\n\r\n    private normalizeContent(content: DocumentContent | string): DocumentContent {\r\n        if (typeof content === 'string') {\r\n            return { text: content };\r\n        }\r\n        return content || {};\r\n    }\r\n\r\n    /**\r\n     * Normalize document metadata with timestamps\r\n     */\r\n    private normalizeMetadata(metadata?: DocumentMetadata): DocumentMetadata {\r\n        const now = Date.now();\r\n        return {\r\n            indexed: now,\r\n            lastModified: now,\r\n            ...metadata\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a deep clone of the document\r\n     */\r\n    clone(): IndexedDocument {\r\n        return new IndexedDocument(\r\n            this.id,\r\n            JSON.parse(JSON.stringify(this.fields)),\r\n            this.metadata ? { ...this.metadata } : undefined,\r\n            this.versions.map(v => ({ ...v })),\r\n            this.relations.map(r => ({ ...r }))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Update document fields and metadata\r\n     */\r\n    update(updates: Partial<IndexedDocumentData>): IndexedDocument {\r\n        const updatedFields = { ...this.fields };\r\n        const updatedMetadata = { \r\n            ...this.metadata,\r\n            lastModified: Date.now()\r\n        };\r\n\r\n        if (updates.fields) {\r\n            Object.entries(updates.fields).forEach(([key, value]) => {\r\n                if (value !== undefined) {\r\n                    (updatedFields as any)[key] = value;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (updates.metadata) {\r\n            Object.assign(updatedMetadata, updates.metadata);\r\n        }\r\n\r\n        return new IndexedDocument(\r\n            this.id,\r\n            updatedFields,\r\n            updatedMetadata,\r\n            updates.versions || this.versions,\r\n            updates.relations || this.relations\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a specific field value\r\n     */\r\n    getField<T extends keyof BaseFields>(field: T): BaseFields[T] {\r\n        return this.fields[field];\r\n    }\r\n\r\n    /**\r\n     * Set a specific field value\r\n     */\r\n    setField<T extends keyof BaseFields>(\r\n        field: T,\r\n        value: BaseFields[T]\r\n    ): void {\r\n        this.fields[field] = value;\r\n        if (this.metadata) {\r\n            this.metadata.lastModified = Date.now();\r\n        }\r\n        if (field === 'content') {\r\n            this.content = value as DocumentContent;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new version of the document\r\n     */\r\n    addVersion(version: Omit<DocumentVersion, 'version'>): void {\r\n        const nextVersion = this.versions.length + 1;\r\n        this.versions.push({\r\n            ...version,\r\n            version: nextVersion\r\n        });\r\n        this.fields.version = String(nextVersion);\r\n        if (this.metadata) {\r\n            this.metadata.lastModified = Date.now();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a relationship to another document\r\n     */\r\n    addRelation(relation: DocumentRelation): void {\r\n        this.relations.push(relation);\r\n        if (this.metadata) {\r\n            this.metadata.lastModified = Date.now();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert to plain object representation\r\n     */\r\n    toObject(): IndexedDocumentData {\r\n        return {\r\n            id: this.id,\r\n            fields: { ...this.fields },\r\n            metadata: this.metadata ? { ...this.metadata } : undefined,\r\n            versions: this.versions.map(v => ({ ...v })),\r\n            relations: this.relations.map(r => ({ ...r }))\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convert to JSON string\r\n     */\r\n    toJSON(): string {\r\n        return JSON.stringify(this.toObject());\r\n    }\r\n\r\n    /**\r\n     * Create string representation\r\n     */\r\n    toString(): string {\r\n        return `IndexedDocument(${this.id})`;\r\n    }\r\n\r\n    /**\r\n     * Create new document instance\r\n     */\r\n    static create(data: IndexedDocumentData): IndexedDocument {\r\n        return new IndexedDocument(\r\n            data.id,\r\n            data.fields,\r\n            data.metadata,\r\n            data.versions,\r\n            data.relations\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Create from plain object\r\n     */\r\n    static fromObject(obj: Partial<IndexedDocumentData> & { \r\n        id: string; \r\n        fields: BaseFields;\r\n    }): IndexedDocument {\r\n        return IndexedDocument.create({\r\n            id: obj.id,\r\n            fields: obj.fields,\r\n            metadata: obj.metadata,\r\n            versions: obj.versions || [],\r\n            relations: obj.relations || []\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create from raw data\r\n     */\r\n    static fromRawData(\r\n        id: string,\r\n        content: string | DocumentContent,\r\n        metadata?: DocumentMetadata\r\n    ): IndexedDocument {\r\n        const fields: BaseFields = {\r\n            title: \"\",\r\n            content: typeof content === 'string' ? { text: content } : content,\r\n            author: \"\",\r\n            tags: [],\r\n            version: \"1.0\"\r\n        };\r\n\r\n        return new IndexedDocument(id, fields, metadata);\r\n    }\r\n}","export class DataMapper {\r\n  private dataMap: Map<string, Set<string>>;\r\n\r\n  constructor() {\r\n    this.dataMap = new Map();\r\n  }\r\n\r\n  mapData(key: string, documentId: string): void {\r\n    if (!this.dataMap.has(key)) {\r\n      this.dataMap.set(key, new Set());\r\n    }\r\n    this.dataMap.get(key)!.add(documentId);\r\n  }\r\n\r\n  getDocuments(key: string): Set<string> {\r\n    return this.dataMap.get(key) || new Set();\r\n  }\r\n\r\n  getDocumentById(documentId: string): Set<string> {\r\n    const documents = new Set<string>();\r\n    this.dataMap.forEach(value => {\r\n      if (value.has(documentId)) {\r\n        documents.add(documentId);\r\n      }\r\n    }\r\n    );\r\n    return documents;\r\n  }\r\n\r\n  getAllKeys(): string[] {\r\n    return Array.from(this.dataMap.keys());\r\n  }\r\n\r\n  removeDocument(documentId: string): void {\r\n    this.dataMap.forEach(value => {\r\n      value.delete(documentId);\r\n    });\r\n  }\r\n\r\n\r\n\r\n  removeKey(key: string): void {\r\n    this.dataMap.delete(key);\r\n  }\r\n  \r\n  exportState(): Record<string, string[]> {\r\n    const serializedMap: Record<string, string[]> = {};\r\n    \r\n    this.dataMap.forEach((value, key) => {\r\n      serializedMap[key] = Array.from(value);\r\n    });\r\n\r\n    return serializedMap;\r\n  }\r\n\r\n  importState(state: Record<string, string[]>): void {\r\n    this.dataMap.clear();\r\n    \r\n    Object.entries(state).forEach(([key, value]) => {\r\n      this.dataMap.set(key, new Set(value));\r\n    });\r\n  }\r\n\r\n  clear(): void {\r\n    this.dataMap.clear();\r\n  }\r\n}","export class TrieNode {\r\n    children: Map<string, TrieNode>;\r\n    isEndOfWord: boolean;\r\n    documentRefs: Set<string>;\r\n    weight: number;\r\n    frequency: number;\r\n    lastAccessed: number;\r\n    prefixCount: number;\r\n    depth: number;\r\n\r\n    constructor(depth: number = 0) {\r\n        this.children = new Map();\r\n        this.isEndOfWord = false;\r\n        this.documentRefs = new Set();\r\n        this.weight = 0.0;\r\n        this.frequency = 0;\r\n        this.lastAccessed = Date.now();\r\n        this.prefixCount = 0;\r\n        this.depth = depth;\r\n    }\r\n\r\n    addChild(char: string): TrieNode {\r\n        const child = new TrieNode(this.depth + 1);\r\n        this.children.set(char, child);\r\n        return child;\r\n    }\r\n\r\n    getChild(char: string): TrieNode | undefined {\r\n        return this.children.get(char);\r\n    }\r\n\r\n    hasChild(char: string): boolean {\r\n        return this.children.has(char);\r\n    }\r\n\r\n    incrementWeight(value: number = 1.0): void {\r\n        this.weight += value;\r\n        this.frequency++;\r\n        this.lastAccessed = Date.now();\r\n    }\r\n\r\n    decrementWeight(value: number = 1.0): void {\r\n        this.weight = Math.max(0, this.weight - value);\r\n        this.frequency = Math.max(0, this.frequency - 1);\r\n    }\r\n\r\n    clearChildren(): void {\r\n        this.children.clear();\r\n        this.documentRefs.clear();\r\n        this.weight = 0;\r\n        this.frequency = 0;\r\n    }\r\n\r\n    shouldPrune(): boolean {\r\n        return this.children.size === 0 && \r\n               this.documentRefs.size === 0 && \r\n               this.weight === 0 &&\r\n               this.frequency === 0;\r\n    }\r\n\r\n    getScore(): number {\r\n        const recency = Math.exp(-(Date.now() - this.lastAccessed) / (24 * 60 * 60 * 1000)); // Decay over 24 hours\r\n        return (this.weight * this.frequency * recency) / (this.depth + 1);\r\n    }\r\n}","\r\n\r\nimport { IndexedDocument, DocumentLink, SearchOptions, SearchResult, DocumentContent} from \"@/types\";\r\nimport { TrieNode } from \"./TrieNode\";\r\n\r\n\r\n\r\nexport class TrieSearch {\r\n    private root: TrieNode;\r\n    private documents: Map<string, IndexedDocument>;\r\n    private documentLinks: Map<string, DocumentLink[]>;\r\n    private totalDocuments: number;\r\n    private maxWordLength: number;\r\n\r\n    constructor(maxWordLength: number = 50) {\r\n        this.root = new TrieNode();\r\n        this.documents = new Map();\r\n        this.documentLinks = new Map();\r\n        this.totalDocuments = 0;\r\n        this.maxWordLength = maxWordLength;\r\n    }\r\n\r\n    public addDocument(document: IndexedDocument): void {\r\n        if (!document.id) return;\r\n\r\n        this.documents.set(document.id, document);\r\n        this.totalDocuments++;\r\n\r\n        // Index all text fields\r\n        Object.values(document.fields).forEach(field => {\r\n            if (typeof field === 'string') {\r\n                this.indexText(field, document.id);\r\n            } else if (Array.isArray(field)) {\r\n                field.forEach(item => {\r\n                    if (typeof item === 'string') {\r\n                        this.indexText(item, document.id);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    private indexText(text: string, documentId: string): void {\r\n        const words = this.tokenize(text);\r\n        const uniqueWords = new Set(words);\r\n\r\n        uniqueWords.forEach(word => {\r\n            if (word.length <= this.maxWordLength) {\r\n                this.insertWord(word, documentId);\r\n            }\r\n        });\r\n    }\r\n\r\n    private insertWord(word: string, documentId: string): void {\r\n        let current = this.root;\r\n        current.prefixCount++;\r\n\r\n        for (const char of word) {\r\n            if (!current.hasChild(char)) {\r\n                current = current.addChild(char);\r\n            } else {\r\n                current = current.getChild(char)!;\r\n            }\r\n            current.prefixCount++;\r\n        }\r\n\r\n        current.isEndOfWord = true;\r\n        current.documentRefs.add(documentId);\r\n        current.incrementWeight();\r\n    }\r\n\r\n    public searchWord(term: string): SearchResult[] {\r\n        return this.search(term);\r\n    }\r\n\r\n    public search(query: string, options: SearchOptions = {}): SearchResult[] {\r\n        const {\r\n            fuzzy = false,\r\n            maxDistance = 2,\r\n            prefixMatch = false,\r\n            maxResults = 10,\r\n            minScore = 0.1,\r\n            caseSensitive = false\r\n        } = options;\r\n\r\n        const words = this.tokenize(query, caseSensitive);\r\n        const results = new Map<string, SearchResult>();\r\n\r\n        words.forEach(word => {\r\n            let matches: SearchResult[] = [];\r\n\r\n            if (fuzzy) {\r\n                matches = this.fuzzySearch(word, maxDistance);\r\n            } else if (prefixMatch) {\r\n                matches = this.prefixSearch(word);\r\n            } else {\r\n                matches = this.exactSearch(word);\r\n            }\r\n\r\n            matches.forEach(match => {\r\n                const existing = results.get(match.docId);\r\n                if (!existing || existing.score < match.score) {\r\n                    results.set(match.docId, match);\r\n                }\r\n            });\r\n        });\r\n\r\n        return Array.from(results.values())\r\n            .filter(result => result.score >= minScore)\r\n            .sort((a, b) => b.score - a.score)\r\n            .slice(0, maxResults);\r\n    }\r\n\r\n    private exactSearch(word: string): SearchResult[] {\r\n        const results: SearchResult[] = [];\r\n        let current = this.root;\r\n\r\n        for (const char of word) {\r\n            if (!current.hasChild(char)) {\r\n                return results;\r\n            }\r\n            current = current.getChild(char)!;\r\n        }\r\n\r\n        if (current.isEndOfWord) {\r\n            current.documentRefs.forEach(docId => {\r\n                results.push({\r\n                    docId,\r\n                    score: this.calculateScore(current, word),\r\n                    term: word,\r\n                    id: \"\",\r\n                    document: this.documents.get(docId)!,\r\n                    item: undefined,\r\n                    matches: []\r\n                });\r\n            });\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    private prefixSearch(prefix: string): SearchResult[] {\r\n        const results: SearchResult[] = [];\r\n        let current = this.root;\r\n\r\n        // Navigate to prefix node\r\n        for (const char of prefix) {\r\n            if (!current.hasChild(char)) {\r\n                return results;\r\n            }\r\n            current = current.getChild(char)!;\r\n        }\r\n\r\n        // Collect all words with this prefix\r\n        this.collectWords(current, prefix, results);\r\n        return results;\r\n    }\r\npublic serializeState(): any {\r\n    return {\r\n        trie: this.serializeTrie(this.root),\r\n        documents: Array.from(this.documents.entries()),\r\n        documentLinks: Array.from(this.documentLinks.entries()),\r\n        totalDocuments: this.totalDocuments,\r\n        maxWordLength: this.maxWordLength\r\n    };\r\n}\r\n\r\npublic deserializeState(state: any): void {\r\n    this.root = this.deserializeTrie(state.trie);\r\n    this.documents = new Map(state.documents);\r\n    this.documentLinks = new Map(state.documentLinks);\r\n    this.totalDocuments = state.totalDocuments;\r\n    this.maxWordLength = state.maxWordLength;\r\n}\r\n\r\nprivate serializeTrie(node: TrieNode): any {\r\n    const serializedNode: any = {\r\n        prefixCount: node.prefixCount,\r\n        isEndOfWord: node.isEndOfWord,\r\n        documentRefs: Array.from(node.documentRefs),\r\n        children: {}\r\n    };\r\n\r\n    node.children.forEach((child, char) => {\r\n        serializedNode.children[char] = this.serializeTrie(child);\r\n    });\r\n\r\n    return serializedNode;\r\n}\r\n\r\npublic addData(documentId: string, content: DocumentContent, document: IndexedDocument): void {\r\n    if (!documentId || !content) return;\r\n    this.addDocument({\r\n        id: documentId,\r\n        fields: {\r\n            content,\r\n            title: document.fields.title || '',\r\n            author: document.fields.author || '',\r\n            tags: document.fields.tags || [],\r\n            version: document.fields.version || ''\r\n        },\r\n        metadata: document.metadata,\r\n        versions: document.versions || [],\r\n        links: document.links || [],\r\n        ranks: [],\r\n        document: function (): IndexedDocument {\r\n            throw new Error(\"Function not implemented.\");\r\n        },\r\n        relations: []\r\n    });\r\n}\r\n\r\nprivate deserializeTrie(data: any): TrieNode {\r\n    const node = new TrieNode();\r\n    node.prefixCount = data.prefixCount;\r\n    node.isEndOfWord = data.isEndOfWord;\r\n    node.documentRefs = new Set(data.documentRefs);\r\n\r\n    for (const char in data.children) {\r\n        node.children.set(char, this.deserializeTrie(data.children[char]));\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\n    private collectWords(node: TrieNode, currentWord: string, results: SearchResult[]): void {\r\n        if (node.isEndOfWord) {\r\n            node.documentRefs.forEach(docId => {\r\n                results.push({\r\n                    docId,\r\n                    score: this.calculateScore(node, currentWord),\r\n                    term: currentWord,\r\n                    id: \"\",\r\n                    document: this.documents.get(docId)!,\r\n                    item: undefined,\r\n                    matches: []\r\n                });\r\n            });\r\n        }\r\n\r\n        node.children.forEach((child, char) => {\r\n            this.collectWords(child, currentWord + char, results);\r\n        });\r\n    }\r\n\r\n    public fuzzySearch(word: string, maxDistance: number): SearchResult[] {\r\n        const results: SearchResult[] = [];\r\n        \r\n        const searchState = {\r\n            word,\r\n            maxDistance,\r\n            results\r\n        };\r\n\r\n        this.fuzzySearchRecursive(this.root, \"\", 0, 0, searchState);\r\n        return results;\r\n    }\r\n\r\n    private fuzzySearchRecursive(\r\n        node: TrieNode, \r\n        current: string,\r\n        currentDistance: number,\r\n        depth: number,\r\n        state: { word: string; maxDistance: number; results: SearchResult[] }\r\n    ): void {\r\n        if (currentDistance > state.maxDistance) return;\r\n\r\n        if (node.isEndOfWord) {\r\n            const distance = this.calculateLevenshteinDistance(state.word, current);\r\n            if (distance <= state.maxDistance) {\r\n                node.documentRefs.forEach(docId => {\r\n                    return state.results.push({\r\n                        docId,\r\n                        score: this.calculateFuzzyScore(node, current, distance),\r\n                        term: current,\r\n                        distance,\r\n                        id: \"\",\r\n                        document: this.documents.get(docId)!,\r\n                        item: undefined,\r\n                        matches: []\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n        node.children.forEach((child, char) => {\r\n            // Try substitution\r\n            const substitutionCost = char !== state.word[depth] ? 1 : 0;\r\n            this.fuzzySearchRecursive(\r\n                child, \r\n                current + char, \r\n                currentDistance + substitutionCost,\r\n                depth + 1,\r\n                state\r\n            );\r\n\r\n            // Try insertion\r\n            this.fuzzySearchRecursive(\r\n                child,\r\n                current + char,\r\n                currentDistance + 1,\r\n                depth,\r\n                state\r\n            );\r\n\r\n            // Try deletion\r\n            if (depth < state.word.length) {\r\n                this.fuzzySearchRecursive(\r\n                    node,\r\n                    current,\r\n                    currentDistance + 1,\r\n                    depth + 1,\r\n                    state\r\n                );\r\n            }\r\n        });\r\n    }\r\n\r\n    private calculateScore(node: TrieNode, term: string): number {\r\n        const tfIdf = (node.frequency / this.totalDocuments) * \r\n                     Math.log(this.totalDocuments / node.documentRefs.size);\r\n        const positionBoost = 1 / (node.depth + 1);\r\n        const lengthNorm = 1 / Math.sqrt(term.length);\r\n\r\n        return node.getScore() * tfIdf * positionBoost * lengthNorm;\r\n    }\r\n\r\n    private calculateFuzzyScore(node: TrieNode, term: string, distance: number): number {\r\n        const exactScore = this.calculateScore(node, term);\r\n        return exactScore * Math.exp(-distance);\r\n    }\r\n\r\n    private calculateLevenshteinDistance(s1: string, s2: string): number {\r\n        const dp: number[][] = Array(s1.length + 1).fill(0)\r\n            .map(() => Array(s2.length + 1).fill(0));\r\n\r\n        for (let i = 0; i <= s1.length; i++) dp[i][0] = i;\r\n        for (let j = 0; j <= s2.length; j++) dp[0][j] = j;\r\n\r\n        for (let i = 1; i <= s1.length; i++) {\r\n            for (let j = 1; j <= s2.length; j++) {\r\n                const substitutionCost = s1[i - 1] !== s2[j - 1] ? 1 : 0;\r\n                dp[i][j] = Math.min(\r\n                    dp[i - 1][j] + 1,              // deletion\r\n                    dp[i][j - 1] + 1,              // insertion\r\n                    dp[i - 1][j - 1] + substitutionCost  // substitution\r\n                );\r\n            }\r\n        }\r\n\r\n        return dp[s1.length][s2.length];\r\n    }\r\n\r\n    private tokenize(text: string, caseSensitive: boolean = false): string[] {\r\n        const normalized = caseSensitive ? text : text.toLowerCase();\r\n        return normalized\r\n            .split(/[\\s,.!?;:'\"()\\[\\]{}\\/\\\\]+/)\r\n            .filter(word => word.length > 0);\r\n    }\r\n\r\n    public removeDocument(documentId: string): void {\r\n        // Remove document references and update weights\r\n        this.removeDocumentRefs(this.root, documentId);\r\n        this.documents.delete(documentId);\r\n        this.documentLinks.delete(documentId);\r\n        this.totalDocuments = Math.max(0, this.totalDocuments - 1);\r\n        this.pruneEmptyNodes(this.root);\r\n    }\r\n\r\n    private removeDocumentRefs(node: TrieNode, documentId: string): void {\r\n        if (node.documentRefs.has(documentId)) {\r\n            node.documentRefs.delete(documentId);\r\n            node.decrementWeight();\r\n            node.prefixCount = Math.max(0, node.prefixCount - 1);\r\n        }\r\n\r\n        node.children.forEach(child => {\r\n            this.removeDocumentRefs(child, documentId);\r\n        });\r\n    }\r\n\r\n    private pruneEmptyNodes(node: TrieNode): boolean {\r\n        // Remove empty child nodes\r\n        node.children.forEach((child, char) => {\r\n            if (this.pruneEmptyNodes(child)) {\r\n                node.children.delete(char);\r\n            }\r\n        });\r\n\r\n        return node.shouldPrune();\r\n    }\r\n\r\n    public getSuggestions(prefix: string, maxResults: number = 5): string[] {\r\n        let current = this.root;\r\n        \r\n        // Navigate to prefix node\r\n        for (const char of prefix) {\r\n            if (!current.hasChild(char)) {\r\n                return [];\r\n            }\r\n            current = current.getChild(char)!;\r\n        }\r\n\r\n        // Collect suggestions\r\n        const suggestions: Array<{ word: string; score: number }> = [];\r\n        this.collectSuggestions(current, prefix, suggestions);\r\n\r\n        return suggestions\r\n            .sort((a, b) => b.score - a.score)\r\n            .slice(0, maxResults)\r\n            .map(suggestion => suggestion.word);\r\n    }\r\n\r\n    private collectSuggestions(\r\n        node: TrieNode, \r\n        currentWord: string, \r\n        suggestions: Array<{ word: string; score: number }>\r\n    ): void {\r\n        if (node.isEndOfWord) {\r\n            suggestions.push({\r\n                word: currentWord,\r\n                score: node.getScore()\r\n            });\r\n        }\r\n\r\n        node.children.forEach((child, char) => {\r\n            this.collectSuggestions(child, currentWord + char, suggestions);\r\n        });\r\n    }\r\n\r\n    public clear(): void {\r\n        this.root = new TrieNode();\r\n        this.documents.clear();\r\n        this.documentLinks.clear();\r\n        this.totalDocuments = 0;\r\n    }\r\n}","import { TrieSearch } from \"@/algorithms/trie\";\r\nimport { \r\n    IndexedDocument, \r\n    SearchableDocument, \r\n    SearchResult, \r\n    SerializedState,\r\n    DocumentValue,\r\n    DocumentMetadata,\r\n    DocumentContent\r\n} from \"@/types\";\r\nimport { DataMapper } from \"./DataMapper\";\r\n\r\ninterface DocumentScore {\r\n    score: number;\r\n    matches: Set<string>;\r\n}\r\n\r\n/**\r\n * IndexMapper class\r\n * Manages document indexing and search operations using trie data structure\r\n */\r\nexport class IndexMapper {\r\n    private dataMapper: DataMapper;\r\n    private trieSearch: TrieSearch;\r\n    private documents: Map<string, IndexedDocument>;\r\n    private documentScores: Map<string, DocumentScore>;\r\n\r\n    constructor(state?: { dataMap?: Record<string, string[]> }) {\r\n        this.dataMapper = new DataMapper();\r\n        if (state?.dataMap) {\r\n            this.dataMapper.importState(state.dataMap);\r\n        }\r\n        this.trieSearch = new TrieSearch();\r\n        this.documents = new Map();\r\n        this.documentScores = new Map();\r\n    }\r\n\r\n    /**\r\n     * Index a document for search operations\r\n     */\r\n    indexDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n        try {\r\n            // Store the document\r\n            if (document.content) {\r\n                this.documents.set(id, {\r\n                    id,\r\n                    fields: document.content as Record<string, string>,\r\n                    metadata: document.metadata\r\n                } as IndexedDocument);\r\n            }\r\n\r\n            // Index each field\r\n            fields.forEach(field => {\r\n                const value = document.content[field];\r\n                if (value !== undefined && value !== null) {\r\n                    const textValue = this.normalizeValue(value);\r\n                    const words = this.tokenizeText(textValue);\r\n                    \r\n                    words.forEach(word => {\r\n                        if (word) {\r\n                            this.trieSearch.addDocument({\r\n                                id,\r\n                                fields: {\r\n                                    [field]: word,\r\n                                    title: \"\",\r\n                                    content: {} as DocumentContent,\r\n                                    author: \"\",\r\n                                    tags: [],\r\n                                    version: \"\"\r\n                                },\r\n                                versions: [],\r\n                                relations: [],\r\n                                metadata: {} as DocumentMetadata,\r\n                                document: () => {\r\n                                    const doc = this.documents.get(id);\r\n                                    if (!doc) {\r\n                                        throw new Error(`Document with id ${id} not found`);\r\n                                    }\r\n                                    return doc;\r\n                                }\r\n                            });\r\n                            this.dataMapper.mapData(word.toLowerCase(), id);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.error(`Error indexing document ${id}:`, error);\r\n            throw new Error(`Failed to index document: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Search for documents matching the query\r\n     */\r\n    search(query: string, options: { fuzzy?: boolean; maxResults?: number } = {}): SearchResult<string>[] {\r\n        try {\r\n            const { fuzzy = false, maxResults = 10 } = options;\r\n            const searchTerms = this.tokenizeText(query);\r\n\r\n            this.documentScores.clear();\r\n\r\n            searchTerms.forEach(term => {\r\n                if (!term) return;\r\n\r\n                const searchResults = fuzzy\r\n                    ? this.trieSearch.fuzzySearch(term, 2)\r\n                    : this.trieSearch.searchWord(term);\r\n\r\n                searchResults.forEach(result => {\r\n                    const docId = result.docId;\r\n                    const current = this.documentScores.get(docId) || {\r\n                        score: 0,\r\n                        matches: new Set<string>()\r\n                    };\r\n                    current.score += this.calculateScore(docId, term);\r\n                    current.matches.add(term);\r\n                    this.documentScores.set(docId, current);\r\n                });\r\n            });\r\n\r\n            return Array.from(this.documentScores.entries())\r\n                .map(([docId, { score, matches }]): SearchResult<string> => ({\r\n                    id: docId,\r\n                    docId: docId,\r\n                    document: this.documents.get(docId) as IndexedDocument,\r\n                    item: docId,\r\n                    term: query,\r\n                    score: score / searchTerms.length,\r\n                    matches: Array.from(matches),\r\n                    metadata: this.documents.get(docId)?.metadata\r\n                }))\r\n                .sort((a, b) => b.score - a.score)\r\n                .slice(0, maxResults);\r\n        } catch (error) {\r\n            console.error('Search error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    // ... rest of the methods remain the same ...\r\n    \r\n    private normalizeValue(value: DocumentValue): string {\r\n        if (typeof value === 'string') {\r\n            return value;\r\n        }\r\n        if (Array.isArray(value)) {\r\n            return value.map(v => this.normalizeValue(v)).join(' ');\r\n        }\r\n        if (typeof value === 'object' && value !== null) {\r\n            return Object.values(value).map(v => this.normalizeValue(v)).join(' ');\r\n        }\r\n        return String(value);\r\n    }\r\n\r\n    private tokenizeText(text: string): string[] {\r\n        return text\r\n            .toLowerCase()\r\n            .replace(/[^\\w\\s]/g, ' ')\r\n            .split(/\\s+/)\r\n            .filter(word => word.length > 0);\r\n    }\r\n\r\n    private calculateScore(documentId: string, term: string): number {\r\n        const baseScore = this.dataMapper.getDocuments(term.toLowerCase()).has(documentId) ? 1.0 : 0.5;\r\n        const termFrequency = this.calculateTermFrequency(documentId, term);\r\n        return baseScore * (1 + termFrequency);\r\n    }\r\n\r\n    private calculateTermFrequency(documentId: string, term: string): number {\r\n        const doc = this.documents.get(documentId);\r\n        if (!doc) return 0;\r\n\r\n        const content = Object.values(doc.fields).join(' ').toLowerCase();\r\n        const regex = new RegExp(term, 'gi');\r\n        const matches = content.match(regex);\r\n        return matches ? matches.length : 0;\r\n    }\r\n\r\n    removeDocument(id: string): void {\r\n        this.trieSearch.removeDocument(id);\r\n        this.dataMapper.removeDocument(id);\r\n        this.documents.delete(id);\r\n        this.documentScores.delete(id);\r\n    }\r\n\r\n    addDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n        this.indexDocument(document, id, fields);\r\n    }\r\n\r\n    updateDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n        this.removeDocument(id);\r\n        this.indexDocument(document, id, fields);\r\n    }\r\n\r\n    getDocumentById(id: string): IndexedDocument | undefined {\r\n        return this.documents.get(id);\r\n    }\r\n\r\n    getAllDocuments(): Map<string, IndexedDocument> {\r\n        return new Map(this.documents);\r\n    }\r\n\r\n    exportState(): unknown {\r\n        return {\r\n            trie: this.trieSearch.serializeState(),\r\n            dataMap: this.dataMapper.exportState(),\r\n            documents: Array.from(this.documents.entries())\r\n        };\r\n    }\r\n\r\n    importState(state: { \r\n        trie: SerializedState; \r\n        dataMap: Record<string, string[]>;\r\n        documents?: [string, IndexedDocument][];\r\n    }): void {\r\n        if (!state || !state.trie || !state.dataMap) {\r\n            throw new Error('Invalid index state');\r\n        }\r\n\r\n        this.trieSearch = new TrieSearch();\r\n        this.trieSearch.deserializeState(state.trie);\r\n        \r\n        const newDataMapper = new DataMapper();\r\n        newDataMapper.importState(state.dataMap);\r\n        this.dataMapper = newDataMapper;\r\n\r\n        if (state.documents) {\r\n            this.documents = new Map(state.documents);\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        this.trieSearch = new TrieSearch();\r\n        const newDataMapper = new DataMapper();\r\n        this.dataMapper = newDataMapper;\r\n        this.documents.clear();\r\n        this.documentScores.clear();\r\n    }\r\n}","import { IndexedDocument } from \"@/storage\";\r\nimport { \r\n    IndexNode, \r\n    OptimizationResult, \r\n    SearchableDocument,\r\n    DocumentContent, \r\n    DocumentValue,\r\n    RegexSearchResult,\r\n    RegexSearchConfig} from \"@/types\";\r\n\r\n/**\r\n * Performs an optimized Breadth-First Search traversal with regex matching\r\n */\r\nexport function bfsRegexTraversal(\r\n    root: IndexNode,\r\n    pattern: string | RegExp,\r\n    maxResults: number = 10,\r\n    config: RegexSearchConfig = {}\r\n): RegexSearchResult[] {\r\n    const {\r\n        maxDepth = 50,\r\n        timeoutMs = 5000,\r\n        caseSensitive = false,\r\n        wholeWord = false\r\n    } = config;\r\n\r\n    const regex = createRegexPattern(pattern, { caseSensitive, wholeWord });\r\n    const results: RegexSearchResult[] = [];\r\n    const queue: Array<{ \r\n        node: IndexNode; \r\n        matched: string; \r\n        depth: number;\r\n        path: string[];\r\n    }> = [];\r\n    const visited = new Set<string>();\r\n    const startTime = Date.now();\r\n\r\n    queue.push({ \r\n        node: root, \r\n        matched: '', \r\n        depth: 0,\r\n        path: []\r\n    });\r\n\r\n    while (queue.length > 0 && results.length < maxResults) {\r\n        if (Date.now() - startTime > timeoutMs) {\r\n            console.warn('BFS regex search timeout');\r\n            break;\r\n        }\r\n\r\n        const current = queue.shift()!;\r\n        const { node, matched, depth, path } = current;\r\n\r\n        if (depth > maxDepth) continue;\r\n\r\n        if (regex.test(matched) && node.id && !visited.has(node.id)) {\r\n            results.push({\r\n                id: node.id,\r\n                score: calculateRegexMatchScore(node, matched, regex),\r\n                matches: [matched],\r\n                path: [...path],\r\n                positions: findMatchPositions(matched, regex)\r\n            });\r\n            visited.add(node.id);\r\n        }\r\n\r\n        for (const [char, childNode] of node.children.entries()) {\r\n            queue.push({\r\n                node: childNode,\r\n                matched: matched + char,\r\n                depth: depth + 1,\r\n                path: [...path, char]\r\n            });\r\n        }\r\n    }\r\n\r\n    return results.sort((a, b) => b.score - a.score);\r\n}\r\n\r\n/**\r\n * Performs an optimized Depth-First Search traversal with regex matching\r\n */\r\nexport function dfsRegexTraversal(\r\n    root: IndexNode,\r\n    pattern: string | RegExp,\r\n    maxResults: number = 10,\r\n    config: RegexSearchConfig = {}\r\n): RegexSearchResult[] {\r\n    const {\r\n        maxDepth = 50,\r\n        timeoutMs = 5000,\r\n        caseSensitive = false,\r\n        wholeWord = false\r\n    } = config;\r\n\r\n    const regex = createRegexPattern(pattern, { caseSensitive, wholeWord });\r\n    const results: RegexSearchResult[] = [];\r\n    const visited = new Set<string>();\r\n    const startTime = Date.now();\r\n\r\n    function dfs(\r\n        node: IndexNode, \r\n        matched: string, \r\n        depth: number,\r\n        path: string[]\r\n    ): void {\r\n        if (results.length >= maxResults || \r\n            depth > maxDepth || \r\n            Date.now() - startTime > timeoutMs) {\r\n            return;\r\n        }\r\n\r\n        if (regex.test(matched) && node.id && !visited.has(node.id)) {\r\n            results.push({\r\n                id: node.id,\r\n                score: calculateRegexMatchScore(node, matched, regex),\r\n                matches: [matched],\r\n                path: [...path],\r\n                positions: findMatchPositions(matched, regex)\r\n            });\r\n            visited.add(node.id);\r\n        }\r\n\r\n        for (const [char, childNode] of node.children.entries()) {\r\n            dfs(\r\n                childNode, \r\n                matched + char, \r\n                depth + 1,\r\n                [...path, char]\r\n            );\r\n        }\r\n    }\r\n\r\n    dfs(root, '', 0, []);\r\n    return results.sort((a, b) => b.score - a.score);\r\n}\r\n\r\n/**\r\n * Helper function to create a properly configured regex pattern\r\n */\r\nfunction createRegexPattern(\r\n    pattern: string | RegExp,\r\n    options: { caseSensitive?: boolean; wholeWord?: boolean }\r\n): RegExp {\r\n    const { caseSensitive = false, wholeWord = false } = options;\r\n    \r\n    if (pattern instanceof RegExp) {\r\n        const flags = `${caseSensitive ? '' : 'i'}${pattern.global ? 'g' : ''}`;\r\n        return new RegExp(pattern.source, flags);\r\n    }\r\n\r\n    let source = pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n    if (wholeWord) {\r\n        source = `\\\\b${source}\\\\b`;\r\n    }\r\n\r\n    return new RegExp(source, caseSensitive ? 'g' : 'ig');\r\n}\r\n\r\n/**\r\n * Calculate a score for regex matches based on various factors\r\n */\r\nfunction calculateRegexMatchScore(\r\n    node: IndexNode,\r\n    matched: string,\r\n    regex: RegExp\r\n): number {\r\n    const baseScore = node.score || 1;\r\n    const matches = matched.match(regex) || [];\r\n    const matchCount = matches.length;\r\n    const matchQuality = matches.reduce((sum, match) => sum + match.length, 0) / matched.length;\r\n    const depthPenalty = 1 / (node.depth || 1);\r\n\r\n    return baseScore * matchCount * matchQuality * depthPenalty;\r\n}\r\n\r\n/**\r\n * Find all match positions in the text for highlighting\r\n */\r\nfunction findMatchPositions(text: string, regex: RegExp): Array<[number, number]> {\r\n    const positions: Array<[number, number]> = [];\r\n    let match: RegExpExecArray | null;\r\n    \r\n    const globalRegex = new RegExp(regex.source, regex.flags + (regex.global ? '' : 'g'));\r\n    \r\n    while ((match = globalRegex.exec(text)) !== null) {\r\n        positions.push([match.index, match.index + match[0].length]);\r\n    }\r\n    \r\n    return positions;\r\n}\r\n\r\n/**\r\n * Creates searchable fields from a document based on specified field paths\r\n */\r\nexport function createSearchableFields(\r\n    document: SearchableDocument,\r\n    fields: string[]\r\n): Record<string, string> {\r\n    if (!document?.content || !Array.isArray(fields)) {\r\n        return {};\r\n    }\r\n\r\n    return fields.reduce((acc, field) => {\r\n        try {\r\n            const value = getNestedValue(document.content, field);\r\n            if (value !== undefined) {\r\n                acc[field] = normalizeFieldValue(value);\r\n            }\r\n        } catch (error) {\r\n            console.warn(`Error processing field ${field}:`, error);\r\n        }\r\n        return acc;\r\n    }, {} as Record<string, string>);\r\n}\r\n\r\n/**\r\n * Normalizes field values into searchable strings\r\n */\r\nexport function normalizeFieldValue(value: DocumentValue): string {\r\n    if (value === null || value === undefined) {\r\n        return '';\r\n    }\r\n\r\n    try {\r\n        if (typeof value === 'string') {\r\n            return value.toLowerCase().trim();\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n            return value\r\n                .map(normalizeFieldValue)\r\n                .filter(Boolean)\r\n                .join(' ');\r\n        }\r\n\r\n        if (typeof value === 'object') {\r\n            return Object.values(value)\r\n                .map(normalizeFieldValue)\r\n                .filter(Boolean)\r\n                .join(' ');\r\n        }\r\n\r\n        return String(value).toLowerCase().trim();\r\n    } catch (error) {\r\n        console.warn('Error normalizing field value:', error);\r\n        return '';\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieves a nested value from an object using dot notation path\r\n */\r\nexport function getNestedValue(\r\n    obj: DocumentContent,\r\n    path: string\r\n): DocumentValue | undefined {\r\n    if (!obj || !path) {\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        return path.split('.').reduce((current: any, key) => {\r\n            if (current === null || typeof current !== 'object') {\r\n                return undefined;\r\n            }\r\n            \r\n            if (Array.isArray(current)) {\r\n                const index = parseInt(key, 10);\r\n                return isNaN(index) ? undefined : current[index];\r\n            }\r\n            \r\n            return current[key];\r\n        }, obj);\r\n    } catch (error) {\r\n        console.warn(`Error getting nested value for path ${path}:`, error);\r\n        return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Optimizes an array of indexable documents\r\n */\r\nexport function optimizeIndex<T extends IndexedDocument>(\r\n    data: T[]\r\n): OptimizationResult<T> {\r\n    if (!Array.isArray(data)) {\r\n        return {\r\n            data: [],\r\n            stats: { originalSize: 0, optimizedSize: 0, compressionRatio: 1 }\r\n        };\r\n    }\r\n\r\n    try {\r\n        const uniqueMap = new Map<string, T>();\r\n        data.forEach(item => {\r\n            const key = JSON.stringify(sortObjectKeys(item));\r\n            uniqueMap.set(key, item);\r\n        });\r\n\r\n        const sorted = Array.from(uniqueMap.values())\r\n            .sort((a, b) => generateSortKey(a).localeCompare(generateSortKey(b)));\r\n\r\n        return {\r\n            data: sorted,\r\n            stats: {\r\n                originalSize: data.length,\r\n                optimizedSize: sorted.length,\r\n                compressionRatio: data.length ? sorted.length / data.length : 1\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.warn('Error optimizing index:', error);\r\n        return {\r\n            data,\r\n            stats: {\r\n                originalSize: data.length,\r\n                optimizedSize: data.length,\r\n                compressionRatio: 1\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to sort object keys recursively\r\n */\r\nexport function sortObjectKeys<T extends object>(obj: T): T {\r\n    if (!obj || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    if (Array.isArray(obj)) {\r\n        return obj.map(sortObjectKeys) as unknown as T;\r\n    }\r\n\r\n    return Object.keys(obj)\r\n        .sort()\r\n        .reduce((sorted, key) => {\r\n            (sorted as any)[key] = sortObjectKeys((obj as any)[key]);\r\n            return sorted;\r\n        }, {} as T);\r\n}\r\n\r\n/**\r\n * Helper function to generate consistent sort keys for documents\r\n */\r\nexport function generateSortKey(doc: IndexedDocument): string {\r\n    if (!doc?.id || !doc.content) {\r\n        return '';\r\n    }\r\n\r\n    try {\r\n        return `${doc.id}:${Object.keys(doc.content).sort().join(',')}`;\r\n    } catch {\r\n        return doc.id;\r\n    }\r\n}","import { SearchOptions, IndexConfig, SearchableDocument } from \"@/types\";\r\nimport { getNestedValue } from \"./SearchUtils\";\r\n\r\nexport function validateSearchOptions(options: SearchOptions): void {\r\n    if (options.maxResults && options.maxResults < 1) {\r\n        throw new Error('maxResults must be greater than 0');\r\n    }\r\n    if (options.threshold && (options.threshold < 0 || options.threshold > 1)) {\r\n        throw new Error('threshold must be between 0 and 1');\r\n    }\r\n    if (options.fields && !Array.isArray(options.fields)) {\r\n        throw new Error('fields must be an array');\r\n    }\r\n}\r\n\r\nexport function validateIndexConfig(config: IndexConfig): void {\r\n    if (!config.name) {\r\n        throw new Error('Index name is required');\r\n    }\r\n    if (!config.version || typeof config.version !== 'number') {\r\n        throw new Error('Valid version number is required');\r\n    }\r\n    if (!Array.isArray(config.fields) || config.fields.length === 0) {\r\n        throw new Error('At least one field must be specified for indexing');\r\n    }\r\n}\r\n\r\nexport function validateDocument(document: SearchableDocument, fields: string[]): boolean {\r\n    return fields.every(field => {\r\n        const value = getNestedValue(document.content, field);\r\n        return value !== undefined;\r\n    });\r\n}","import { IndexMapper } from \"@/mappers\";\r\nimport { \r\n    IndexConfig, \r\n    SearchOptions, \r\n    SearchResult, \r\n    IndexedDocument, \r\n    SearchableDocument, \r\n    SerializedState,\r\n} from \"@/types\";\r\nimport { SerializedIndex } from \"@/types/core\";\r\nimport { DocumentValue } from \"@/types/document\";\r\nimport { createSearchableFields } from \"@/utils\";\r\n\r\nexport class IndexManager {\r\n   getSize() {\r\n        return this.documents.size;\r\n    }\r\n    \r\n    getAllDocuments() {\r\n        return this.documents;\r\n        \r\n    }\r\n    private indexMapper: IndexMapper;\r\n    private config: IndexConfig;\r\n    private documents: Map<string, IndexedDocument>;\r\n\r\n    constructor(config: IndexConfig) {\r\n        this.config = config;\r\n        this.indexMapper = new IndexMapper();\r\n        this.documents = new Map();\r\n    }\r\n\r\n    addDocument<T extends IndexedDocument>(document: T): void {\r\n        const id = document.id || this.generateDocumentId(this.documents.size);\r\n        this.documents.set(id, document);\r\n\r\n        const contentRecord: Record<string, DocumentValue> = {};\r\n        for (const field of this.config.fields) {\r\n            if (field in document.fields) {\r\n                contentRecord[field] = document.fields[field] as DocumentValue;\r\n            }\r\n        }\r\n\r\n        const searchableDoc: SearchableDocument = {\r\n            id,\r\n            content: createSearchableFields({\r\n                content: contentRecord,\r\n                id\r\n            }, this.config.fields),\r\n            metadata: document.metadata\r\n        };\r\n\r\n        this.indexMapper.indexDocument(searchableDoc, id, this.config.fields);\r\n    }\r\n\r\n    getDocument(id: string): IndexedDocument | undefined {\r\n        return this.documents.get(id);\r\n    }\r\n\r\n    \r\n\r\n    exportIndex(): SerializedIndex {\r\n        return {\r\n            documents: Array.from(this.documents.entries()).map(([key, value]) => ({\r\n                key,\r\n                value: this.serializeDocument(value)\r\n            })),\r\n            indexState: this.indexMapper.exportState(),\r\n            config: this.config\r\n        };\r\n    }\r\n\r\n    importIndex(data: unknown): void {\r\n        if (!this.isValidIndexData(data)) {\r\n            throw new Error('Invalid index data format');\r\n        }\r\n\r\n        try {\r\n            const typedData = data as SerializedIndex;\r\n            this.documents = new Map(\r\n                typedData.documents.map(item => [item.key, item.value])\r\n            );\r\n            this.config = typedData.config;\r\n            this.indexMapper = new IndexMapper();\r\n            \r\n            if (this.isValidIndexState(typedData.indexState)) {\r\n                this.indexMapper.importState({\r\n                    trie: typedData.indexState.trie,\r\n                    dataMap: typedData.indexState.dataMap\r\n                });\r\n            } else {\r\n                throw new Error('Invalid index state format');\r\n            }\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to import index: ${message}`);\r\n        }\r\n    }\r\n\r\n   \r\n\r\n    clear(): void {\r\n        this.documents.clear();\r\n        this.indexMapper = new IndexMapper();\r\n    }\r\n\r\n    private generateDocumentId(index: number): string {\r\n        return `${this.config.name}-${index}-${Date.now()}`;\r\n    }\r\n\r\n    private isValidIndexData(data: unknown): data is SerializedIndex {\r\n        if (!data || typeof data !== 'object') return false;\r\n        \r\n        const indexData = data as Partial<SerializedIndex>;\r\n        return Boolean(\r\n            indexData.documents &&\r\n            Array.isArray(indexData.documents) &&\r\n            indexData.indexState !== undefined &&\r\n            indexData.config &&\r\n            typeof indexData.config === 'object'\r\n        );\r\n    }\r\n\r\n    private isValidIndexState(state: unknown): state is { trie: SerializedState; dataMap: Record<string, string[]> } {\r\n        return (\r\n            state !== null &&\r\n            typeof state === 'object' &&\r\n            'trie' in state &&\r\n            'dataMap' in state\r\n        );\r\n    }\r\n\r\n    private serializeDocument(doc: IndexedDocument): IndexedDocument {\r\n        return JSON.parse(JSON.stringify(doc));\r\n    }\r\n\r\n    async addDocuments<T extends IndexedDocument>(documents: T[]): Promise<void> {\r\n        for (const doc of documents) {\r\n            // Use document's existing ID if available, otherwise generate new one\r\n            const id = doc.id || this.generateDocumentId(this.documents.size);\r\n\r\n            try {\r\n                // Convert document fields to Record<string, DocumentValue>\r\n                const contentRecord: Record<string, DocumentValue> = {};\r\n                for (const field of this.config.fields) {\r\n                    if (field in doc.fields) {\r\n                        contentRecord[field] = doc.fields[field] as DocumentValue;\r\n                    }\r\n                }\r\n\r\n                // Create searchable document\r\n                const searchableDoc: SearchableDocument = {\r\n                    id,\r\n                    content: createSearchableFields({\r\n                        content: contentRecord,\r\n                        id\r\n                    }, this.config.fields),\r\n                    metadata: doc.metadata\r\n                };\r\n\r\n                // Store original document with ID\r\n                this.documents.set(id, { ...doc, id });\r\n\r\n                // Index the document\r\n                await this.indexMapper.indexDocument(searchableDoc, id, this.config.fields);\r\n            } catch (error) {\r\n                console.warn(`Failed to index document ${id}:`, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    async updateDocument<T extends IndexedDocument>(document: T): Promise<void> {\r\n        const id = document.id;\r\n        if (!this.documents.has(id)) {\r\n            throw new Error(`Document ${id} not found`);\r\n        }\r\n\r\n        try {\r\n            // Update the document in storage\r\n            this.documents.set(id, document);\r\n\r\n            // Convert fields for indexing\r\n            const contentRecord: Record<string, DocumentValue> = {};\r\n            for (const field of this.config.fields) {\r\n                if (field in document.fields) {\r\n                    contentRecord[field] = document.fields[field] as DocumentValue;\r\n                }\r\n            }\r\n\r\n            // Create searchable document\r\n            const searchableDoc: SearchableDocument = {\r\n                id,\r\n                content: createSearchableFields({\r\n                    content: contentRecord,\r\n                    id\r\n                }, this.config.fields),\r\n                metadata: document.metadata\r\n            };\r\n\r\n            // Update the index\r\n            await this.indexMapper.updateDocument(searchableDoc, id, this.config.fields);\r\n        } catch (error) {\r\n            console.error(`Failed to update document ${id}:`, error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async removeDocument(documentId: string): Promise<void> {\r\n        try {\r\n            if (this.documents.has(documentId)) {\r\n                await this.indexMapper.removeDocument(documentId);\r\n                this.documents.delete(documentId);\r\n            }\r\n        } catch (error) {\r\n            console.error(`Failed to remove document ${documentId}:`, error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async search<T extends IndexedDocument>(\r\n        query: string, \r\n        options: SearchOptions = {}\r\n    ): Promise<SearchResult<T>[]> {\r\n        // Handle null or undefined query\r\n        if (!query?.trim()) return [];\r\n\r\n        try {\r\n            const searchResults = await this.indexMapper.search(query, {\r\n                fuzzy: options.fuzzy ?? false,\r\n                maxResults: options.maxResults ?? 10\r\n            });\r\n\r\n            return searchResults\r\n                .filter(result => this.documents.has(result.item))\r\n                .map(result => {\r\n                    const item = this.documents.get(result.item) as T;\r\n                    return {\r\n                        id: item.id,\r\n                        docId: item.id,\r\n                        term: query,\r\n                        document: item,\r\n                        metadata: item.metadata,\r\n                        item,\r\n                        score: result.score,\r\n                        matches: result.matches\r\n                    };\r\n                })\r\n                .filter(result => result.score >= (options.threshold ?? 0.5));\r\n\r\n        } catch (error) {\r\n            console.error('Search error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    // Helper method for tests to check if a document exists\r\n    hasDocument(id: string): boolean {\r\n        return this.documents.has(id);\r\n    }\r\n}","import { QueryToken } from \"@/types\";\r\n\r\nexport class QueryProcessor {\r\n  private readonly STOP_WORDS = new Set([\r\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for',\r\n    'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on',\r\n    'that', 'the', 'to', 'was', 'were', 'will', 'with'\r\n  ]);\r\n\r\n  process(query: string | null | undefined): string {\r\n    if (query == null) return '';\r\n    if (typeof query !== 'string') return String(query);\r\n\r\n    // Extract quoted phrases\r\n    let tempQuery = query;\r\n    // const quotes = new Map<string, string>();\r\n    let quoteMatch;\r\n    const quoteRegex = /\"[^\"]+\"|\"[^\"]*$/g;\r\n\r\n    while ((quoteMatch = quoteRegex.exec(tempQuery)) !== null) {\r\n      const quote = quoteMatch[0];\r\n      tempQuery = tempQuery.replace(quote, ` ${quote} `);\r\n    }\r\n\r\n    const tokens = this.tokenize(tempQuery);\r\n    const processedTokens = this.processTokens(tokens);\r\n    return this.optimizeQuery(processedTokens);\r\n  }\r\n\r\n  private tokenize(query: string): QueryToken[] {\r\n    return query\r\n      .split(/\\s+/)\r\n      .filter(term => term.length > 0)\r\n      .map(term => {\r\n        // Preserve quotes as-is\r\n        if (term.startsWith('\"') && term.endsWith('\"')) {\r\n          return { type: 'term', value: term };\r\n        }\r\n        return this.classifyToken(term.toLowerCase());\r\n      });\r\n  }\r\n\r\n  private classifyToken(term: string): QueryToken {\r\n    if (term.startsWith('+') || term.startsWith('-')) {\r\n      return { type: 'operator', value: term };\r\n    }\r\n    if (term.includes(':')) {\r\n      return { type: 'modifier', value: term };\r\n    }\r\n    return { type: 'term', value: term };\r\n  }\r\n\r\n  private processTokens(tokens: QueryToken[]): QueryToken[] {\r\n    return tokens\r\n      .filter(token => {\r\n        if (token.type !== 'term') return true;\r\n        if (token.value.startsWith('\"')) return true;\r\n        return !this.STOP_WORDS.has(token.value);\r\n      })\r\n      .map(token => this.normalizeToken(token));\r\n  }\r\n\r\n  private normalizeToken(token: QueryToken): QueryToken {\r\n    if (token.type === 'term' && !token.value.startsWith('\"')) {\r\n      let value = token.value;\r\n      \r\n      // Handle 'ing' ending\r\n      if (value.endsWith('ing')) {\r\n        // Keep root word - remove 'ing' and restore any dropped consonant\r\n        value = value.endsWith('ying') ? value.slice(0, -4) + 'y' :\r\n               value.endsWith('pping') ? value.slice(0, -4) :\r\n               value.slice(0, -3);\r\n      }\r\n      \r\n      // Handle 'ies' plurals\r\n      if (value.endsWith('ies')) {\r\n        value = value.slice(0, -3) + 'y';\r\n      }\r\n      // Handle regular plurals but not words ending in 'ss'\r\n      else if (value.endsWith('s') && !value.endsWith('ss')) {\r\n        value = value.slice(0, -1);\r\n      }\r\n      \r\n      // Handle 'ed' ending\r\n      if (value.endsWith('ed')) {\r\n        value = value.slice(0, -2);\r\n      }\r\n\r\n      return { ...token, value };\r\n    }\r\n    return token;\r\n  }\r\n\r\n  private optimizeQuery(tokens: QueryToken[]): string {\r\n    return tokens\r\n      .map(token => token.value)\r\n      .join(' ')\r\n      .trim()\r\n      .replace(/\\s+/g, ' ');  // normalize spaces\r\n  }\r\n}","import { SearchEngine } from \"@/core/SearchEngine\";\r\nimport { \r\n    DocumentVersion, \r\n    DocumentRelation, \r\n    NexusDocument, \r\n    AdvancedSearchOptions,\r\n    CreateDocumentOptions,\r\n    NexusDocumentMetadata,\r\n    NexusFields,\r\n    SearchResult,\r\n    DocumentContent,\r\n    BaseFields,\r\n    \r\n} from \"@/types\";\r\nimport { IndexedDocument } from \"@/storage/IndexedDocument\";\r\n\r\ninterface NexusDocumentInput extends Partial<NexusDocument> {\r\n    id?: string;\r\n    content?: DocumentContent;\r\n}\r\n\r\ninterface NexusDocumentPluginConfig {\r\n    name?: string;\r\n    version?: number;\r\n    fields?: string[];\r\n    storage?: {\r\n        type: 'memory' | 'indexeddb';\r\n        options?: Record<string, any>;\r\n    };\r\n    versioning?: {\r\n        enabled?: boolean;\r\n        maxVersions?: number;\r\n    };\r\n    validation?: {\r\n        required?: string[];\r\n        customValidators?: Record<string, (value: any) => boolean>;\r\n    };\r\n}\r\n\r\n/**\r\n * NexusDocumentAdapter provides document management functionality with search engine integration\r\n */\r\nexport class NexusDocumentAdapter implements NexusDocument {\r\n    private static searchEngine: SearchEngine;\r\n    private static config: Required<NexusDocumentPluginConfig>;\r\n\r\n    private readonly _id: string;\r\n    private _fields: NexusFields;\r\n    private _metadata: NexusDocumentMetadata;\r\n    private _versions: DocumentVersion[];\r\n    private _relations: DocumentRelation[];\r\n\r\n    get id(): string { return this._id; }\r\n    get fields(): NexusFields { return { ...this._fields }; }\r\n    get metadata(): NexusDocumentMetadata { return { ...this._metadata }; }\r\n    get versions(): DocumentVersion[] { return [...this._versions]; }\r\n    get relations(): DocumentRelation[] { return [...this._relations]; }\r\n\r\n    constructor(doc: NexusDocumentInput) {\r\n        this._id = doc.id || this.generateId();\r\n        this._fields = this.normalizeFields(doc.fields, doc.content);\r\n        this._metadata = this.normalizeMetadata(doc.metadata);\r\n        this._versions = doc.versions || [];\r\n        this._relations = doc.relations || [];\r\n    }\r\n\r\n    private normalizeFields(fields?: Partial<NexusFields>, content?: DocumentContent): NexusFields {\r\n        const now = new Date().toISOString();\r\n        return {\r\n            title: fields?.title || '',\r\n            content: this.normalizeContent(fields?.content || content),\r\n            type: fields?.type || 'document',\r\n            tags: Array.isArray(fields?.tags) ? [...fields.tags] : [],\r\n            category: fields?.category || '',\r\n            author: fields?.author || '',\r\n            created: fields?.created || now,\r\n            modified: fields?.modified || now,\r\n            status: fields?.status || 'draft',\r\n            version: fields?.version || '1.0',\r\n            locale: fields?.locale || '',\r\n        };\r\n    }\r\n\r\n    private normalizeMetadata(metadata?: Partial<NexusDocumentMetadata>): NexusDocumentMetadata {\r\n        const now = Date.now();\r\n        return {\r\n            indexed: metadata?.indexed ?? now,\r\n            lastModified: metadata?.lastModified ?? now,\r\n            checksum: metadata?.checksum,\r\n            permissions: metadata?.permissions || [],\r\n            workflow: metadata?.workflow,\r\n        };\r\n    }\r\n\r\n    private normalizeContent(content?: DocumentContent | string): DocumentContent {\r\n        if (typeof content === 'string') {\r\n            return { text: content };\r\n        }\r\n        return content || {};\r\n    }\r\n\r\n    clone(): NexusDocument {\r\n        return new NexusDocumentAdapter({\r\n            id: this._id,\r\n            fields: { ...this._fields },\r\n            metadata: { ...this._metadata },\r\n            versions: [...this._versions],\r\n            relations: [...this._relations]\r\n        });\r\n    }\r\n\r\n    update(updates: Partial<NexusDocument>): NexusDocument {\r\n        const newFields = updates.fields ? {\r\n            ...this._fields,\r\n            ...updates.fields,\r\n            modified: new Date().toISOString()\r\n        } : this._fields;\r\n\r\n        const newMetadata = updates.metadata ? {\r\n            ...this._metadata,\r\n            ...updates.metadata,\r\n            lastModified: Date.now()\r\n        } : this._metadata;\r\n\r\n        const versions = [...this._versions];\r\n        if (updates.fields?.content && updates.fields.content !== this._fields.content) {\r\n            versions.push({\r\n                version: versions.length + 1,\r\n                content: this._fields.content,\r\n                modified: new Date(),\r\n                author: this._fields.author\r\n            });\r\n        }\r\n\r\n        return new NexusDocumentAdapter({\r\n            id: this._id,\r\n            fields: newFields,\r\n            metadata: newMetadata,\r\n            versions,\r\n            relations: updates.relations || this._relations\r\n        });\r\n    }\r\n\r\n    document(): IndexedDocument {\r\n\r\n        return new IndexedDocument(this._id, this._fields as BaseFields, this._metadata, this._versions, this._relations);\r\n    }\r\n\r\n    toObject(): NexusDocument {\r\n        return {\r\n            id: this._id,\r\n            fields: this._fields,\r\n            metadata: this._metadata,\r\n            versions: this._versions,\r\n            relations: this._relations,\r\n            document: () => this.document(),\r\n            clone: () => this.clone(),\r\n            update: (updates) => this.update(updates),\r\n            toObject: () => this.toObject()\r\n        };\r\n    }\r\n\r\n    static async initialize(config: Partial<NexusDocumentPluginConfig> = {}): Promise<void> {\r\n        const defaultConfig = this.getDefaultConfig();\r\n        this.config = {\r\n            ...defaultConfig,\r\n            ...config,\r\n            versioning: { \r\n                enabled: true, \r\n                maxVersions: config.versioning?.maxVersions ?? defaultConfig.versioning.maxVersions \r\n            },\r\n            validation: { ...defaultConfig.validation, ...config.validation }\r\n        };\r\n\r\n        this.searchEngine = new SearchEngine({\r\n            name: this.config.name,\r\n            version: this.config.version,\r\n            fields: this.config.fields,\r\n            storage: this.config.storage,\r\n            documentSupport: {\r\n                enabled: true,\r\n                versioning: { \r\n                    enabled: true, \r\n                    maxVersions: this.config.versioning.maxVersions \r\n                },\r\n                validation: this.config.validation\r\n            }\r\n        });\r\n\r\n        await this.searchEngine.initialize();\r\n    }\r\n\r\n    private static getDefaultConfig(): Required<NexusDocumentPluginConfig> {\r\n        return {\r\n            name: 'nexus-document',\r\n            version: 1,\r\n            fields: ['title', 'content', 'type', 'tags', 'category', 'author'],\r\n            storage: { type: 'memory' },\r\n            versioning: {\r\n                enabled: true,\r\n                maxVersions: 10\r\n            },\r\n            validation: {\r\n                required: ['title', 'content'],\r\n                customValidators: {}\r\n            }\r\n        };\r\n    }\r\n\r\n    static async search(query: string, options: AdvancedSearchOptions = {}): Promise<SearchResult<NexusDocument>[]> {\r\n        const results = await this.searchEngine.search(query, options);\r\n        return results.map(result => ({\r\n            ...result,\r\n            item: new NexusDocumentAdapter(this.convertToNexusDocument(result.item))\r\n        }));\r\n    }\r\n\r\n    private static convertToNexusDocument(doc: IndexedDocument): NexusDocumentInput {\r\n        return {\r\n            id: doc.id,\r\n            fields: {\r\n                ...doc.fields,\r\n                type: 'document',\r\n                created: doc.fields.modified || new Date().toISOString(),\r\n                status: 'draft'\r\n            },\r\n            metadata: doc.metadata as NexusDocumentMetadata,\r\n            versions: doc.versions,\r\n            relations: doc.relations\r\n        };\r\n    }\r\n\r\n    static async create(options: CreateDocumentOptions): Promise<NexusDocument> {\r\n        this.validateDocument(options);\r\n        const doc = new NexusDocumentAdapter({\r\n            fields: {\r\n                title: options.title,\r\n                content: options.content,\r\n                type: options.type,\r\n                tags: options.tags || [],\r\n                category: options.category,\r\n                author: options.author,\r\n                created: new Date().toISOString(),\r\n                modified: new Date().toISOString(),\r\n                status: options.status || 'draft',\r\n                version: '1.0',\r\n                locale: options.locale\r\n            },\r\n            metadata: new NexusDocumentAdapter({}).normalizeMetadata(options.metadata)\r\n        });\r\n        await doc.save();\r\n        return doc;\r\n    }\r\n\r\n    static async get(id: string): Promise<NexusDocument> {\r\n        const doc = await this.searchEngine.getDocument(id);\r\n        if (!doc) {\r\n            throw new Error(`Document ${id} not found`);\r\n        }\r\n        return new NexusDocumentAdapter(this.convertToNexusDocument(doc));\r\n    }\r\n\r\n    async save(): Promise<void> {\r\n        NexusDocumentAdapter.validateDocument(this._fields);\r\n        await NexusDocumentAdapter.searchEngine.updateDocument(this.document());\r\n    }\r\n\r\n    async delete(): Promise<void> {\r\n        await NexusDocumentAdapter.searchEngine.removeDocument(this._id);\r\n    }\r\n\r\n    private generateId(): string {\r\n        return `doc-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;\r\n    }\r\n\r\n    private static validateDocument(doc: Partial<CreateDocumentOptions | NexusFields>): void {\r\n        const { required = [], customValidators = {} } = this.config.validation;\r\n\r\n        for (const field of required) {\r\n            if (!doc[field as keyof typeof doc]) {\r\n                throw new Error(`Field '${field}' is required`);\r\n            }\r\n        }\r\n\r\n        for (const [field, validator] of Object.entries(customValidators)) {\r\n            const value = doc[field as keyof typeof doc];\r\n            if (value !== undefined && !validator(value)) {\r\n                throw new Error(`Validation failed for field '${field}'`);\r\n            }\r\n        }\r\n    }\r\n}","\r\nimport { CacheManager, IndexedDocument, SearchStorage } from \"@/storage\";\r\n\r\nimport {\r\n    SearchOptions,\r\n    SearchResult,\r\n    SearchEngineConfig,\r\n    SearchEventListener,\r\n    SearchEvent,\r\n    IndexNode,\r\n    DocumentContent,\r\n    BaseFields,\r\n    DocumentMetadata,\r\n    DocumentStatus,\r\n    ExtendedSearchOptions,\r\n    RegexSearchConfig,\r\n    RegexSearchResult,\r\n    \r\n} from \"@/types\";\r\nimport { validateSearchOptions, bfsRegexTraversal, dfsRegexTraversal } from \"@/utils\";\r\nimport { IndexManager } from \"../storage/IndexManager\";\r\nimport { QueryProcessor } from \"./QueryProcessor\";\r\nimport { TrieSearch } from \"@/algorithms/trie\";\r\nimport { NexusDocumentAdapter } from \"@/adapters\";\r\n\r\n\r\nexport class SearchEngine {\r\n    private readonly queryProcessor: QueryProcessor;\r\n    private storage: SearchStorage;\r\n    private readonly cache: CacheManager;\r\n    private readonly config: SearchEngineConfig;\r\n    private readonly eventListeners: Set<SearchEventListener>;\r\n    private trie: TrieSearch;\r\n    private isInitialized: boolean = false;\r\n    private documents: Map<string, IndexedDocument>;\r\n    private trieRoot: IndexNode;\r\n    private readonly documentSupport: boolean;\r\n    private readonly indexManager: IndexManager;\r\n\r\n    constructor(config: SearchEngineConfig) {\r\n        this.config = config;\r\n        this.indexManager = new IndexManager(config);\r\n        this.queryProcessor = new QueryProcessor();\r\n        this.storage = new SearchStorage(config.storage);\r\n        this.cache = new CacheManager();\r\n        this.eventListeners = new Set();\r\n        this.trie = new TrieSearch();\r\n        this.documents = new Map();\r\n        this.documentSupport = config.documentSupport?.enabled ?? false;\r\n        this.config = config;\r\n        this.indexManager = new IndexManager(config);\r\n        this.queryProcessor = new QueryProcessor();\r\n        this.storage = new SearchStorage(config.storage);\r\n        this.cache = new CacheManager();\r\n        this.eventListeners = new Set();\r\n        this.trie = new TrieSearch();\r\n        this.documents = new Map();\r\n        this.trieRoot = { id: '', value: '', score: 0, children: new Map(), depth: 0 };\r\n    } \r\n   \r\n    private extractRegexMatches(\r\n        doc: IndexedDocument,\r\n        positions: Array<[number, number]>,\r\n        options: SearchOptions\r\n    ): string[] {\r\n        const searchFields = options.fields || this.config.fields;\r\n        const matches = new Set<string>();\r\n\r\n        for (const field of searchFields) {\r\n            const fieldContent = String(doc.fields[field] || '');\r\n            for (const [start, end] of positions) {\r\n                if (start >= 0 && end <= fieldContent.length) {\r\n                    matches.add(fieldContent.slice(start, end));\r\n                }\r\n            }\r\n        }\r\n\r\n        return Array.from(matches);\r\n    }\r\n\r\n    public async initialize(): Promise<void> {\r\n        if (this.isInitialized) return;\r\n\r\n        try {\r\n            try {\r\n                await this.storage.initialize();\r\n            } catch (storageError) {\r\n                this.emitEvent({\r\n                    type: 'storage:error',\r\n                    timestamp: Date.now(),\r\n                    error: storageError instanceof Error ? storageError : new Error(String(storageError))\r\n                });\r\n\r\n                this.storage = new SearchStorage({ type: 'memory' });\r\n                await this.storage.initialize();\r\n            }\r\n\r\n            await this.loadIndexes();\r\n            this.isInitialized = true;\r\n\r\n            this.emitEvent({\r\n                type: 'engine:initialized',\r\n                timestamp: Date.now()\r\n            });\r\n        } catch (error) {\r\n            throw new Error(`Failed to initialize search engine: ${String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add documents to the search engine\r\n     */\r\n    public async addDocuments(documents: IndexedDocument[]): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            const normalizedDocs = documents.map(doc => this.normalizeDocument(doc));\r\n            \r\n            if (this.documentSupport && this.config.documentSupport?.validation) {\r\n                this.validateDocuments(normalizedDocs);\r\n            }\r\n\r\n            for (const doc of normalizedDocs) {\r\n                this.documents.set(doc.id, doc);\r\n\r\n                // Convert type-specific fields with proper type safety\r\n                const adaptedDoc = new NexusDocumentAdapter({\r\n                    id: doc.id,\r\n                    fields: {\r\n                        ...doc.fields,\r\n                        title: String(doc.fields.title || ''),\r\n                        content: this.normalizeContent(doc.fields.content),\r\n                        author: String(doc.fields.author || ''),\r\n                        type: String(doc.fields.type || 'document'),\r\n                        tags: Array.isArray(doc.fields.tags) ? doc.fields.tags.map(String) : [],\r\n                        category: String(doc.fields.category || ''),\r\n                        created: this.normalizeDate(doc.fields.created) || new Date().toISOString(),\r\n                        modified: this.normalizeDate(doc.fields.modified) || new Date().toISOString(),\r\n                        status: this.normalizeStatus(doc.fields.status) || 'draft',\r\n                        version: String(doc.fields.version || '1.0'),\r\n                        locale: String(doc.fields.locale || '')\r\n                    },\r\n                    metadata: {\r\n                        ...doc.metadata,\r\n                        indexed: doc.metadata?.indexed ?? Date.now(),\r\n                        lastModified: doc.metadata?.lastModified ?? Date.now()\r\n                    },\r\n                    versions: doc.versions,\r\n                    relations: doc.relations\r\n                });\r\n\r\n                this.trie.addDocument(adaptedDoc);\r\n                this.indexManager.addDocument(adaptedDoc);\r\n            }\r\n\r\n            await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n            this.cache.clear();\r\n\r\n            this.emitEvent({\r\n                type: 'index:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentCount: documents.length }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'index:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to normalize document content\r\n     */\r\n    private normalizeContent(content: unknown): DocumentContent {\r\n        if (!content) return {};\r\n        if (typeof content === 'string') return { text: content };\r\n        if (typeof content === 'object') return content as DocumentContent;\r\n        return { value: String(content) };\r\n    }\r\n\r\n    /**\r\n     * Helper method to normalize date strings\r\n     */\r\n    private normalizeDate(date: unknown): string | undefined {\r\n        if (!date) return undefined;\r\n        if (date instanceof Date) return date.toISOString();\r\n        if (typeof date === 'string') return new Date(date).toISOString();\r\n        if (typeof date === 'number') return new Date(date).toISOString();\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Helper method to normalize document status\r\n     */\r\n    private normalizeStatus(status: unknown): DocumentStatus | undefined {\r\n        if (!status) return undefined;\r\n        const statusStr = String(status).toLowerCase();\r\n        \r\n        switch (statusStr) {\r\n            case 'draft':\r\n            case 'published':\r\n            case 'archived':\r\n                return statusStr as DocumentStatus;\r\n            case 'active':\r\n                return 'published';\r\n            default:\r\n                return 'draft';\r\n        }\r\n    }\r\n\r\n  \r\n\r\n    public async updateDocument(document: IndexedDocument): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        const normalizedDoc = this.normalizeDocument(document);\r\n        await this.handleVersioning(normalizedDoc);\r\n\r\n        if (this.documentSupport && this.config.documentSupport?.versioning?.enabled) {\r\n            await this.handleVersioning(normalizedDoc);\r\n        }\r\n\r\n        this.documents.set(normalizedDoc.id, normalizedDoc);\r\n        this.trie.addDocument(normalizedDoc);\r\n        await this.indexManager.updateDocument(normalizedDoc);\r\n    }    public async search(\r\n        query: string,\r\n        options: ExtendedSearchOptions = {}\r\n    ): Promise<SearchResult<IndexedDocument>[]> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n    \r\n        validateSearchOptions(options);\r\n    \r\n        const searchStartTime = Date.now();\r\n        this.emitEvent({\r\n            type: 'search:start',\r\n            timestamp: searchStartTime,\r\n            data: { query, options }\r\n        });\r\n    \r\n        const cacheKey = this.generateCacheKey(query, options);\r\n        const cachedResults = this.cache.get(cacheKey);\r\n        if (cachedResults) {\r\n            return cachedResults as SearchResult<IndexedDocument>[];\r\n        }\r\n    \r\n        try {\r\n            let results: RegexSearchResult[] | Array<{ id: string; score: number }>;\r\n    \r\n            if (options.regex) {\r\n                results = await this.performRegexSearch(query, options);\r\n            } else {\r\n                const processedQuery = this.queryProcessor.process(query);\r\n                const searchTerms = processedQuery.toLowerCase().split(/\\s+/).filter(Boolean);\r\n                results = await this.performBasicSearch(searchTerms, options);\r\n            }\r\n    \r\n            const searchResults = await this.processSearchResults(results, options);\r\n            this.cache.set(cacheKey, searchResults);\r\n    \r\n            this.emitEvent({\r\n                type: 'search:complete',\r\n                timestamp: Date.now(),\r\n                data: {\r\n                    query,\r\n                    options,\r\n                    resultCount: searchResults.length,\r\n                    searchTime: Date.now() - searchStartTime\r\n                }\r\n            });\r\n    \r\n            return searchResults;\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'search:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Search failed: ${error}`);\r\n        }\r\n    }\r\n/**\r\n * Performs regex-based search using either BFS or DFS traversal\r\n */\r\nprivate async performRegexSearch(\r\n    query: string,\r\n    options: ExtendedSearchOptions\r\n): Promise<SearchResult<IndexedDocument>[]> {\r\n    const regexConfig: RegexSearchConfig = {\r\n        maxDepth: options.regexConfig?.maxDepth || 50,\r\n        timeoutMs: options.regexConfig?.timeoutMs || 5000,\r\n        caseSensitive: options.regexConfig?.caseSensitive || false,\r\n        wholeWord: options.regexConfig?.wholeWord || false\r\n    };\r\n\r\n    const regex = this.createRegexFromOption(options.regex || '');\r\n\r\n    // Determine search strategy based on regex complexity\r\n    const regexResults = this.isComplexRegex(regex) ?\r\n        await dfsRegexTraversal(\r\n            this.trieRoot,\r\n            regex,\r\n            options.maxResults || 10,\r\n            regexConfig\r\n        ) :\r\n        await bfsRegexTraversal(\r\n            this.trieRoot,\r\n            regex,\r\n            options.maxResults || 10,\r\n            regexConfig\r\n        );\r\n\r\n    // Map regex results to SearchResult format\r\n    return regexResults.map(result => {\r\n        const document = this.documents.get(result.id);\r\n        if (!document) {\r\n            throw new Error(`Document not found for id: ${result.id}`);\r\n        }\r\n\r\n        return {\r\n            id: result.id,\r\n            docId: result.id,\r\n            term: result.matches[0] || query, // Use first match or query as term\r\n            score: result.score,\r\n            matches: result.matches,\r\n            document: document,\r\n            item: document,\r\n            metadata: {\r\n                ...document.metadata,\r\n                lastAccessed: Date.now()\r\n            }\r\n        };\r\n    }).filter(result => result.score >= (options.minScore || 0));\r\n}\r\n\r\n\r\n\r\n    private async performBasicSearch(\r\n        searchTerms: string[],\r\n        options: SearchOptions\r\n    ): Promise<Array<{ id: string; score: number }>> {\r\n        const results = new Map<string, { score: number; matches: Set<string> }>();\r\n    \r\n        for (const term of searchTerms) {\r\n            const matches = options.fuzzy ?\r\n                this.trie.fuzzySearch(term, options.maxDistance || 2) :\r\n                this.trie.search(term);\r\n    \r\n            for (const match of matches) {\r\n                const docId = match.docId;\r\n                const current = results.get(docId) || { score: 0, matches: new Set<string>() };\r\n                current.score += this.calculateTermScore(term, docId, options);\r\n                current.matches.add(term);\r\n                results.set(docId, current);\r\n            }\r\n        }\r\n    \r\n        return Array.from(results.entries())\r\n            .map(([id, { score }]) => ({ id, score }))\r\n            .sort((a, b) => b.score - a.score);\r\n    }\r\n\r\n    /**\r\n * Creates a RegExp object from various input types\r\n */\r\nprivate createRegexFromOption(regexOption: string | RegExp | object): RegExp {\r\n    if (regexOption instanceof RegExp) {\r\n        return regexOption;\r\n    }\r\n    if (typeof regexOption === 'string') {\r\n        return new RegExp(regexOption);\r\n    }\r\n    if (typeof regexOption === 'object' && regexOption !== null) {\r\n        const pattern = (regexOption as any).pattern;\r\n        const flags = (regexOption as any).flags;\r\n        return new RegExp(pattern || '', flags || '');\r\n    }\r\n    return new RegExp('');\r\n}\r\n\r\n\r\n/**\r\n * Determines if a regex pattern is complex\r\n */\r\nprivate isComplexRegex(regex: RegExp): boolean {\r\n    const pattern = regex.source;\r\n    return (\r\n        pattern.includes('{') ||\r\n        pattern.includes('+') ||\r\n        pattern.includes('*') ||\r\n        pattern.includes('?') ||\r\n        pattern.includes('|') ||\r\n        pattern.includes('(?') ||\r\n        pattern.includes('[') ||\r\n        pattern.length > 20  // Additional complexity check based on pattern length\r\n    );\r\n}\r\n    private async processSearchResults(\r\n        results: RegexSearchResult[] | Array<{ id: string; score: number }>,\r\n        options: SearchOptions\r\n    ): Promise<SearchResult<IndexedDocument>[]> {\r\n        const processedResults: SearchResult<IndexedDocument>[] = [];\r\n    \r\n        for (const result of results) {\r\n            const doc = this.documents.get(result.id);\r\n            if (!doc) continue;\r\n    \r\n            const searchResult: SearchResult<IndexedDocument> = {\r\n                id: result.id,\r\n                docId: result.id,\r\n                item: doc,\r\n                score: (result as { score: number }).score ? this.normalizeScore((result as { score: number }).score) : (result as { score: number }).score,\r\n                matches: [],\r\n                metadata: {\r\n                    ...doc.metadata,\r\n                    lastAccessed: Date.now()\r\n                },\r\n                document: doc,\r\n                term: 'matched' in result ? String(result.matched) : '',\r\n            };\r\n    \r\n            if (options.includeMatches) {\r\n                if ('positions' in result) {\r\n                    // Handle regex search results\r\n                    searchResult.matches = this.extractRegexMatches(doc, result.positions as [number, number][], options);\r\n                } else {\r\n                    // Handle basic search results\r\n                    searchResult.matches = this.extractMatches(doc, options);\r\n                }\r\n            }\r\n    \r\n            processedResults.push(searchResult);\r\n        }\r\n    \r\n        return this.applyPagination(processedResults, options);\r\n    }\r\n\r\n  \r\n    public getTrieState(): unknown {\r\n        return this.trie.serializeState();\r\n    }\r\n    \r\n   \r\n\r\n    private validateDocuments(documents: IndexedDocument[]): void {\r\n        if (!this.config.documentSupport?.validation) return;\r\n\r\n        const { required = [], customValidators = {} } = this.config.documentSupport.validation;\r\n\r\n        for (const doc of documents) {\r\n            // Check required fields\r\n            for (const field of required) {\r\n                if (!doc.fields[field]) {\r\n                    throw new Error(`Field '${field}' is required for document ${doc.id}`);\r\n                }\r\n            }\r\n\r\n            // Run custom validators\r\n            Object.entries(customValidators).forEach(([field, validator]) => {\r\n                const value = doc.fields[field];\r\n                if (value !== undefined && !validator(value)) {\r\n                    throw new Error(`Validation failed for field '${field}' in document ${doc.id}`);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    \r\n    public async removeDocument(documentId: string): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        if (!this.documents.has(documentId)) {\r\n            throw new Error(`Document ${documentId} not found`);\r\n        }\r\n\r\n        try {\r\n            this.documents.delete(documentId);\r\n            this.trie.removeDocument(documentId);\r\n            await this.indexManager.removeDocument(documentId);\r\n            this.cache.clear();\r\n\r\n            try {\r\n                await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n            } catch (storageError) {\r\n                this.emitEvent({\r\n                    type: 'storage:error',\r\n                    timestamp: Date.now(),\r\n                    error: storageError instanceof Error ? storageError : new Error(String(storageError))\r\n                });\r\n            }\r\n\r\n            this.emitEvent({\r\n                type: 'remove:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentId }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'remove:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to remove document: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async clearIndex(): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            await this.storage.clearIndices();\r\n            this.documents.clear();\r\n            this.trie = new TrieSearch();\r\n            this.indexManager.clear();\r\n            this.cache.clear();\r\n\r\n            this.emitEvent({\r\n                type: 'index:clear',\r\n                timestamp: Date.now()\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'index:clear:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to clear index: ${error}`);\r\n        }\r\n    }\r\n\r\n    private calculateTermScore(term: string, docId: string, options: SearchOptions): number {\r\n        const doc = this.documents.get(docId);\r\n        if (!doc) return 0;\r\n\r\n        const searchFields = options.fields || this.config.fields;\r\n        let score = 0;\r\n\r\n        for (const field of searchFields) {\r\n            const fieldContent = String(doc.fields[field] || '').toLowerCase();\r\n            const fieldBoost = (options.boost?.[field] || 1);\r\n            const termFrequency = (fieldContent.match(new RegExp(term, 'gi')) || []).length;\r\n            score += termFrequency * fieldBoost;\r\n        }\r\n\r\n        return score;\r\n    }\r\n\r\n    private normalizeScore(score: number): number {\r\n        return Math.min(Math.max(score / 100, 0), 1);\r\n    }\r\n\r\n    private extractMatches(doc: IndexedDocument, options: SearchOptions): string[] {\r\n        const matches = new Set<string>();\r\n        const searchFields = options.fields || this.config.fields;\r\n\r\n        for (const field of searchFields) {\r\n            const fieldContent = String(doc.fields[field] || '').toLowerCase();\r\n\r\n            if (options.regex) {\r\n                const regex = typeof options.regex === 'string' ?\r\n                    new RegExp(options.regex, 'gi') :\r\n                    new RegExp(options.regex.source, 'gi');\r\n\r\n                const fieldMatches = fieldContent.match(regex) || [];\r\n                fieldMatches.forEach(match => matches.add(match));\r\n            }\r\n        }\r\n\r\n        return Array.from(matches);\r\n    }\r\n\r\n    private applyPagination(\r\n        results: SearchResult<IndexedDocument>[],\r\n        options: SearchOptions\r\n    ): SearchResult<IndexedDocument>[] {\r\n        const page = options.page || 1;\r\n        const pageSize = options.pageSize || 10;\r\n        const start = (page - 1) * pageSize;\r\n        return results.slice(start, start + pageSize);\r\n    }\r\n\r\n \r\n\r\n    private async loadIndexes(): Promise<void> {\r\n        try {\r\n            const storedIndex = await this.storage.getIndex(this.config.name);\r\n            if (storedIndex) {\r\n                this.indexManager.importIndex(storedIndex);\r\n                const indexedDocs = this.indexManager.getAllDocuments();\r\n                for (const doc of indexedDocs) {\r\n                    this.documents.set(doc[1].id, IndexedDocument.fromObject({\r\n                        id: doc[1].id,\r\n                        fields: {\r\n                            title: doc[1].fields.title,\r\n                            content: doc[1].fields.content,\r\n                            author: doc[1].fields.author,\r\n                            tags: doc[1].fields.tags,\r\n                            version: doc[1].fields.version\r\n                        },\r\n                        metadata: doc[1].metadata\r\n                    }));\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.warn('Failed to load stored index, starting fresh:', error);\r\n        }\r\n    }\r\n\r\n    private generateCacheKey(query: string, options: SearchOptions): string {\r\n        return `${this.config.name}-${query}-${JSON.stringify(options)}`;\r\n    }\r\n\r\n    public addEventListener(listener: SearchEventListener): void {\r\n        this.eventListeners.add(listener);\r\n    }\r\n\r\n    public removeEventListener(listener: SearchEventListener): void {\r\n        this.eventListeners.delete(listener);\r\n    }\r\n\r\n   /**\r\n     * Emit search engine events\r\n     */\r\n   private emitEvent(event: SearchEvent): void {\r\n    this.eventListeners.forEach(listener => {\r\n        try {\r\n            listener(event);\r\n        } catch (error) {\r\n            console.error('Error in event listener:', error);\r\n        }\r\n    });\r\n}\r\n    public async close(): Promise<void> {\r\n        try {\r\n            await this.storage.close();\r\n            this.cache.clear();\r\n            this.documents.clear();\r\n            this.isInitialized = false;\r\n\r\n            this.emitEvent({\r\n                type: 'engine:closed',\r\n                timestamp: Date.now()\r\n            });\r\n        } catch (error) {\r\n            console.warn('Error during close:', error);\r\n        }\r\n    }\r\n\r\n    public getIndexedDocumentCount(): number {\r\n        return this.documents.size;\r\n    }\r\n\r\n  \r\n    public async bulkUpdate(updates: Map<string, Partial<IndexedDocument>>): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        const updatePromises: Promise<void>[] = [];\r\n\r\n        for (const [id, update] of updates) {\r\n            const existingDoc = this.documents.get(id);\r\n            if (existingDoc) {\r\n                const updatedDoc = new IndexedDocument(\r\n                    id,\r\n                    { ...existingDoc.fields, ...update.fields },\r\n                    { ...existingDoc.metadata, ...update.metadata }\r\n                );\r\n                updatePromises.push(this.updateDocument(updatedDoc));\r\n            }\r\n        }\r\n\r\n        try {\r\n            await Promise.all(updatePromises);\r\n            this.emitEvent({\r\n                type: 'bulk:update:complete',\r\n                timestamp: Date.now(),\r\n                data: { updateCount: updates.size }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'bulk:update:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Bulk update failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async importIndex(indexData: unknown): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            await this.clearIndex();\r\n            this.indexManager.importIndex(indexData);\r\n\r\n            const indexedDocuments = Array.from(this.documents.values()).map(doc => IndexedDocument.fromObject(doc));\r\n\r\n            await this.addDocuments(indexedDocuments);\r\n\r\n            this.emitEvent({\r\n                type: 'import:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentCount: this.documents.size }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'import:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Import failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    public exportIndex(): unknown {\r\n        if (!this.isInitialized) {\r\n            throw new Error('Search engine not initialized');\r\n        }\r\n        return this.indexManager.exportIndex();\r\n    }\r\n\r\n    public getDocument(id: string): IndexedDocument | undefined {\r\n        return this.documents.get(id);\r\n    }\r\n\r\n    public getAllDocuments(): IndexedDocument[] {\r\n        return Array.from(this.documents.values());\r\n    }\r\n\r\n    public async reindexAll(): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            const documents = this.getAllDocuments();\r\n            await this.clearIndex();\r\n            await this.addDocuments(documents);\r\n\r\n            this.emitEvent({\r\n                type: 'reindex:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentCount: documents.length }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'reindex:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Reindex failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async optimizeIndex(): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            // Trigger cache cleanup\r\n            this.cache.clear();\r\n\r\n            // Compact storage if possible\r\n            if (this.storage instanceof SearchStorage) {\r\n                await this.storage.clearIndices();\r\n                await this.storage.storeIndex(\r\n                    this.config.name,\r\n                    this.indexManager.exportIndex()\r\n                );\r\n            }\r\n\r\n            this.emitEvent({\r\n                type: 'optimize:complete',\r\n                timestamp: Date.now()\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'optimize:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Optimization failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    public  async handleVersioning(doc: IndexedDocument): Promise<void> {\r\n        const existingDoc = await this.getDocument(doc.id);\r\n        if (!existingDoc) return;\r\n\r\n        const maxVersions = this.config.documentSupport?.versioning?.maxVersions ?? 10;\r\n        const versions = existingDoc.versions || [];\r\n\r\n        if (doc.fields.content !== existingDoc.fields.content) {\r\n            versions.push({\r\n                version: Number(existingDoc.fields.version),\r\n                content: existingDoc.fields.content,\r\n                modified: new Date(existingDoc.fields.modified || Date.now()),\r\n                author: existingDoc.fields.author\r\n            });\r\n\r\n            // Keep only the latest versions\r\n            if (versions.length > maxVersions) {\r\n                versions.splice(0, versions.length - maxVersions);\r\n            }\r\n\r\n            doc.versions = versions;\r\n            doc.fields.version = String(Number(doc.fields.version) + 1);\r\n        }\r\n    }\r\n \r\n\r\n    private normalizeDocument(doc: IndexedDocument): IndexedDocument {\r\n        if (!this.documentSupport) {\r\n            return doc;\r\n        }\r\n\r\n        const normalizedFields: BaseFields = {\r\n            title: doc.fields.title || '',\r\n            content: doc.fields.content as DocumentContent,\r\n            author: doc.fields.author || '',\r\n            tags: Array.isArray(doc.fields.tags) ? doc.fields.tags : [],\r\n            version: doc.fields.version || '1.0',\r\n        };\r\n\r\n        const normalizedMetadata: DocumentMetadata = {\r\n            indexed: doc.metadata?.indexed || Date.now(),\r\n            lastModified: doc.metadata?.lastModified || Date.now(),\r\n        };\r\n\r\n        return new IndexedDocument(\r\n            doc.id,\r\n            normalizedFields,\r\n            normalizedMetadata\r\n        );\r\n    }\r\n\r\n    public async restoreVersion(id: string, version: number): Promise<void> {\r\n        if (!this.documentSupport) {\r\n            throw new Error('Document support is not enabled');\r\n        }\r\n\r\n        const doc = await this.getDocument(id);\r\n        if (!doc) {\r\n            throw new Error(`Document ${id} not found`);\r\n        }\r\n\r\n        const targetVersion = await this.getDocumentVersion(id, version);\r\n        if (!targetVersion) {\r\n            throw new Error(`Version ${version} not found for document ${id}`);\r\n        }\r\n\r\n        const updatedDoc = new IndexedDocument(\r\n            doc.id,\r\n            {\r\n                ...doc.fields,\r\n                content: targetVersion.content,\r\n                modified: new Date().toISOString(),\r\n                version: String(Number(doc.fields.version) + 1)\r\n            },\r\n            {\r\n                ...doc.metadata,\r\n                lastModified: Date.now()\r\n            }\r\n        );\r\n\r\n        await this.updateDocument(updatedDoc);\r\n    }\r\n\r\n    // Additional NexusDocument specific methods that are only available when document support is enabled\r\n    public async getDocumentVersion(id: string, version: number): Promise<any | undefined> {\r\n        if (!this.documentSupport) {\r\n            throw new Error('Document support is not enabled');\r\n        }\r\n\r\n        const doc = await this.getDocument(id);\r\n        return doc?.versions?.find(v => v.version === version);\r\n    }\r\n\r\n\r\n    public getStats(): {\r\n        documentCount: number;\r\n        indexSize: number;\r\n        cacheSize: number;\r\n        initialized: boolean;\r\n    } {\r\n        return {\r\n            documentCount: this.documents.size,\r\n            indexSize: this.indexManager.getSize(),\r\n            cacheSize: this.cache.getSize(),\r\n            initialized: this.isInitialized\r\n        };\r\n    }\r\n\r\n    public isReady(): boolean {\r\n        return this.isInitialized;\r\n    }\r\n}","export class SearchError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'SearchError';\r\n  }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class StorageError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'StorageError';\r\n  }\r\n}\r\n\r\nexport class CacheError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'CacheError';\r\n  }\r\n}\r\n\r\nexport class MapperError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'MapperError';\r\n  }\r\n}\r\n\r\nexport class PerformanceError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'PerformanceError';\r\n  }\r\n}\r\n\r\nexport class ConfigError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ConfigError';\r\n  }\r\n}\r\n\r\n","export type SearchEventType =\r\n    // Engine lifecycle events\r\n    | 'engine:initialized'\r\n    | 'engine:closed'\r\n    \r\n    // Index operations\r\n    | 'index:start'\r\n    | 'index:complete'\r\n    | 'index:error'\r\n    | 'index:clear'\r\n    | 'index:clear:error'\r\n    \r\n    // Search operations\r\n    | 'search:start'\r\n    | 'search:complete'\r\n    | 'search:error'\r\n    \r\n    // Document operations\r\n    | 'update:start'\r\n    | 'update:complete'\r\n    | 'update:error'\r\n    | 'remove:start'\r\n    | 'remove:complete'\r\n    | 'remove:error'\r\n    \r\n    // Bulk operations\r\n    | 'bulk:update:start'\r\n    | 'bulk:update:complete'\r\n    | 'bulk:update:error'\r\n    \r\n    // Import/Export operations\r\n    | 'import:start'\r\n    | 'import:complete'\r\n    | 'import:error'\r\n    | 'export:start'\r\n    | 'export:complete'\r\n    | 'export:error'\r\n    \r\n    // Optimization operations\r\n    | 'optimize:start'\r\n    | 'optimize:complete'\r\n    | 'optimize:error'\r\n    \r\n    // Reindex operations\r\n    | 'reindex:start'\r\n    | 'reindex:complete'\r\n    | 'reindex:error'\r\n    \r\n    // Storage operations\r\n    | 'storage:error'\r\n    | 'storage:clear'\r\n    | 'storage:clear:error';\r\n\r\nexport interface BaseEvent {\r\n    timestamp: number;\r\n    region?: string;\r\n}\r\n\r\nexport interface SuccessEvent extends BaseEvent {\r\n    data?: {\r\n        documentCount?: number;\r\n        searchTime?: number;\r\n        resultCount?: number;\r\n        documentId?: string;\r\n        updateCount?: number;\r\n        query?: string;\r\n        options?: unknown;\r\n    };\r\n}\r\n\r\nexport interface ErrorEvent extends BaseEvent {\r\n    error: Error;\r\n    details?: {\r\n        documentId?: string;\r\n        operation?: string;\r\n        phase?: string;\r\n    };\r\n}\r\n\r\nexport interface SearchEvent extends BaseEvent {\r\n    type: SearchEventType;\r\n    data?: unknown;\r\n    error?: Error;\r\n    regex?: RegExp;\r\n}\r\n\r\nexport interface IndexNode {\r\n    id?: string;\r\n    value?: unknown;\r\n    score: number;\r\n    children: Map<string, IndexNode>;\r\n}\r\n\r\nexport interface SearchEventListener {\r\n    (event: SearchEvent): void;\r\n}\r\n\r\nexport interface SearchEventEmitter {\r\n    addEventListener(listener: SearchEventListener): void;\r\n    removeEventListener(listener: SearchEventListener): void;\r\n    emitEvent(event: SearchEvent): void;\r\n}\r\n\r\nexport class SearchEventError extends Error {\r\n    constructor(\r\n        message: string,\r\n        public readonly type: SearchEventType,\r\n        public readonly details?: unknown\r\n    ) {\r\n        super(message);\r\n        this.name = 'SearchEventError';\r\n    }\r\n}","import { SearchResult } from \"./search\";\r\n\r\nexport interface CacheOptions {\r\n    maxSize: number;\r\n    ttlMinutes: number;\r\n}\r\nexport interface CacheEntry {\r\n    data: SearchResult<unknown>[];\r\n    timestamp: number;\r\n    lastAccessed: number;\r\n    accessCount: number;\r\n}\r\n\r\n\r\n\r\nexport interface CacheOptions {\r\n    strategy: CacheStrategyType;\r\n    maxSize: number;\r\n    ttlMinutes: number;\r\n}\r\n\r\nexport enum CacheStrategyType {\r\n    LRU = 'LRU',\r\n    MRU = 'MRU'\r\n  }\r\n\r\n  export type CacheStrategy = keyof typeof CacheStrategyType;\r\n  \r\n  export interface CacheStatus {\r\n    size: number;\r\n    maxSize: number;\r\n    strategy: CacheStrategy;\r\n    ttl: number;\r\n    utilization: number;\r\n    oldestEntryAge: number | null;\r\n    newestEntryAge: number | null;\r\n    memoryUsage: {\r\n        bytes: number;\r\n        formatted: string;\r\n    };\r\n}","/// <reference types=\"node\"/>\r\nimport type {\r\n    IndexConfig,\r\n    SearchContext,\r\n    SearchOptions,\r\n    SearchResult,\r\n    SearchStats,\r\n    SearchEventType,\r\n    SearchEvent,\r\n    DocumentLink,\r\n    DocumentRank,\r\n} from './types/index';\r\nimport { DEFAULT_SEARCH_OPTIONS , DEFAULT_INDEX_OPTIONS} from './types/defaults';\r\n// Export type declarations\r\nexport { DocumentLink, DocumentRank, SearchEvent, SearchEventType, SearchStats, SearchContext };\r\n\r\n// Core imports\r\nimport { SearchEngine } from '@core/SearchEngine';\r\nimport { IndexManager } from '@storage/IndexManager';\r\nimport { QueryProcessor } from '@core/QueryProcessor';\r\n\r\n// Algorithm imports\r\nimport { TrieNode } from '@algorithms/trie/TrieNode';\r\nimport { TrieSearch } from '@algorithms/trie/TrieSearch';\r\n\r\n// Mapper imports\r\nimport { DataMapper } from '@/mappers/DataMapper';\r\nimport { IndexMapper } from '@/mappers/IndexMapper';\r\n\r\n// Storage imports\r\nimport { CacheManager } from '@storage/CacheManager';\r\nimport { IndexedDB } from '@storage/IndexedDBService';\r\n\r\n// Utility imports\r\nimport {\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n} from '@utils/index';\r\n\r\n// Export all types\r\nexport * from './types/';\r\n\r\n\r\n// Custom error classes\r\nexport class SearchError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'SearchError';\r\n    }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'IndexError';\r\n    }\r\n}\r\n\r\n// Type guards with improved type checking\r\nexport function isSearchOptions(obj: unknown): obj is SearchOptions {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const options = obj as Partial<SearchOptions>;\r\n    \r\n    return (\r\n        (typeof options.fuzzy === 'undefined' || typeof options.fuzzy === 'boolean') &&\r\n        (typeof options.maxResults === 'undefined' || typeof options.maxResults === 'number') &&\r\n        (typeof options.threshold === 'undefined' || typeof options.threshold === 'number') &&\r\n        (typeof options.fields === 'undefined' || Array.isArray(options.fields)) &&\r\n        (typeof options.sortBy === 'undefined' || typeof options.sortBy === 'string') &&\r\n        (typeof options.sortOrder === 'undefined' || ['asc', 'desc'].includes(options.sortOrder)) &&\r\n        (typeof options.page === 'undefined' || typeof options.page === 'number') &&\r\n        (typeof options.pageSize === 'undefined' || typeof options.pageSize === 'number') &&\r\n        (typeof options.regex === 'undefined' || typeof options.regex === 'string' || options.regex instanceof RegExp) &&\r\n        (typeof options.boost === 'undefined' || (typeof options.boost === 'object' && options.boost !== null))\r\n    );\r\n}\r\n\r\nexport function isIndexConfig(obj: unknown): obj is IndexConfig {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const config = obj as Partial<IndexConfig>;\r\n    \r\n    return Boolean(\r\n        typeof config.name === 'string' &&\r\n        typeof config.version === 'number' &&\r\n        Array.isArray(config.fields)\r\n    );\r\n}\r\n\r\nexport function isSearchResult<T>(obj: unknown): obj is SearchResult<T> {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const result = obj as Partial<SearchResult<T>>;\r\n    \r\n    return Boolean(\r\n        'id' in result &&\r\n        'item' in result &&\r\n        'document' in result &&\r\n        typeof result.score === 'number' &&\r\n        Array.isArray(result.matches)\r\n    );\r\n}\r\n\r\n// Global type declaration\r\ndeclare global {\r\n    interface Window {\r\n        NexusSearch: typeof NexusSearchNamespace;\r\n    }\r\n}\r\n\r\n\r\n// Create namespace with proper type definition\r\nconst NexusSearchNamespace = {\r\n    DEFAULT_INDEX_OPTIONS,\r\n    DEFAULT_SEARCH_OPTIONS,\r\n    SearchError,\r\n    IndexError,\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    isSearchOptions,\r\n    isIndexConfig,\r\n    isSearchResult,\r\n} as const;\r\n\r\n// Export individual components\r\nexport {\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    DataMapper,\r\n    IndexMapper,\r\n    CacheManager,\r\n    IndexedDB,\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n};\r\n\r\n// Browser environment check and global initialization\r\nif (typeof window !== 'undefined') {\r\n    window.NexusSearch = NexusSearchNamespace;\r\n}\r\n\r\n// Export namespace\r\nexport const NexusSearch = NexusSearchNamespace;\r\nexport default NexusSearch;","// src/constants/defaults.ts\r\nimport { SearchOptions } from '../types/search';\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n    // Basic search options\r\n    fuzzy: false,\r\n    fields: [],\r\n    boost: {}, // Empty object to satisfy Required type\r\n    maxResults: 10,\r\n    threshold: 0.5,\r\n\r\n    // Sorting and pagination\r\n    sortBy: 'score',\r\n    sortOrder: 'desc',\r\n    page: 1,\r\n    pageSize: 10,\r\n\r\n    // Advanced features\r\n    highlight: false,\r\n\r\n    // Result customization\r\n    includeMatches: false,\r\n    includeScore: false,\r\n    includeStats: false,\r\n    enableRegex: false,\r\n    maxDistance: 0,\r\n    regex: /./ // Simplified to just RegExp to fix type errors\r\n    ,\r\n    prefixMatch: false,\r\n    minScore: 0,\r\n    includePartial: false,\r\n    caseSensitive: false\r\n};\r\n\r\nexport const DEFAULT_INDEX_OPTIONS = {\r\n    fields: []\r\n};\r\n\r\n\r\n// Helper function to merge options\r\nexport function mergeSearchOptions(\r\n    options?: Partial<SearchOptions>\r\n): Required<SearchOptions> {\r\n    return {\r\n        ...DEFAULT_SEARCH_OPTIONS,\r\n        ...options,\r\n        // Ensure boost is always an object\r\n        boost: options?.boost || {}\r\n    };\r\n}\r\n\r\n// Type guard for search options\r\nexport function isValidSearchOptions(options: unknown): options is SearchOptions {\r\n    if (!options || typeof options !== 'object') return false;\r\n    const opt = options as Partial<SearchOptions>;\r\n    \r\n    return (\r\n        (opt.fuzzy === undefined || typeof opt.fuzzy === 'boolean') &&\r\n        (opt.fields === undefined || Array.isArray(opt.fields)) &&\r\n        (opt.boost === undefined || (typeof opt.boost === 'object' && opt.boost !== null)) &&\r\n        (opt.maxResults === undefined || typeof opt.maxResults === 'number') &&\r\n        (opt.threshold === undefined || typeof opt.threshold === 'number') &&\r\n        (opt.sortBy === undefined || typeof opt.sortBy === 'string') &&\r\n        (opt.sortOrder === undefined || ['asc', 'desc'].includes(opt.sortOrder)) &&\r\n        (opt.page === undefined || typeof opt.page === 'number') &&\r\n        (opt.pageSize === undefined || typeof opt.pageSize === 'number') &&\r\n        (opt.regex === undefined || typeof opt.regex === 'string' || opt.regex instanceof RegExp) &&\r\n        (opt.highlight === undefined || typeof opt.highlight === 'boolean') &&\r\n        (opt.includeMatches === undefined || typeof opt.includeMatches === 'boolean') &&\r\n        (opt.includeScore === undefined || typeof opt.includeScore === 'boolean') &&\r\n        (opt.includeStats === undefined || typeof opt.includeStats === 'boolean')\r\n    );\r\n}","import { SearchDBSchema, IndexConfig, MetadataEntry } from \"@/types\";\r\nimport { IDBPDatabase, openDB } from \"idb\";\r\n\r\nexport class IndexedDB {\r\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n    private readonly DB_NAME = 'nexus_search_db';\r\n    private readonly DB_VERSION = 1;\r\n    private initPromise: Promise<void> | null = null;\r\n\r\n    constructor() {\r\n        this.initPromise = this.initialize();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        if (this.db) return;\r\n\r\n        try {\r\n            this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n                upgrade(db) {\r\n                    // Handle version upgrades\r\n                    if (!db.objectStoreNames.contains('searchIndices')) {\r\n                        const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n                        indexStore.createIndex('timestamp', 'timestamp');\r\n                    }\r\n\r\n                    if (!db.objectStoreNames.contains('metadata')) {\r\n                        const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n                        metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n                    }\r\n                },\r\n                blocked() {\r\n                    console.warn('Database upgrade was blocked');\r\n                },\r\n                blocking() {\r\n                    console.warn('Current database version is blocking a newer version');\r\n                },\r\n                terminated() {\r\n                    console.error('Database connection was terminated');\r\n                }\r\n            });\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Storage initialization failed: ${message}`);\r\n        }\r\n    }\r\n\r\n    private async ensureConnection(): Promise<void> {\r\n        if (this.initPromise) {\r\n            await this.initPromise;\r\n        }\r\n\r\n        if (!this.db) {\r\n            throw new Error('Database connection not available');\r\n        }\r\n    }\r\n\r\n    async storeIndex(key: string, data: unknown): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const entry = {\r\n                id: key,\r\n                data,\r\n                timestamp: Date.now(),\r\n            };\r\n\r\n            await this.db!.put('searchIndices', entry);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to store index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async getIndex(key: string): Promise<unknown | null> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const entry = await this.db!.get('searchIndices', key);\r\n            return entry?.data ?? null;\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to retrieve index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async updateMetadata(config: IndexConfig): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const metadata: MetadataEntry = {\r\n                id: 'config',\r\n                config,\r\n                lastUpdated: Date.now()\r\n            };\r\n\r\n            await this.db!.put('metadata', metadata);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to update metadata: ${message}`);\r\n        }\r\n    }\r\n\r\n    async getMetadata(): Promise<MetadataEntry | null> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const result = await this.db!.get('metadata', 'config');\r\n            return result ?? null;\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to retrieve metadata: ${message}`);\r\n        }\r\n    }\r\n\r\n    async clearIndices(): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            await this.db!.clear('searchIndices');\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to clear indices: ${message}`);\r\n        }\r\n    }\r\n\r\n    async deleteIndex(key: string): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            await this.db!.delete('searchIndices', key);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to delete index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async close(): Promise<void> {\r\n        if (this.db) {\r\n            this.db.close();\r\n            this.db = null;\r\n        }\r\n    }\r\n}\r\n\r\nexport class SearchStorage {\r\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n    private readonly DB_NAME = 'nexus_search_db';\r\n    private readonly DB_VERSION = 1;\r\n    private initPromise: Promise<void> | null = null;\r\n\r\n    constructor() {\r\n        this.initPromise = this.initialize();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        if (this.db) return;\r\n\r\n        try {\r\n            this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n                upgrade(db) {\r\n                    if (!db.objectStoreNames.contains('searchIndices')) {\r\n                        const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n                        indexStore.createIndex('timestamp', 'timestamp');\r\n                    }\r\n\r\n                    if (!db.objectStoreNames.contains('metadata')) {\r\n                        const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n                        metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n                    }\r\n                },\r\n                blocked() {\r\n                    console.warn('Database upgrade was blocked');\r\n                },\r\n                blocking() {\r\n                    console.warn('Current database version is blocking a newer version');\r\n                },\r\n                terminated() {\r\n                    console.error('Database connection was terminated');\r\n                }\r\n            });\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Storage initialization failed: ${message}`);\r\n        }\r\n    }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n    \r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n  \r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        id: 'config', // Set id field directly\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n  \r\n      await this.db!.put('metadata', metadata); // Use metadata directly\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n  \r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const result = await this.db!.get('metadata', 'config');\r\n      return result || null; // Return `null` if `result` is `undefined`\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}\r\n","import { MetricsResult, PerformanceMetric } from \"@/types\";\r\n\r\nexport class PerformanceMonitor {\r\n    private metrics: Map<string, number[]>;\r\n\r\n    constructor() {\r\n        this.metrics = new Map();\r\n    }\r\n\r\n    async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {\r\n        const start = performance.now();\r\n        try {\r\n            return await fn();\r\n        } finally {\r\n            const duration = performance.now() - start;\r\n            this.recordMetric(name, duration);\r\n        }\r\n    }\r\n\r\n    private recordMetric(name: string, duration: number): void {\r\n        if (!this.metrics.has(name)) {\r\n            this.metrics.set(name, []);\r\n        }\r\n        this.metrics.get(name)!.push(duration);\r\n    }\r\n\r\n    getMetrics(): MetricsResult {\r\n        const results: MetricsResult = {};\r\n\r\n        this.metrics.forEach((durations, name) => {\r\n            results[name] = {\r\n                avg: this.average(durations),\r\n                min: Math.min(...durations),\r\n                max: Math.max(...durations),\r\n                count: durations.length\r\n            } as PerformanceMetric;\r\n        });\r\n\r\n        return results;\r\n    }\r\n\r\n    private average(numbers: number[]): number {\r\n        return numbers.reduce((a, b) => a + b, 0) / numbers.length;\r\n    }\r\n\r\n    clear(): void {\r\n        this.metrics.clear();\r\n    }\r\n}"],"names":["CacheManager","getSize","this","cache","size","getStatus","timestamps","Array","from","values","map","entry","timestamp","now","Date","memoryBytes","calculateMemoryUsage","maxSize","strategy","ttl","utilization","oldestEntryAge","length","Math","min","newestEntryAge","max","memoryUsage","bytes","formatted","formatBytes","totalSize","key","entries","estimateDataSize","data","accessOrder","result","matches","join","JSON","stringify","item","metadata","units","unitIndex","toFixed","constructor","ttlMinutes","initialStrategy","Map","stats","hits","misses","evictions","set","evict","lastAccessed","accessCount","updateAccessOrder","get","isExpired","delete","removeFromAccessOrder","clear","getStats","hitRate","keyToEvict","findLRUKey","findMRUKey","push","unshift","index","indexOf","splice","setStrategy","newStrategy","forEach","prune","prunedCount","analyze","totalAccesses","totalAccessCount","accessCounts","averageAccessCount","mostAccessedKeys","sort","a","b","slice","count","SearchStorage","options","type","db","memoryStorage","storageType","determineStorageType","isIndexedDBAvailable","indexedDB","_a","initialize","openDB","upgrade","createObjectStore","keyPath","createIndex","error","console","warn","storeIndex","name","put","id","getIndex","clearIndices","close","IndexedDocument","fields","versions","relations","normalizeFields","normalizeMetadata","content","normalizeContent","document","title","author","tags","isArray","version","text","indexed","lastModified","clone","parse","undefined","v","r","update","updates","updatedFields","updatedMetadata","Object","value","assign","getField","field","setField","addVersion","nextVersion","String","addRelation","relation","toObject","toJSON","toString","create","fromObject","obj","fromRawData","DataMapper","dataMap","mapData","documentId","has","Set","add","getDocuments","getDocumentById","documents","getAllKeys","keys","removeDocument","removeKey","exportState","serializedMap","importState","state","TrieNode","depth","children","isEndOfWord","documentRefs","weight","frequency","prefixCount","addChild","char","child","getChild","hasChild","incrementWeight","decrementWeight","clearChildren","shouldPrune","getScore","recency","exp","TrieSearch","maxWordLength","root","documentLinks","totalDocuments","addDocument","indexText","words","tokenize","word","insertWord","current","searchWord","term","search","query","fuzzy","maxDistance","prefixMatch","maxResults","minScore","caseSensitive","results","fuzzySearch","prefixSearch","exactSearch","match","existing","docId","score","filter","calculateScore","prefix","collectWords","serializeState","trie","serializeTrie","deserializeState","deserializeTrie","node","serializedNode","addData","links","ranks","Error","currentWord","searchState","fuzzySearchRecursive","currentDistance","distance","calculateLevenshteinDistance","calculateFuzzyScore","substitutionCost","tfIdf","log","positionBoost","lengthNorm","sqrt","s1","s2","dp","fill","i","j","toLowerCase","split","removeDocumentRefs","pruneEmptyNodes","getSuggestions","suggestions","collectSuggestions","suggestion","IndexMapper","dataMapper","trieSearch","documentScores","indexDocument","textValue","normalizeValue","tokenizeText","doc","searchTerms","replace","calculateTermFrequency","regex","RegExp","updateDocument","getAllDocuments","newDataMapper","createRegexPattern","pattern","wholeWord","flags","global","source","calculateRegexMatchScore","matched","baseScore","reduce","sum","findMatchPositions","positions","globalRegex","exec","createSearchableFields","acc","getNestedValue","normalizeFieldValue","trim","Boolean","path","parseInt","isNaN","sortObjectKeys","sorted","generateSortKey","validateSearchOptions","threshold","IndexManager","config","indexMapper","generateDocumentId","contentRecord","searchableDoc","getDocument","exportIndex","serializeDocument","indexState","importIndex","isValidIndexData","typedData","isValidIndexState","message","indexData","addDocuments","_b","hasDocument","QueryProcessor","STOP_WORDS","process","quoteMatch","tempQuery","quoteRegex","quote","tokens","processedTokens","processTokens","optimizeQuery","startsWith","endsWith","classifyToken","includes","token","normalizeToken","NexusDocumentAdapter","_id","_fields","_metadata","_versions","_relations","generateId","toISOString","category","created","modified","status","locale","checksum","permissions","workflow","newFields","newMetadata","defaultConfig","getDefaultConfig","versioning","enabled","maxVersions","validation","searchEngine","SearchEngine","storage","documentSupport","required","customValidators","convertToNexusDocument","validateDocument","save","random","validator","isInitialized","indexManager","queryProcessor","eventListeners","trieRoot","extractRegexMatches","searchFields","fieldContent","start","end","storageError","emitEvent","loadIndexes","normalizedDocs","normalizeDocument","validateDocuments","adaptedDoc","normalizeDate","normalizeStatus","_c","_e","_d","documentCount","date","statusStr","normalizedDoc","handleVersioning","searchStartTime","cacheKey","generateCacheKey","cachedResults","performRegexSearch","performBasicSearch","searchResults","processSearchResults","resultCount","searchTime","regexConfig","maxDepth","timeoutMs","createRegexFromOption","regexResults","isComplexRegex","visited","startTime","dfs","test","childNode","dfsRegexTraversal","queue","shift","bfsRegexTraversal","calculateTermScore","regexOption","processedResults","searchResult","normalizeScore","includeMatches","extractMatches","applyPagination","getTrieState","clearIndex","fieldBoost","boost","page","pageSize","storedIndex","indexedDocs","addEventListener","listener","removeEventListener","event","getIndexedDocumentCount","bulkUpdate","updatePromises","existingDoc","updatedDoc","Promise","all","updateCount","indexedDocuments","reindexAll","optimizeIndex","Number","normalizedFields","normalizedMetadata","restoreVersion","targetVersion","getDocumentVersion","find","indexSize","cacheSize","initialized","isReady","ValidationError","super","StorageError","CacheError","MapperError","PerformanceError","ConfigError","SearchEventError","details","CacheStrategyType","SearchError","IndexError","isSearchOptions","sortBy","sortOrder","isIndexConfig","isSearchResult","NexusSearchNamespace","DEFAULT_INDEX_OPTIONS","DEFAULT_SEARCH_OPTIONS","highlight","includeScore","includeStats","enableRegex","includePartial","window","NexusSearch","DB_NAME","DB_VERSION","initPromise","objectStoreNames","contains","blocked","blocking","terminated","ensureConnection","updateMetadata","lastUpdated","getMetadata","deleteIndex","metrics","measure","fn","performance","duration","recordMetric","getMetrics","durations","avg","average","numbers","originalSize","optimizedSize","compressionRatio","uniqueMap","localeCompare","every"],"mappings":"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"}