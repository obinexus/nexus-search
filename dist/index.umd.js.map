{"version":3,"file":"index.umd.js","sources":["../src/storage/CacheManager.ts","../src/storage/SearchStorage.ts","../src/storage/IndexedDocument.ts","../src/mappers/DataMapper.ts","../src/algorithms/trie/TrieNode.ts","../src/algorithms/trie/TrieSearch.ts","../src/mappers/IndexMapper.ts","../src/utils/SearchUtils.ts","../src/utils/ValidationUtils.ts","../src/storage/IndexManager.ts","../src/core/QueryProcessor.ts","../src/core/SearchEngine.ts","../src/types/errors.ts","../src/types/cache.ts","../src/index.ts","../src/types/defaults.ts","../src/storage/IndexedDBService.ts","../src/utils/PerformanceUtils.ts"],"sourcesContent":["import { CacheEntry, CacheStrategy, SearchResult } from \"@/types\";\r\n\r\n\r\n\r\nexport class CacheManager {\r\n    private cache: Map<string, CacheEntry>;\r\n    private readonly maxSize: number;\r\n    private readonly ttl: number;\r\n    private strategy: CacheStrategy; // Changed from readonly to private\r\n    private accessOrder: string[];\r\n    private stats: {\r\n        hits: number;\r\n        misses: number;\r\n        evictions: number;\r\n    };\r\n\r\n    constructor(\r\n        maxSize: number = 1000, \r\n        ttlMinutes: number = 5, \r\n        initialStrategy: CacheStrategy = 'LRU'\r\n    ) {\r\n        this.cache = new Map();\r\n        this.maxSize = maxSize;\r\n        this.ttl = ttlMinutes * 60 * 1000;\r\n        this.strategy = initialStrategy;\r\n        this.accessOrder = [];\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            evictions: 0\r\n        };\r\n    }\r\n\r\n    set(key: string, data: SearchResult<unknown>[]): void {\r\n        if (this.cache.size >= this.maxSize) {\r\n            this.evict();\r\n        }\r\n\r\n        const entry: CacheEntry = {\r\n            data,\r\n            timestamp: Date.now(),\r\n            lastAccessed: Date.now(),\r\n            accessCount: 1\r\n        };\r\n\r\n        this.cache.set(key, entry);\r\n        this.updateAccessOrder(key);\r\n    }\r\n\r\n    get(key: string): SearchResult<unknown>[] | null {\r\n        const entry = this.cache.get(key);\r\n\r\n        if (!entry) {\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n\r\n        if (this.isExpired(entry.timestamp)) {\r\n            this.cache.delete(key);\r\n            this.removeFromAccessOrder(key);\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n\r\n        entry.lastAccessed = Date.now();\r\n        entry.accessCount++;\r\n        this.updateAccessOrder(key);\r\n        this.stats.hits++;\r\n\r\n        return entry.data;\r\n    }\r\n\r\n    clear(): void {\r\n        this.cache.clear();\r\n        this.accessOrder = [];\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            evictions: 0\r\n        };\r\n    }\r\n\r\n    getStats() {\r\n        return {\r\n            ...this.stats,\r\n            size: this.cache.size,\r\n            maxSize: this.maxSize,\r\n            hitRate: this.stats.hits / (this.stats.hits + this.stats.misses),\r\n            strategy: this.strategy\r\n        };\r\n    }\r\n\r\n    private isExpired(timestamp: number): boolean {\r\n        return Date.now() - timestamp > this.ttl;\r\n    }\r\n\r\n    private evict(): void {\r\n        const keyToEvict = this.strategy === 'LRU' \r\n            ? this.findLRUKey()\r\n            : this.findMRUKey();\r\n\r\n        if (keyToEvict) {\r\n            this.cache.delete(keyToEvict);\r\n            this.removeFromAccessOrder(keyToEvict);\r\n            this.stats.evictions++;\r\n        }\r\n    }\r\n\r\n    private findLRUKey(): string | null {\r\n        return this.accessOrder[0] || null;\r\n    }\r\n\r\n    private findMRUKey(): string | null {\r\n        return this.accessOrder[this.accessOrder.length - 1] || null;\r\n    }\r\n\r\n    private updateAccessOrder(key: string): void {\r\n        this.removeFromAccessOrder(key);\r\n\r\n        if (this.strategy === 'LRU') {\r\n            this.accessOrder.push(key); // Most recently used at end\r\n        } else {\r\n            this.accessOrder.unshift(key); // Most recently used at start\r\n        }\r\n    }\r\n\r\n    private removeFromAccessOrder(key: string): void {\r\n        const index = this.accessOrder.indexOf(key);\r\n        if (index !== -1) {\r\n            this.accessOrder.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    setStrategy(newStrategy: CacheStrategy): void {\r\n        if (newStrategy === this.strategy) return;\r\n        \r\n        this.strategy = newStrategy;\r\n        const entries = [...this.accessOrder];\r\n        this.accessOrder = [];\r\n        entries.forEach(key => this.updateAccessOrder(key));\r\n    }\r\n\r\n    prune(): number {\r\n        let prunedCount = 0;\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            if (this.isExpired(entry.timestamp)) {\r\n                this.cache.delete(key);\r\n                this.removeFromAccessOrder(key);\r\n                prunedCount++;\r\n            }\r\n        }\r\n        return prunedCount;\r\n    }\r\n\r\n    analyze(): {\r\n        hitRate: number;\r\n        averageAccessCount: number;\r\n        mostAccessedKeys: Array<{ key: string; count: number }>;\r\n    } {\r\n        const totalAccesses = this.stats.hits + this.stats.misses;\r\n        const hitRate = totalAccesses > 0 ? this.stats.hits / totalAccesses : 0;\r\n\r\n        let totalAccessCount = 0;\r\n        const accessCounts = new Map<string, number>();\r\n\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            totalAccessCount += entry.accessCount;\r\n            accessCounts.set(key, entry.accessCount);\r\n        }\r\n\r\n        const averageAccessCount = this.cache.size > 0 \r\n            ? totalAccessCount / this.cache.size \r\n            : 0;\r\n\r\n        const mostAccessedKeys = Array.from(accessCounts.entries())\r\n            .sort((a, b) => b[1] - a[1])\r\n            .slice(0, 5)\r\n            .map(([key, count]) => ({ key, count }));\r\n\r\n        return {\r\n            hitRate,\r\n            averageAccessCount,\r\n            mostAccessedKeys\r\n        };\r\n    }\r\n}","import { openDB, IDBPDatabase } from 'idb';\nimport type { SearchDBSchema, StorageOptions } from '@/types';\n\nexport class SearchStorage {\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\n    private memoryStorage: Map<string, unknown> = new Map();\n    private storageType: 'indexeddb' | 'memory';\n    \n    constructor(options: StorageOptions = {\n        type: 'memory'\n    }) {\n        this.storageType = this.determineStorageType(options);\n    }\n\n    private determineStorageType(options: StorageOptions): 'indexeddb' | 'memory' {\n        // Use memory storage if explicitly specified or if in Node.js environment\n        if (options.type === 'memory' || !this.isIndexedDBAvailable()) {\n            return 'memory';\n        }\n        return 'indexeddb';\n    }\n\n    private isIndexedDBAvailable(): boolean {\n        try {\n            return typeof indexedDB !== 'undefined' && indexedDB !== null;\n        } catch {\n            return false;\n        }\n    }\n\n    async initialize(): Promise<void> {\n        if (this.storageType === 'memory') {\n            // No initialization needed for memory storage\n            return;\n        }\n\n        try {\n            this.db = await openDB<SearchDBSchema>('nexus-search-db', 1, {\n                upgrade(db) {\n                    const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\n                    indexStore.createIndex('timestamp', 'timestamp');\n\n                    const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\n                    metaStore.createIndex('lastUpdated', 'lastUpdated');\n                }\n            });\n        } catch (error) {\n            // Fallback to memory storage if IndexedDB fails\n            this.storageType = 'memory';\n            console.warn('Failed to initialize IndexedDB, falling back to memory storage:', error);\n        }\n    }\n\n    async storeIndex(name: string, data: unknown): Promise<void> {\n        if (this.storageType === 'memory') {\n            this.memoryStorage.set(name, data);\n            return;\n        }\n\n        try {\n            await this.db?.put('searchIndices', {\n                id: name,\n                data,\n                timestamp: Date.now()\n            });\n        } catch (error) {\n            console.error('Storage error:', error);\n            // Fallback to memory storage\n            this.memoryStorage.set(name, data);\n        }\n    }\n\n    async getIndex(name: string): Promise<unknown> {\n        if (this.storageType === 'memory') {\n            return this.memoryStorage.get(name);\n        }\n\n        try {\n            const entry = await this.db?.get('searchIndices', name);\n            return entry?.data;\n        } catch (error) {\n            console.error('Retrieval error:', error);\n            // Fallback to memory storage\n            return this.memoryStorage.get(name);\n        }\n    }\n\n    async clearIndices(): Promise<void> {\n        if (this.storageType === 'memory') {\n            this.memoryStorage.clear();\n            return;\n        }\n\n        try {\n            await this.db?.clear('searchIndices');\n        } catch (error) {\n            console.error('Clear error:', error);\n            this.memoryStorage.clear();\n        }\n    }\n\n    async close(): Promise<void> {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n        }\n        this.memoryStorage.clear();\n    }\n}","import { IndexedDocument as IIndexedDocument, DocumentMetadata } from \"@/types\";\r\n\r\nexport class IndexedDocument implements IIndexedDocument {\r\n    id: string;\r\n    fields: {\r\n        title: string;\r\n        content: string;\r\n        author: string;\r\n        tags: string[];\r\n    };\r\n    metadata?: DocumentMetadata;\r\n\r\n    constructor(\r\n        id: string,\r\n        fields: {\r\n            title: string;\r\n            content: string;\r\n            author: string;\r\n            tags: string[];\r\n        },\r\n        metadata?: DocumentMetadata\r\n    ) {\r\n        this.id = id;\r\n        this.fields = fields;\r\n        this.metadata = metadata;\r\n    }\r\n\r\n    static fromObject(obj: IIndexedDocument): IndexedDocument {\r\n        return new IndexedDocument(obj.id, obj.fields, obj.metadata);\r\n    }\r\n\r\n    toObject(): IIndexedDocument {\r\n        return {\r\n            id: this.id,\r\n            fields: this.fields,\r\n            metadata: this.metadata,\r\n            toObject: this.toObject.bind(this)\r\n        };\r\n    }\r\n}","export class DataMapper {\r\n  private dataMap: Map<string, Set<string>>;\r\n\r\n  constructor() {\r\n    this.dataMap = new Map();\r\n  }\r\n\r\n  mapData(key: string, documentId: string): void {\r\n    if (!this.dataMap.has(key)) {\r\n      this.dataMap.set(key, new Set());\r\n    }\r\n    this.dataMap.get(key)!.add(documentId);\r\n  }\r\n\r\n  getDocuments(key: string): Set<string> {\r\n    return this.dataMap.get(key) || new Set();\r\n  }\r\n\r\n  getAllKeys(): string[] {\r\n    return Array.from(this.dataMap.keys());\r\n  }\r\n\r\n  removeDocument(documentId: string): void {\r\n    this.dataMap.forEach(value => {\r\n      value.delete(documentId);\r\n    });\r\n  }\r\n\r\n  removeKey(key: string): void {\r\n    this.dataMap.delete(key);\r\n  }\r\n  \r\n  exportState(): Record<string, string[]> {\r\n    const serializedMap: Record<string, string[]> = {};\r\n    \r\n    this.dataMap.forEach((value, key) => {\r\n      serializedMap[key] = Array.from(value);\r\n    });\r\n\r\n    return serializedMap;\r\n  }\r\n\r\n  importState(state: Record<string, string[]>): void {\r\n    this.dataMap.clear();\r\n    \r\n    Object.entries(state).forEach(([key, value]) => {\r\n      this.dataMap.set(key, new Set(value));\r\n    });\r\n  }\r\n\r\n  clear(): void {\r\n    this.dataMap.clear();\r\n  }\r\n}","export class TrieNode {\r\n  children: Map<string, TrieNode>;\r\n  isEndOfWord: boolean;\r\n  documentRefs: Set<string>;\r\n  weight: number;\r\n\r\n  constructor() {\r\n      this.children = new Map();\r\n      this.isEndOfWord = false;\r\n      this.documentRefs = new Set();\r\n      this.weight = 0.0;\r\n  }\r\n}\r\n","import {  IndexableDocument, DocumentLink, SerializedState, SerializedTrieNode } from \"@/types\";\r\nimport { TrieNode } from \"./TrieNode\";\r\n\r\nexport class TrieSearch {\r\n    private root: TrieNode;\r\n    private documents: Map<string, IndexableDocument>;\r\n    private documentLinks: Map<string, DocumentLink[]>;\r\n\r\n    constructor() {\r\n        this.root = new TrieNode();\r\n        this.documents = new Map();\r\n        this.documentLinks = new Map();\r\n    }\r\n\r\n    public insert(text: string, documentId: string): void {\r\n        if (!text || !documentId) return;\r\n\r\n        const words = text.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            let current = this.root;\r\n\r\n            for (const char of word) {\r\n                if (!current.children.has(char)) {\r\n                    current.children.set(char, new TrieNode());\r\n                }\r\n                current = current.children.get(char)!;\r\n            }\r\n\r\n            current.isEndOfWord = true;\r\n            current.documentRefs.add(documentId);\r\n            current.weight += 1.0;\r\n        }\r\n    }\r\n\r\n    public search(query: string, maxResults: number = 10): Set<string> {\r\n        if (!query) return new Set();\r\n\r\n        const results = new Set<string>();\r\n        const words = query.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            let current = this.root;\r\n            let found = true;\r\n\r\n            for (const char of word) {\r\n                if (!current.children.has(char)) {\r\n                    found = false;\r\n                    break;\r\n                }\r\n                current = current.children.get(char)!;\r\n            }\r\n\r\n            if (found && current.isEndOfWord) {\r\n                this.collectDocumentRefs(current, results, maxResults);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public remove(documentId: string): void {\r\n        for (const [, node] of this.root.children) {\r\n            this.removeHelper(documentId, node);\r\n        }\r\n\r\n        this.documents.delete(documentId);\r\n        this.documentLinks.delete(documentId);\r\n    }\r\n\r\n    private removeHelper(documentId: string, node: TrieNode): void {\r\n        if (node.documentRefs.has(documentId)) {\r\n            node.documentRefs.delete(documentId);\r\n            node.weight -= 1.0;\r\n        }\r\n\r\n        for (const [, child] of node.children) {\r\n            this.removeHelper(documentId, child);\r\n        }\r\n\r\n        if (node.children.size === 0 && node.documentRefs.size === 0 && node.weight === 0) {\r\n            node.children.clear();\r\n        }\r\n    }\r\n\r\n    public linkDocument(documentId: string, links: DocumentLink[]): void {\r\n        this.documentLinks.set(documentId, links);\r\n    }\r\n\r\n    public getDocumentLinks(documentId: string): DocumentLink[] {\r\n        return this.documentLinks.get(documentId) ?? [];\r\n    }   \r\n    public removeData(documentId: string): void {\r\n        this.remove(documentId);\r\n    }\r\n\r\n    public fuzzySearch(query: string, maxDistance: number = 2): Set<string> {\r\n        if (!query) return new Set();\r\n\r\n        const results = new Set<string>();\r\n        const words = query.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            this.fuzzySearchHelper(word, this.root, '', maxDistance, results);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    private collectDocumentRefs(node: TrieNode, results: Set<string>, maxResults: number): void {\r\n        if (node.isEndOfWord) {\r\n            for (const docId of node.documentRefs) {\r\n                if (results.size >= maxResults) return;\r\n                results.add(docId);\r\n            }\r\n        }\r\n\r\n        for (const child of node.children.values()) {\r\n            if (results.size >= maxResults) return;\r\n            this.collectDocumentRefs(child, results, maxResults);\r\n        }\r\n    }\r\n\r\n    private fuzzySearchHelper(\r\n        word: string,\r\n        node: TrieNode,\r\n        currentWord: string,\r\n        maxDistance: number,\r\n        results: Set<string>\r\n    ): void {\r\n        if (maxDistance < 0) return;\r\n\r\n        if (node.isEndOfWord) {\r\n            const distance = this.calculateLevenshteinDistance(word, currentWord);\r\n            if (distance <= maxDistance) {\r\n                node.documentRefs.forEach(id => results.add(id));\r\n            }\r\n        }\r\n\r\n        for (const [char, childNode] of node.children) {\r\n            const newDistance = word[currentWord.length] !== char ? maxDistance - 1 : maxDistance;\r\n            this.fuzzySearchHelper(word, childNode, currentWord + char, newDistance, results);\r\n\r\n            if (maxDistance > 0) {\r\n                this.fuzzySearchHelper(word, childNode, currentWord, maxDistance - 1, results);\r\n            }\r\n        }\r\n    }\r\n\r\n    private calculateLevenshteinDistance(s1: string, s2: string): number {\r\n        const dp: number[][] = Array(s1.length + 1).fill(0)\r\n            .map(() => Array(s2.length + 1).fill(0));\r\n\r\n        for (let i = 0; i <= s1.length; i++) dp[i][0] = i;\r\n        for (let j = 0; j <= s2.length; j++) dp[0][j] = j;\r\n\r\n        for (let i = 1; i <= s1.length; i++) {\r\n            for (let j = 1; j <= s2.length; j++) {\r\n                dp[i][j] = Math.min(\r\n                    dp[i - 1][j] + 1,\r\n                    dp[i][j - 1] + 1,\r\n                    dp[i - 1][j - 1] + (s1[i - 1] !== s2[j - 1] ? 1 : 0)\r\n                );\r\n            }\r\n        }\r\n\r\n        return dp[s1.length][s2.length];\r\n    }\r\n\r\n    public exportState(): SerializedState {\r\n        return {\r\n            trie: this.serializeNode(this.root),\r\n            documents: Array.from(this.documents.entries()),\r\n            documentLinks: Array.from(this.documentLinks.entries())\r\n        };\r\n    }\r\n\r\n    public importState(state: SerializedState): void {\r\n        this.root = this.deserializeNode(state.trie);\r\n        this.documents = new Map(state.documents);\r\n        this.documentLinks = new Map(state.documentLinks);\r\n    }\r\n\r\n    private serializeNode(node: TrieNode): SerializedTrieNode {\r\n        const children: { [key: string]: SerializedTrieNode } = {};\r\n\r\n        node.children.forEach((childNode, char) => {\r\n            children[char] = this.serializeNode(childNode);\r\n        });\r\n\r\n        return {\r\n            isEndOfWord: node.isEndOfWord,\r\n            documentRefs: Array.from(node.documentRefs),\r\n            weight: node.weight,\r\n            children\r\n        };\r\n    }\r\n\r\n    private deserializeNode(serialized: SerializedTrieNode): TrieNode {\r\n        const node = new TrieNode();\r\n        node.isEndOfWord = serialized.isEndOfWord;\r\n        node.documentRefs = new Set(serialized.documentRefs);\r\n        node.weight = serialized.weight ?? 0;\r\n\r\n        Object.entries(serialized.children).forEach(([char, childData]) => {\r\n            node.children.set(char, this.deserializeNode(childData));\r\n        });\r\n\r\n        return node;\r\n    }\r\n\r\n    public clear(): void {\r\n        this.root = new TrieNode();\r\n        this.documents.clear();\r\n        this.documentLinks.clear();\r\n    }\r\n\r\n    public getSize(): number {\r\n        return this.documents.size;\r\n    }\r\n}","import { TrieSearch } from \"@/algorithms/trie\";\r\nimport {  SearchableDocument, SearchResult, SerializedState } from \"@/types\";\r\nimport { DataMapper } from \"./DataMapper\";\r\n\r\n\r\n/**\r\n * IndexMapper class\r\n * @description IndexMapper class that indexes documents and performs search operations\r\n * @class IndexMapper\r\n * @implements {IndexMapper}\r\n * @method indexDocument\r\n * @method search\r\n * \r\n */\r\nexport class IndexMapper {\r\n  private dataMapper: DataMapper;\r\n  private trieSearch: TrieSearch;\r\n\r\n  constructor() {\r\n    this.dataMapper = new DataMapper();\r\n    this.trieSearch = new TrieSearch();\r\n  }\r\n\r\n  indexDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n    fields.forEach(field => {\r\n        const value = document[field];\r\n        if (typeof value === 'string') {\r\n            const words = this.tokenizeText(value);\r\n            words.forEach(word => {\r\n                this.trieSearch.insert(word, id);\r\n                this.dataMapper.mapData(word.toLowerCase(), id);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n  search(query: string, options: { fuzzy?: boolean; maxResults?: number } = {}): SearchResult<string>[] {\r\n    const { fuzzy = false, maxResults = 10 } = options;\r\n    const searchTerms = this.tokenizeText(query);\r\n    \r\n    const documentScores = new Map<string, { score: number; matches: Set<string> }>();\r\n\r\n    searchTerms.forEach(term => {\r\n      const documentIds = fuzzy\r\n        ? this.trieSearch.fuzzySearch(term)\r\n        : this.trieSearch.search(term, maxResults);\r\n\r\n      documentIds.forEach(id => {\r\n        const current = documentScores.get(id) || { score: 0, matches: new Set<string>() };\r\n        current.score += this.calculateScore(id, term);\r\n        current.matches.add(term);\r\n        documentScores.set(id, current);\r\n      });\r\n    });\r\n\r\n    const results = Array.from(documentScores.entries())\r\n      .map(([id, { score, matches }]) => ({\r\n        id: id,\r\n        document: id,\r\n        item: id,\r\n        score: score / searchTerms.length,\r\n        matches: Array.from(matches)\r\n      }))\r\n      .sort((a, b) => b.score - a.score);\r\n\r\n    return results.slice(0, maxResults);\r\n  }\r\n\r\n  exportState(): unknown {\r\n    return {\r\n      trie: this.trieSearch.exportState(),\r\n      dataMap: this.dataMapper.exportState()\r\n    };\r\n  }\r\n\r\n  importState(state: { trie: SerializedState; dataMap: Record<string, string[]> }): void {\r\n    if (!state || !state.trie || !state.dataMap) {\r\n        throw new Error('Invalid index state');\r\n    }\r\n\r\n    this.trieSearch = new TrieSearch();\r\n    this.trieSearch.importState(state.trie );\r\n    this.dataMapper = new DataMapper();\r\n    this.dataMapper.importState(state.dataMap);\r\n}\r\n\r\n\r\n  private tokenizeText(text: string): string[] {\r\n    return text\r\n      .toLowerCase()\r\n      .replace(/[^\\w\\s]/g, ' ')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 0);\r\n  }\r\n\r\n\r\n  private calculateScore(documentId: string, term: string): number {\r\n    const baseScore = this.dataMapper.getDocuments(term.toLowerCase()).has(documentId) ? 1.0 : 0.5;\r\n    return baseScore\r\n  \r\n  }\r\n  removeDocument(id: string): void {\r\n    this.trieSearch.remove(id);\r\n    this.dataMapper.removeDocument(id);\r\n  }\r\n\r\n\r\n  \r\n  addDocument(id: string, fields: string[], document: SearchableDocument): void {\r\n    this.indexDocument(document, id, fields);\r\n  }\r\n\r\n  updateDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n    this.removeDocument(id);\r\n    this.indexDocument(document, id, fields);\r\n  }\r\n\r\n  clear(): void {\r\n    this.trieSearch = new TrieSearch();\r\n    this.dataMapper = new DataMapper();\r\n  }\r\n}\r\n","import { DocumentValue, IndexableDocument, OptimizationResult, SearchableDocument } from \"@/types\";\r\n\r\ntype DocumentContent = {\r\n    [key: string]: DocumentValue | DocumentContent;\r\n};\r\n\r\n/**\r\n * Creates searchable fields from a document based on specified field paths.\r\n * Handles nested paths and various value types.\r\n */\r\nexport function createSearchableFields(\r\n    document: SearchableDocument,\r\n    fields: string[]\r\n): Record<string, string> {\r\n    if (!document || !document.content || !Array.isArray(fields)) {\r\n        return {};\r\n    }\r\n\r\n    const searchableFields: Record<string, string> = {};\r\n    \r\n    for (const field of fields) {\r\n        try {\r\n            const value = getNestedValue(document.content, field);\r\n            if (value !== undefined) {\r\n                searchableFields[field] = normalizeFieldValue(value);\r\n            }\r\n        } catch (error) {\r\n            console.warn(`Error processing field ${field}:`, error);\r\n        }\r\n    }\r\n\r\n    return searchableFields;\r\n}\r\n\r\n/**\r\n * Normalizes field values into searchable strings.\r\n * Handles various data types and nested structures.\r\n */\r\nexport function normalizeFieldValue(value: DocumentValue): string {\r\n    try {\r\n        if (value === null || value === undefined) {\r\n            return '';\r\n        }\r\n\r\n        if (typeof value === 'string') {\r\n            return value.toLowerCase().trim();\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n            return value\r\n                .map(v => normalizeFieldValue(v))\r\n                .filter(Boolean)\r\n                .join(' ');\r\n        }\r\n\r\n        if (typeof value === 'object') {\r\n            return Object.values(value)\r\n                .map(v => normalizeFieldValue(v))\r\n                .filter(Boolean)\r\n                .join(' ');\r\n        }\r\n\r\n        return String(value).toLowerCase().trim();\r\n    } catch (error) {\r\n        console.warn('Error normalizing field value:', error);\r\n        return '';\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieves a nested value from an object using dot notation path.\r\n * Handles arrays and nested objects safely.\r\n */\r\nexport function getNestedValue(\r\n    obj: DocumentContent,\r\n    path: string\r\n): DocumentValue | undefined {\r\n    if (!obj || !path) {\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        const keys = path.split('.');\r\n        let current: DocumentValue | DocumentContent = obj;\r\n\r\n        for (const key of keys) {\r\n            if (!current || typeof current !== 'object') {\r\n                return undefined;\r\n            }\r\n\r\n            if (Array.isArray(current)) {\r\n                // Handle array indexing\r\n                const index = parseInt(key, 10);\r\n                if (isNaN(index)) {\r\n                    return undefined;\r\n                }\r\n                current = current[index];\r\n            } else {\r\n                current = current[key];\r\n            }\r\n        }\r\n\r\n        return current as DocumentValue;\r\n    } catch (error) {\r\n        console.warn(`Error getting nested value for path ${path}:`, error);\r\n        return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Optimizes an array of indexable documents by removing duplicates \r\n * and sorting them efficiently.\r\n * \r\n * @template T - The type of the indexable document.\r\n * @param {T[]} data - Array of indexable documents to optimize.\r\n * @returns {OptimizationResult<T>} Optimized data and optimization statistics.\r\n */\r\nexport function optimizeIndex<T extends IndexableDocument>(\r\n    data: T[]\r\n): OptimizationResult<T> {\r\n    if (!Array.isArray(data)) {\r\n        return {\r\n            data: [],\r\n            stats: {\r\n                originalSize: 0,\r\n                optimizedSize: 0,\r\n                compressionRatio: 1\r\n            }\r\n        };\r\n    }\r\n\r\n    try {\r\n        // Use Map for more efficient duplicate removal\r\n        const uniqueMap = new Map<string, T>();\r\n        \r\n        for (const item of data) {\r\n            const key = JSON.stringify(sortObjectKeys(item));\r\n            uniqueMap.set(key, item);\r\n        }\r\n\r\n        const sorted = Array.from(uniqueMap.values()).sort((a, b) => {\r\n            const aKey = generateSortKey(a);\r\n            const bKey = generateSortKey(b);\r\n            return aKey.localeCompare(bKey);\r\n        });\r\n\r\n        return {\r\n            data: sorted,\r\n            stats: {\r\n                originalSize: data.length,\r\n                optimizedSize: sorted.length,\r\n                compressionRatio: data.length ? sorted.length / data.length : 1\r\n            }\r\n        };\r\n    } catch (error) {\r\n        console.warn('Error optimizing index:', error);\r\n        return {\r\n            data: [...data],\r\n            stats: {\r\n                originalSize: data.length,\r\n                optimizedSize: data.length,\r\n                compressionRatio: 1\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to sort object keys recursively for consistent serialization.\r\n */\r\nexport function sortObjectKeys<T extends object>(obj: T): T {\r\n    if (Array.isArray(obj)) {\r\n        return obj.map(sortObjectKeys) as unknown as T;\r\n    }\r\n    \r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    return Object.keys(obj)\r\n        .sort()\r\n        .reduce((sorted, key) => {\r\n            (sorted as any)[key] = sortObjectKeys((obj as any)[key]);\r\n            return sorted;\r\n        }, {} as T);\r\n}\r\n\r\n/**\r\n * Helper function to generate consistent sort keys for documents.\r\n */\r\nexport function generateSortKey(doc: IndexableDocument): string {\r\n    if (!doc.id || !doc.content) {\r\n        return '';\r\n    }\r\n\r\n    try {\r\n        return `${doc.id}:${Object.keys(doc.content).sort().join(',')}`;\r\n    } catch {\r\n        return doc.id;\r\n    }\r\n}\r\n\r\n/**\r\n * Create a document that can be indexed\r\n * @param {Object} params Document parameters\r\n * @param {string} params.id Document ID\r\n * @param {Object} params.fields Document fields\r\n * @param {Object} [params.metadata] Optional metadata\r\n * @returns {Object} Indexed document\r\n */\r\nexport function createDocument({ id, fields, metadata = {} }: { id: string; fields: Record<string, any>; metadata?: Record<string, any> }) {\r\n    return {\r\n        id,\r\n        fields,\r\n        metadata: {\r\n            indexed: Date.now(),\r\n            lastModified: Date.now(),\r\n            ...metadata\r\n        }\r\n    };\r\n}\r\n","import { SearchOptions, IndexConfig, SearchableDocument } from \"@/types\";\r\nimport { getNestedValue } from \"./SearchUtils\";\r\n\r\nexport function validateSearchOptions(options: SearchOptions): void {\r\n    if (options.maxResults && options.maxResults < 1) {\r\n        throw new Error('maxResults must be greater than 0');\r\n    }\r\n    if (options.threshold && (options.threshold < 0 || options.threshold > 1)) {\r\n        throw new Error('threshold must be between 0 and 1');\r\n    }\r\n    if (options.fields && !Array.isArray(options.fields)) {\r\n        throw new Error('fields must be an array');\r\n    }\r\n}\r\n\r\nexport function validateIndexConfig(config: IndexConfig): void {\r\n    if (!config.name) {\r\n        throw new Error('Index name is required');\r\n    }\r\n    if (!config.version || typeof config.version !== 'number') {\r\n        throw new Error('Valid version number is required');\r\n    }\r\n    if (!Array.isArray(config.fields) || config.fields.length === 0) {\r\n        throw new Error('At least one field must be specified for indexing');\r\n    }\r\n}\r\n\r\nexport function validateDocument(document: SearchableDocument, fields: string[]): boolean {\r\n    return fields.every(field => {\r\n        const value = getNestedValue(document.content, field);\r\n        return value !== undefined;\r\n    });\r\n}","import { IndexMapper } from \"@/mappers\";\r\nimport { \r\n    IndexConfig, \r\n    SearchOptions, \r\n    SearchResult, \r\n    IndexedDocument, \r\n    SearchableDocument, \r\n    SerializedState,\r\n    DocumentValue \r\n} from \"@/types\";\r\nimport { SerializedIndex } from \"@/types/core\";\r\nimport { createSearchableFields } from \"@/utils\";\r\n\r\nexport class IndexManager {\r\n    getAllDocuments() {\r\n        return this.documents;\r\n        \r\n    }\r\n    private indexMapper: IndexMapper;\r\n    private config: IndexConfig;\r\n    private documents: Map<string, IndexedDocument>;\r\n\r\n    constructor(config: IndexConfig) {\r\n        this.config = config;\r\n        this.indexMapper = new IndexMapper();\r\n        this.documents = new Map();\r\n    }\r\n\r\n    async addDocuments<T extends IndexedDocument>(documents: T[]): Promise<void> {\r\n        for (const [index, doc] of documents.entries()) {\r\n            const id = this.generateDocumentId(index);\r\n\r\n            // Convert document fields to Record<string, DocumentValue>\r\n            const contentRecord: Record<string, DocumentValue> = {};\r\n            for (const field of this.config.fields) {\r\n                if (field in doc) {\r\n                    if (field in doc) {\r\n                        contentRecord[field] = (doc as any)[field] as DocumentValue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Create searchable document with proper field extraction\r\n            const searchableDoc: SearchableDocument = {\r\n                id,\r\n                content: createSearchableFields({\r\n                    content: contentRecord,\r\n                    id\r\n                }, this.config.fields),\r\n                metadata: doc.metadata\r\n            };\r\n\r\n            // Store original document with ID\r\n            this.documents.set(id, { ...doc, id });\r\n\r\n            // Index the document\r\n            try {\r\n                await this.indexMapper.indexDocument(searchableDoc, id, this.config.fields);\r\n            } catch (error) {\r\n                console.warn(`Failed to index document ${id}:`, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    async search<T extends IndexedDocument>(\r\n        query: string, \r\n        options: SearchOptions = {}\r\n    ): Promise<SearchResult<T>[]> {\r\n        if (!query.trim()) return [];\r\n\r\n        try {\r\n            const searchResults = await this.indexMapper.search(query, {\r\n                fuzzy: options.fuzzy ?? false,\r\n                maxResults: options.maxResults ?? 10\r\n            });\r\n\r\n            return searchResults\r\n                .filter(result => this.documents.has(result.item))\r\n                .map(result => {\r\n                    const item = this.documents.get(result.item) as T;\r\n                    return {\r\n                        id: item.id,\r\n                        document: item,\r\n                        metadata: item.metadata,\r\n                        item,\r\n                        score: result.score,\r\n                        matches: result.matches\r\n                    };\r\n                })\r\n                .filter(result => result.score >= (options.threshold ?? 0.5));\r\n\r\n        } catch (error) {\r\n            console.error('Search error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    exportIndex(): SerializedIndex {\r\n        return {\r\n            documents: Array.from(this.documents.entries()).map(([key, value]) => ({\r\n                key,\r\n                value: this.serializeDocument(value)\r\n            })),\r\n            indexState: this.indexMapper.exportState(),\r\n            config: this.config\r\n        };\r\n    }\r\n\r\n    importIndex(data: unknown): void {\r\n        if (!this.isValidIndexData(data)) {\r\n            throw new Error('Invalid index data format');\r\n        }\r\n\r\n        try {\r\n            const typedData = data as SerializedIndex;\r\n            this.documents = new Map(\r\n                typedData.documents.map(item => [item.key, item.value])\r\n            );\r\n            this.config = typedData.config;\r\n            this.indexMapper = new IndexMapper();\r\n            \r\n            if (this.isValidIndexState(typedData.indexState)) {\r\n                this.indexMapper.importState({\r\n                    trie: typedData.indexState.trie,\r\n                    dataMap: typedData.indexState.dataMap\r\n                });\r\n            } else {\r\n                throw new Error('Invalid index state format');\r\n            }\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to import index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async removeDocument(documentId: string): Promise<void> {\r\n        if (this.documents.has(documentId)) {\r\n            this.documents.delete(documentId);\r\n            await this.indexMapper.removeDocument(documentId);\r\n        }\r\n    }\r\n\r\n    async updateDocument<T extends IndexedDocument>(document: T): Promise<void> {\r\n        const id = document.id;\r\n        if (this.documents.has(id)) {\r\n            this.documents.set(id, document);\r\n            const contentRecord: Record<string, DocumentValue> = {};\r\n            for (const field of this.config.fields) {\r\n                if (field in document) {\r\n                    if (field in document) {\r\n                        contentRecord[field] = (document as any)[field] as DocumentValue;\r\n                    }\r\n                }\r\n            }\r\n            const searchableDoc: SearchableDocument = {\r\n                id,\r\n                content: createSearchableFields({\r\n                    content: contentRecord,\r\n                    id\r\n                }, this.config.fields),\r\n                metadata: document.metadata\r\n            };\r\n            await this.indexMapper.updateDocument(searchableDoc, id, this.config.fields);\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        this.documents.clear();\r\n        this.indexMapper = new IndexMapper();\r\n    }\r\n\r\n    private generateDocumentId(index: number): string {\r\n        return `${this.config.name}-${index}-${Date.now()}`;\r\n    }\r\n\r\n    private isValidIndexData(data: unknown): data is SerializedIndex {\r\n        if (!data || typeof data !== 'object') return false;\r\n        \r\n        const indexData = data as Partial<SerializedIndex>;\r\n        return Boolean(\r\n            indexData.documents &&\r\n            Array.isArray(indexData.documents) &&\r\n            indexData.indexState !== undefined &&\r\n            indexData.config &&\r\n            typeof indexData.config === 'object'\r\n        );\r\n    }\r\n\r\n    private isValidIndexState(state: unknown): state is { trie: SerializedState; dataMap: Record<string, string[]> } {\r\n        return (\r\n            state !== null &&\r\n            typeof state === 'object' &&\r\n            'trie' in state &&\r\n            'dataMap' in state\r\n        );\r\n    }\r\n\r\n    private serializeDocument(doc: IndexedDocument): IndexedDocument {\r\n        return JSON.parse(JSON.stringify(doc));\r\n    }\r\n}","import { QueryToken } from \"@/types\";\r\n\r\nexport class QueryProcessor {\r\n  private readonly STOP_WORDS = new Set([\r\n      'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for',\r\n      'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on',\r\n      'that', 'the', 'to', 'was', 'were', 'will', 'with'\r\n  ]);\r\n\r\n  process(query: string | null | undefined): string {\r\n      if (query == null) return '';\r\n      if (typeof query !== 'string') return String(query);\r\n\r\n      const tokens = this.tokenize(query);\r\n      const processedTokens = this.processTokens(tokens);\r\n      return this.optimizeQuery(processedTokens);\r\n  }\r\n\r\n  private tokenize(query: string): QueryToken[] {\r\n      return query\r\n          .toLowerCase()\r\n          .split(/\\s+/)\r\n          .filter(term => term.length > 0)\r\n          .map(term => this.classifyToken(term));\r\n  }\r\n\r\n  private classifyToken(term: string): QueryToken {\r\n      if (term.startsWith('+') || term.startsWith('-')) {\r\n          return { type: 'operator', value: term };\r\n      }\r\n      if (term.includes(':')) {\r\n          return { type: 'modifier', value: term };\r\n      }\r\n      return { type: 'term', value: term };\r\n  }\r\n\r\n  private processTokens(tokens: QueryToken[]): QueryToken[] {\r\n      return tokens\r\n          .filter(token =>\r\n              token.type !== 'term' || !this.STOP_WORDS.has(token.value)\r\n          )\r\n          .map(token => this.normalizeToken(token));\r\n  }\r\n\r\n  private normalizeToken(token: QueryToken): QueryToken {\r\n      if (token.type === 'term') {\r\n          let value = token.value;\r\n          if (value.endsWith('ing')) value = value.slice(0, -3);\r\n          if (value.endsWith('ed')) value = value.slice(0, -2);\r\n          if (value.endsWith('s') && !value.endsWith('ss')) value = value.slice(0, -1);\r\n          return { ...token, value };\r\n      }\r\n      return token;\r\n  }\r\n\r\n  private optimizeQuery(tokens: QueryToken[]): string {\r\n      return tokens\r\n          .map(token => token.value)\r\n          .join(' ');\r\n  }\r\n}\r\n","import { CacheManager, IndexedDocument, SearchStorage } from \"@/storage\";\r\nimport { \r\n    SearchOptions, \r\n    SearchResult, \r\n    SearchEngineConfig,\r\n    SearchEventListener,\r\n    SearchEvent,\r\n} from \"@/types\";\r\nimport { validateSearchOptions, createSearchableFields } from \"@/utils\";\r\nimport { IndexManager } from \"../storage/IndexManager\";\r\nimport { QueryProcessor } from \"./QueryProcessor\";\r\nimport { TrieSearch } from \"@/algorithms/trie\";\r\n\r\nexport class SearchEngine {\r\n    private readonly indexManager: IndexManager;\r\n    private readonly queryProcessor: QueryProcessor;\r\n    private storage: SearchStorage;\r\n    private readonly cache: CacheManager;\r\n    private readonly config: SearchEngineConfig;\r\n    private readonly eventListeners: Set<SearchEventListener>;\r\n    private trie: TrieSearch;\r\n    private isInitialized: boolean = false;\r\n    private documents: Map<string, IndexedDocument>;\r\n\r\n    constructor(config: SearchEngineConfig) {\r\n        this.config = config;\r\n        this.indexManager = new IndexManager(config);\r\n        this.queryProcessor = new QueryProcessor();\r\n        this.storage = new SearchStorage(config.storage);\r\n        this.cache = new CacheManager();\r\n        this.eventListeners = new Set();\r\n        this.trie = new TrieSearch();\r\n        this.documents = new Map();\r\n    }\r\n\r\n    public async initialize(): Promise<void> {\r\n        if (this.isInitialized) return;\r\n\r\n        try {\r\n            try {\r\n                await this.storage.initialize();\r\n            } catch (storageError) {\r\n                this.emitEvent({\r\n                    type: 'storage:error',\r\n                    timestamp: Date.now(),\r\n                    error: storageError instanceof Error ? storageError : new Error(String(storageError))\r\n                });\r\n                \r\n                this.storage = new SearchStorage({ type: 'memory' });\r\n                await this.storage.initialize();\r\n            }\r\n\r\n            await this.loadIndexes();\r\n            this.isInitialized = true;\r\n\r\n            this.emitEvent({\r\n                type: 'engine:initialized',\r\n                timestamp: Date.now()\r\n            });\r\n        } catch (error) {\r\n            throw new Error(`Failed to initialize search engine: ${String(error)}`);\r\n        }\r\n    }\r\n\r\n    public async addDocuments(documents: IndexedDocument[]): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            this.emitEvent({\r\n                type: 'index:start',\r\n                timestamp: Date.now(),\r\n                data: { documentCount: documents.length }\r\n            });\r\n\r\n            for (const doc of documents) {\r\n                const docId = doc.id || this.generateDocumentId();\r\n                const indexedDoc = IndexedDocument.fromObject({\r\n                    ...doc,\r\n                    id: docId,\r\n                    metadata: {\r\n                        ...doc.metadata,\r\n                        indexed: Date.now(),\r\n                        lastModified: Date.now()\r\n                    },\r\n                    toObject: function (): IndexedDocument {\r\n                        throw new Error(\"Function not implemented.\");\r\n                    }\r\n                });\r\n\r\n                this.documents.set(docId, indexedDoc);\r\n\r\n                const searchableContent = createSearchableFields(\r\n                    { content: doc.fields, id: docId },\r\n                    this.config.fields\r\n                );\r\n\r\n                for (const field of this.config.fields) {\r\n                    if (searchableContent[field]) {\r\n                        const words = searchableContent[field]\r\n                            .toLowerCase()\r\n                            .split(/\\s+/)\r\n                            .filter(Boolean);\r\n\r\n                        for (const word of words) {\r\n                            this.trie.insert(word, docId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            await this.indexManager.addDocuments(\r\n                Array.from(this.documents.values()).map(doc => doc.toObject())\r\n            );\r\n\r\n            try {\r\n                await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n            } catch (storageError) {\r\n                this.emitEvent({\r\n                    type: 'storage:error',\r\n                    timestamp: Date.now(),\r\n                    error: storageError instanceof Error ? storageError : new Error(String(storageError))\r\n                });\r\n            }\r\n\r\n            this.cache.clear();\r\n            this.emitEvent({\r\n                type: 'index:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentCount: documents.length }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'index:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to add documents: ${error}`);\r\n        }\r\n    }\r\n    public async search(\r\n        query: string,\r\n        options: SearchOptions = {}\r\n    ): Promise<SearchResult<IndexedDocument>[]> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        validateSearchOptions(options);\r\n\r\n        const searchStartTime = Date.now();\r\n        this.emitEvent({\r\n            type: 'search:start',\r\n            timestamp: searchStartTime,\r\n            data: { query, options }\r\n        });\r\n\r\n        const cacheKey = this.generateCacheKey(query, options);\r\n        const cachedResults = this.cache.get(cacheKey);\r\n        if (cachedResults) {\r\n            return cachedResults as SearchResult<IndexedDocument>[];\r\n        }\r\n\r\n        try {\r\n            const processedQuery = this.queryProcessor.process(query);\r\n            const results = await this.indexManager.search<IndexedDocument>(processedQuery, options);\r\n\r\n            // Enhance results with metadata\r\n            const enhancedResults = results.map(result => ({\r\n                ...result,\r\n                document: this.documents.get(result.id as unknown as string)?.toObject() || result.document,\r\n                metadata: {\r\n                    ...result.metadata,\r\n                    lastAccessed: Date.now()\r\n                }\r\n            }));\r\n\r\n            this.cache.set(cacheKey, enhancedResults);\r\n\r\n            this.emitEvent({\r\n                type: 'search:complete',\r\n                timestamp: Date.now(),\r\n                data: {\r\n                    query,\r\n                    options,\r\n                    resultCount: enhancedResults.length,\r\n                    searchTime: Date.now() - searchStartTime\r\n                }\r\n            });\r\n\r\n            return enhancedResults;\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'search:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Search failed: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async updateDocument(document: IndexedDocument): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        const documentId = document.id;\r\n        if (!documentId || !this.documents.has(documentId)) {\r\n            throw new Error(`Document ${documentId} not found`);\r\n        }\r\n\r\n        try {\r\n            const updatedDoc = IndexedDocument.fromObject({\r\n                ...document,\r\n                metadata: {\r\n                    ...document.metadata,\r\n                    lastModified: Date.now()\r\n                },\r\n                toObject: function (): IndexedDocument {\r\n                    throw new Error(\"Function not implemented.\");\r\n                }\r\n            });\r\n\r\n            await this.removeDocument(documentId);\r\n            await this.addDocuments([updatedDoc]);\r\n\r\n            this.emitEvent({\r\n                type: 'update:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentId }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'update:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to update document: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async removeDocument(documentId: string): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        if (!this.documents.has(documentId)) {\r\n            throw new Error(`Document ${documentId} not found`);\r\n        }\r\n\r\n        try {\r\n            this.documents.delete(documentId);\r\n            this.trie.removeData(documentId);\r\n            await this.indexManager.removeDocument(documentId);\r\n            this.cache.clear();\r\n\r\n            try {\r\n                await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n            } catch (storageError) {\r\n                this.emitEvent({\r\n                    type: 'storage:error',\r\n                    timestamp: Date.now(),\r\n                    error: storageError instanceof Error ? storageError : new Error(String(storageError))\r\n                });\r\n            }\r\n\r\n            this.emitEvent({\r\n                type: 'remove:complete',\r\n                timestamp: Date.now(),\r\n                data: { documentId }\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'remove:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to remove document: ${error}`);\r\n        }\r\n    }\r\n\r\n    public addEventListener(listener: SearchEventListener): void {\r\n        this.eventListeners.add(listener);\r\n    }\r\n\r\n    public removeEventListener(listener: SearchEventListener): void {\r\n        this.eventListeners.delete(listener);\r\n    }\r\n\r\n    private emitEvent(event: SearchEvent): void {\r\n        this.eventListeners.forEach(listener => {\r\n            try {\r\n                listener(event);\r\n            } catch (error) {\r\n                console.error('Error in event listener:', error);\r\n            }\r\n        });\r\n    }\r\n\r\n  \r\n    private async loadIndexes(): Promise<void> {\r\n        try {\r\n            const storedIndex = await this.storage.getIndex(this.config.name);\r\n            if (storedIndex) {\r\n                this.indexManager.importIndex(storedIndex);\r\n                \r\n                // Reconstruct documents from stored index\r\n                const indexedDocs = this.indexManager.getAllDocuments();\r\n                for (const doc of indexedDocs) {\r\n                    this.documents.set(doc[1].id, IndexedDocument.fromObject(doc[1]));\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.warn('Failed to load stored index, starting fresh:', error);\r\n        }\r\n    }\r\n\r\n    private generateCacheKey(query: string, options: SearchOptions): string {\r\n        return `${this.config.name}-${query}-${JSON.stringify(options)}`;\r\n    }\r\n\r\n    private generateDocumentId(): string {\r\n        return `${this.config.name}-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\r\n    }\r\n\r\n    public async clearIndex(): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            await this.storage.clearIndices();\r\n            this.documents.clear();\r\n            this.trie = new TrieSearch();\r\n            this.indexManager.clear();\r\n            this.cache.clear();\r\n\r\n            this.emitEvent({\r\n                type: 'index:clear',\r\n                timestamp: Date.now()\r\n            });\r\n        } catch (error) {\r\n            this.emitEvent({\r\n                type: 'index:clear:error',\r\n                timestamp: Date.now(),\r\n                error: error instanceof Error ? error : new Error(String(error))\r\n            });\r\n            throw new Error(`Failed to clear index: ${error}`);\r\n        }\r\n    }\r\n\r\n    public async close(): Promise<void> {\r\n        try {\r\n            await this.storage.close();\r\n            this.cache.clear();\r\n            this.documents.clear();\r\n            this.isInitialized = false;\r\n        } catch (error) {\r\n            console.warn('Error during close:', error);\r\n        }\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        return this.isInitialized;\r\n    }\r\n\r\n    public getAllDocuments(): IndexedDocument[] {\r\n        return Array.from(this.documents.values());\r\n    }\r\n\r\n    public getDocumentById(id: string): IndexedDocument | undefined {\r\n        return this.documents.get(id);\r\n    }\r\n\r\n    public getIndexedDocumentCount(): number {\r\n        return this.documents.size;\r\n    }\r\n\r\n    public getTrieState(): unknown {\r\n        return this.trie.exportState();\r\n    }\r\n}","export class SearchError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'SearchError';\r\n  }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class StorageError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'StorageError';\r\n  }\r\n}","import { SearchResult } from \"./search\";\r\n\r\nexport interface CacheOptions {\r\n    maxSize: number;\r\n    ttlMinutes: number;\r\n}\r\nexport interface CacheEntry {\r\n    data: SearchResult<unknown>[];\r\n    timestamp: number;\r\n    lastAccessed: number;\r\n    accessCount: number;\r\n}\r\n\r\n\r\n\r\nexport interface CacheOptions {\r\n    strategy: CacheStrategy;\r\n    maxSize: number;\r\n    ttlMinutes: number;\r\n}\r\n\r\nexport enum CacheStrategyType {\r\n    LRU = 'LRU',\r\n    MRU = 'MRU'\r\n  }\r\n\r\n  export type CacheStrategy = keyof typeof CacheStrategyType;\r\n  \r\n  export interface CacheStats {\r\n    hits: number;\r\n    misses: number;\r\n    evictions: number;\r\n}","/// <reference types=\"node\"/>\r\nimport type {\r\n    IndexConfig,\r\n    SearchContext,\r\n    SearchOptions,\r\n    SearchResult,\r\n    SearchStats,\r\n    SearchEventType,\r\n    SearchEvent,\r\n    DocumentLink,\r\n    DocumentRank,\r\n} from './types/index';\r\nimport { DEFAULT_SEARCH_OPTIONS , DEFAULT_INDEX_OPTIONS} from './types/defaults';\r\n// Export type declarations\r\nexport { DocumentLink, DocumentRank, SearchEvent, SearchEventType, SearchStats, SearchContext };\r\n\r\n// Core imports\r\nimport { SearchEngine } from '@core/SearchEngine';\r\nimport { IndexManager } from '@storage/IndexManager';\r\nimport { QueryProcessor } from '@core/QueryProcessor';\r\n\r\n// Algorithm imports\r\nimport { TrieNode } from '@algorithms/trie/TrieNode';\r\nimport { TrieSearch } from '@algorithms/trie/TrieSearch';\r\n\r\n// Mapper imports\r\nimport { DataMapper } from '@/mappers/DataMapper';\r\nimport { IndexMapper } from '@/mappers/IndexMapper';\r\n\r\n// Storage imports\r\nimport { CacheManager } from '@storage/CacheManager';\r\nimport { IndexedDB } from '@storage/IndexedDBService';\r\n\r\n// Utility imports\r\nimport {\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n} from '@utils/index';\r\n\r\n// Export all types\r\nexport * from './types/';\r\n\r\n\r\n// Custom error classes\r\nexport class SearchError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'SearchError';\r\n    }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'IndexError';\r\n    }\r\n}\r\n\r\n// Type guards with improved type checking\r\nexport function isSearchOptions(obj: unknown): obj is SearchOptions {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const options = obj as Partial<SearchOptions>;\r\n    \r\n    return (\r\n        (typeof options.fuzzy === 'undefined' || typeof options.fuzzy === 'boolean') &&\r\n        (typeof options.maxResults === 'undefined' || typeof options.maxResults === 'number') &&\r\n        (typeof options.threshold === 'undefined' || typeof options.threshold === 'number') &&\r\n        (typeof options.fields === 'undefined' || Array.isArray(options.fields)) &&\r\n        (typeof options.sortBy === 'undefined' || typeof options.sortBy === 'string') &&\r\n        (typeof options.sortOrder === 'undefined' || ['asc', 'desc'].includes(options.sortOrder)) &&\r\n        (typeof options.page === 'undefined' || typeof options.page === 'number') &&\r\n        (typeof options.pageSize === 'undefined' || typeof options.pageSize === 'number') &&\r\n        (typeof options.regex === 'undefined' || typeof options.regex === 'string' || options.regex instanceof RegExp) &&\r\n        (typeof options.boost === 'undefined' || (typeof options.boost === 'object' && options.boost !== null))\r\n    );\r\n}\r\n\r\nexport function isIndexConfig(obj: unknown): obj is IndexConfig {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const config = obj as Partial<IndexConfig>;\r\n    \r\n    return Boolean(\r\n        typeof config.name === 'string' &&\r\n        typeof config.version === 'number' &&\r\n        Array.isArray(config.fields)\r\n    );\r\n}\r\n\r\nexport function isSearchResult<T>(obj: unknown): obj is SearchResult<T> {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const result = obj as Partial<SearchResult<T>>;\r\n    \r\n    return Boolean(\r\n        'id' in result &&\r\n        'item' in result &&\r\n        'document' in result &&\r\n        typeof result.score === 'number' &&\r\n        Array.isArray(result.matches)\r\n    );\r\n}\r\n\r\n// Global type declaration\r\ndeclare global {\r\n    interface Window {\r\n        NexusSearch: typeof NexusSearchNamespace;\r\n    }\r\n}\r\n\r\n\r\n// Create namespace with proper type definition\r\nconst NexusSearchNamespace = {\r\n    DEFAULT_INDEX_OPTIONS,\r\n    DEFAULT_SEARCH_OPTIONS,\r\n    SearchError,\r\n    IndexError,\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    isSearchOptions,\r\n    isIndexConfig,\r\n    isSearchResult,\r\n} as const;\r\n\r\n// Export individual components\r\nexport {\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    DataMapper,\r\n    IndexMapper,\r\n    CacheManager,\r\n    IndexedDB,\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n};\r\n\r\n// Browser environment check and global initialization\r\nif (typeof window !== 'undefined') {\r\n    window.NexusSearch = NexusSearchNamespace;\r\n}\r\n\r\n// Export namespace\r\nexport const NexusSearch = NexusSearchNamespace;\r\nexport default NexusSearch;","// src/constants/defaults.ts\r\nimport { SearchOptions } from '../types/search';\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n    // Basic search options\r\n    fuzzy: false,\r\n    fields: [],\r\n    boost: {}, // Empty object to satisfy Required type\r\n    maxResults: 10,\r\n    threshold: 0.5,\r\n\r\n    // Sorting and pagination\r\n    sortBy: 'score',\r\n    sortOrder: 'desc',\r\n    page: 1,\r\n    pageSize: 10,\r\n\r\n    // Advanced features\r\n    regex: '',\r\n    highlight: false,\r\n\r\n    // Result customization\r\n    includeMatches: false,\r\n    includeScore: false,\r\n    includeStats: false\r\n};\r\n\r\nexport const DEFAULT_INDEX_OPTIONS = {\r\n    fields: []\r\n};\r\n\r\n\r\n// Helper function to merge options\r\nexport function mergeSearchOptions(\r\n    options?: Partial<SearchOptions>\r\n): Required<SearchOptions> {\r\n    return {\r\n        ...DEFAULT_SEARCH_OPTIONS,\r\n        ...options,\r\n        // Ensure boost is always an object\r\n        boost: options?.boost || {}\r\n    };\r\n}\r\n\r\n// Type guard for search options\r\nexport function isValidSearchOptions(options: unknown): options is SearchOptions {\r\n    if (!options || typeof options !== 'object') return false;\r\n    const opt = options as Partial<SearchOptions>;\r\n    \r\n    return (\r\n        (opt.fuzzy === undefined || typeof opt.fuzzy === 'boolean') &&\r\n        (opt.fields === undefined || Array.isArray(opt.fields)) &&\r\n        (opt.boost === undefined || (typeof opt.boost === 'object' && opt.boost !== null)) &&\r\n        (opt.maxResults === undefined || typeof opt.maxResults === 'number') &&\r\n        (opt.threshold === undefined || typeof opt.threshold === 'number') &&\r\n        (opt.sortBy === undefined || typeof opt.sortBy === 'string') &&\r\n        (opt.sortOrder === undefined || ['asc', 'desc'].includes(opt.sortOrder)) &&\r\n        (opt.page === undefined || typeof opt.page === 'number') &&\r\n        (opt.pageSize === undefined || typeof opt.pageSize === 'number') &&\r\n        (opt.regex === undefined || typeof opt.regex === 'string' || opt.regex instanceof RegExp) &&\r\n        (opt.highlight === undefined || typeof opt.highlight === 'boolean') &&\r\n        (opt.includeMatches === undefined || typeof opt.includeMatches === 'boolean') &&\r\n        (opt.includeScore === undefined || typeof opt.includeScore === 'boolean') &&\r\n        (opt.includeStats === undefined || typeof opt.includeStats === 'boolean')\r\n    );\r\n}","import { SearchDBSchema, IndexConfig, MetadataEntry } from \"@/types\";\r\nimport { IDBPDatabase, openDB } from \"idb\";\r\n\r\nexport class IndexedDB {\r\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n    private readonly DB_NAME = 'nexus_search_db';\r\n    private readonly DB_VERSION = 1;\r\n    private initPromise: Promise<void> | null = null;\r\n\r\n    constructor() {\r\n        this.initPromise = this.initialize();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        if (this.db) return;\r\n\r\n        try {\r\n            this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n                upgrade(db) {\r\n                    // Handle version upgrades\r\n                    if (!db.objectStoreNames.contains('searchIndices')) {\r\n                        const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n                        indexStore.createIndex('timestamp', 'timestamp');\r\n                    }\r\n\r\n                    if (!db.objectStoreNames.contains('metadata')) {\r\n                        const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n                        metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n                    }\r\n                },\r\n                blocked() {\r\n                    console.warn('Database upgrade was blocked');\r\n                },\r\n                blocking() {\r\n                    console.warn('Current database version is blocking a newer version');\r\n                },\r\n                terminated() {\r\n                    console.error('Database connection was terminated');\r\n                }\r\n            });\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Storage initialization failed: ${message}`);\r\n        }\r\n    }\r\n\r\n    private async ensureConnection(): Promise<void> {\r\n        if (this.initPromise) {\r\n            await this.initPromise;\r\n        }\r\n\r\n        if (!this.db) {\r\n            throw new Error('Database connection not available');\r\n        }\r\n    }\r\n\r\n    async storeIndex(key: string, data: unknown): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const entry = {\r\n                id: key,\r\n                data,\r\n                timestamp: Date.now(),\r\n            };\r\n\r\n            await this.db!.put('searchIndices', entry);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to store index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async getIndex(key: string): Promise<unknown | null> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const entry = await this.db!.get('searchIndices', key);\r\n            return entry?.data ?? null;\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to retrieve index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async updateMetadata(config: IndexConfig): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const metadata: MetadataEntry = {\r\n                id: 'config',\r\n                config,\r\n                lastUpdated: Date.now()\r\n            };\r\n\r\n            await this.db!.put('metadata', metadata);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to update metadata: ${message}`);\r\n        }\r\n    }\r\n\r\n    async getMetadata(): Promise<MetadataEntry | null> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            const result = await this.db!.get('metadata', 'config');\r\n            return result ?? null;\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to retrieve metadata: ${message}`);\r\n        }\r\n    }\r\n\r\n    async clearIndices(): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            await this.db!.clear('searchIndices');\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to clear indices: ${message}`);\r\n        }\r\n    }\r\n\r\n    async deleteIndex(key: string): Promise<void> {\r\n        await this.ensureConnection();\r\n\r\n        try {\r\n            await this.db!.delete('searchIndices', key);\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to delete index: ${message}`);\r\n        }\r\n    }\r\n\r\n    async close(): Promise<void> {\r\n        if (this.db) {\r\n            this.db.close();\r\n            this.db = null;\r\n        }\r\n    }\r\n}\r\n\r\nexport class SearchStorage {\r\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n    private readonly DB_NAME = 'nexus_search_db';\r\n    private readonly DB_VERSION = 1;\r\n    private initPromise: Promise<void> | null = null;\r\n\r\n    constructor() {\r\n        this.initPromise = this.initialize();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        if (this.db) return;\r\n\r\n        try {\r\n            this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n                upgrade(db) {\r\n                    if (!db.objectStoreNames.contains('searchIndices')) {\r\n                        const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n                        indexStore.createIndex('timestamp', 'timestamp');\r\n                    }\r\n\r\n                    if (!db.objectStoreNames.contains('metadata')) {\r\n                        const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n                        metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n                    }\r\n                },\r\n                blocked() {\r\n                    console.warn('Database upgrade was blocked');\r\n                },\r\n                blocking() {\r\n                    console.warn('Current database version is blocking a newer version');\r\n                },\r\n                terminated() {\r\n                    console.error('Database connection was terminated');\r\n                }\r\n            });\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Storage initialization failed: ${message}`);\r\n        }\r\n    }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n    \r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n  \r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        id: 'config', // Set id field directly\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n  \r\n      await this.db!.put('metadata', metadata); // Use metadata directly\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n  \r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const result = await this.db!.get('metadata', 'config');\r\n      return result || null; // Return `null` if `result` is `undefined`\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}\r\n","import { MetricsResult, PerformanceMetric } from \"@/types\";\r\n\r\nexport class PerformanceMonitor {\r\n    private metrics: Map<string, number[]>;\r\n\r\n    constructor() {\r\n        this.metrics = new Map();\r\n    }\r\n\r\n    async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {\r\n        const start = performance.now();\r\n        try {\r\n            return await fn();\r\n        } finally {\r\n            const duration = performance.now() - start;\r\n            this.recordMetric(name, duration);\r\n        }\r\n    }\r\n\r\n    private recordMetric(name: string, duration: number): void {\r\n        if (!this.metrics.has(name)) {\r\n            this.metrics.set(name, []);\r\n        }\r\n        this.metrics.get(name)!.push(duration);\r\n    }\r\n\r\n    getMetrics(): MetricsResult {\r\n        const results: MetricsResult = {};\r\n\r\n        this.metrics.forEach((durations, name) => {\r\n            results[name] = {\r\n                avg: this.average(durations),\r\n                min: Math.min(...durations),\r\n                max: Math.max(...durations),\r\n                count: durations.length\r\n            } as PerformanceMetric;\r\n        });\r\n\r\n        return results;\r\n    }\r\n\r\n    private average(numbers: number[]): number {\r\n        return numbers.reduce((a, b) => a + b, 0) / numbers.length;\r\n    }\r\n\r\n    clear(): void {\r\n        this.metrics.clear();\r\n    }\r\n}"],"names":["CacheManager","constructor","maxSize","ttlMinutes","initialStrategy","this","cache","Map","ttl","strategy","accessOrder","stats","hits","misses","evictions","set","key","data","size","evict","entry","timestamp","Date","now","lastAccessed","accessCount","updateAccessOrder","get","isExpired","delete","removeFromAccessOrder","clear","getStats","hitRate","keyToEvict","findLRUKey","findMRUKey","length","push","unshift","index","indexOf","splice","setStrategy","newStrategy","entries","forEach","prune","prunedCount","analyze","totalAccesses","totalAccessCount","accessCounts","averageAccessCount","mostAccessedKeys","Array","from","sort","a","b","slice","map","count","SearchStorage","options","type","db","memoryStorage","storageType","determineStorageType","isIndexedDBAvailable","indexedDB","_a","initialize","openDB","upgrade","createObjectStore","keyPath","createIndex","error","console","warn","storeIndex","name","put","id","getIndex","clearIndices","close","IndexedDocument","fields","metadata","fromObject","obj","toObject","bind","DataMapper","dataMap","mapData","documentId","has","Set","add","getDocuments","getAllKeys","keys","removeDocument","value","removeKey","exportState","serializedMap","importState","state","Object","TrieNode","children","isEndOfWord","documentRefs","weight","TrieSearch","root","documents","documentLinks","insert","text","words","toLowerCase","split","filter","Boolean","word","current","char","search","query","maxResults","results","found","collectDocumentRefs","remove","node","removeHelper","child","linkDocument","links","getDocumentLinks","removeData","fuzzySearch","maxDistance","fuzzySearchHelper","docId","values","currentWord","calculateLevenshteinDistance","childNode","newDistance","s1","s2","dp","fill","i","j","Math","min","trie","serializeNode","deserializeNode","serialized","childData","getSize","IndexMapper","dataMapper","trieSearch","indexDocument","document","field","tokenizeText","fuzzy","searchTerms","documentScores","term","score","matches","calculateScore","item","Error","replace","addDocument","updateDocument","createSearchableFields","content","isArray","searchableFields","getNestedValue","undefined","normalizeFieldValue","trim","v","join","String","path","parseInt","isNaN","sortObjectKeys","reduce","sorted","generateSortKey","doc","validateSearchOptions","threshold","IndexManager","getAllDocuments","config","indexMapper","addDocuments","generateDocumentId","contentRecord","searchableDoc","_b","result","exportIndex","serializeDocument","indexState","importIndex","isValidIndexData","typedData","isValidIndexState","message","indexData","JSON","parse","stringify","QueryProcessor","STOP_WORDS","process","tokens","tokenize","processedTokens","processTokens","optimizeQuery","classifyToken","startsWith","includes","token","normalizeToken","endsWith","SearchEngine","isInitialized","indexManager","queryProcessor","storage","eventListeners","storageError","emitEvent","loadIndexes","documentCount","indexedDoc","indexed","lastModified","searchableContent","searchStartTime","cacheKey","generateCacheKey","cachedResults","processedQuery","enhancedResults","resultCount","searchTime","updatedDoc","addEventListener","listener","removeEventListener","event","storedIndex","indexedDocs","random","toString","substring","clearIndex","isReady","getDocumentById","getIndexedDocumentCount","getTrieState","ValidationError","super","StorageError","CacheStrategyType","SearchError","IndexError","isSearchOptions","sortBy","sortOrder","page","pageSize","regex","RegExp","boost","isIndexConfig","version","isSearchResult","NexusSearchNamespace","DEFAULT_INDEX_OPTIONS","DEFAULT_SEARCH_OPTIONS","highlight","includeMatches","includeScore","includeStats","window","NexusSearch","DB_NAME","DB_VERSION","initPromise","objectStoreNames","contains","blocked","blocking","terminated","ensureConnection","updateMetadata","lastUpdated","getMetadata","deleteIndex","metrics","measure","fn","start","performance","duration","recordMetric","getMetrics","durations","avg","average","max","numbers","originalSize","optimizedSize","compressionRatio","uniqueMap","aKey","bKey","localeCompare","every"],"mappings":"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"}