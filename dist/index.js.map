{"version":3,"file":"index.js","sources":["../src/types/errors.ts","../src/types/index.ts","../src/mappers/DataMapper.ts","../src/algorithms/trie/TrieNode.ts","../src/algorithms/trie/TrieSearch.ts","../src/mappers/IndexMapper.ts","../src/utils/SearchUtils.ts","../src/core/IndexManager.ts","../src/core/QueryProcessor.ts","../node_modules/idb/build/wrap-idb-value.js","../node_modules/idb/build/index.js","../src/storage/IndexedDB.ts","../src/storage/CacheManager.ts","../src/utils/ValidationUtils.ts","../src/core/SearchEngine.ts"],"sourcesContent":["export class SearchError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'SearchError';\r\n  }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class StorageError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'StorageError';\r\n  }\r\n}","\r\n\r\nexport * from './types';\r\nexport * from './errors';\r\nexport * from './events';\r\nexport * from './internal';\r\nexport * from './guards';\r\nexport * from './utils';\r\nexport * from './defaults';\r\n\r\n// Event types implementation\r\nexport type SearchEventType = \r\n  | 'search:start'\r\n  | 'search:complete'\r\n  | 'search:error'\r\n  | 'index:start'\r\n  | 'index:complete'\r\n  | 'index:error'\r\n  | 'storage:error';\r\n\r\nexport interface SearchEvent {\r\n  type: SearchEventType;\r\n  timestamp: number;\r\n  data?: any;\r\n  error?: Error;\r\n}\r\n\r\nexport interface SearchEventListener {\r\n  (event: SearchEvent): void;\r\n}\r\n\r\n// Internal types implementation\r\nexport interface IndexNode {\r\n  id: string;\r\n  value: any;\r\n  score: number;\r\n  children: Map<string, IndexNode>;\r\n}\r\n\r\nexport interface SearchContext {\r\n  query: string;\r\n  options: SearchOptions;\r\n  startTime: number;\r\n  results: SearchResult<any>[];\r\n  stats: SearchStats;\r\n}\r\n\r\nexport interface TokenInfo {\r\n  value: string;\r\n  type: 'word' | 'operator' | 'modifier' | 'delimiter';\r\n  position: number;\r\n  length: number;\r\n}\r\n\r\n// Type guards\r\nexport function isSearchOptions(obj: any): obj is SearchOptions {\r\n  return obj && (\r\n    typeof obj.fuzzy === 'undefined' || typeof obj.fuzzy === 'boolean'\r\n  ) && (\r\n    typeof obj.maxResults === 'undefined' || typeof obj.maxResults === 'number'\r\n  );\r\n}\r\n\r\nexport function isIndexConfig(obj: any): obj is IndexConfig {\r\n  return obj && \r\n    typeof obj.name === 'string' &&\r\n    typeof obj.version === 'number' &&\r\n    Array.isArray(obj.fields);\r\n}\r\n\r\nexport function isSearchResult<T>(obj: any): obj is SearchResult<T> {\r\n  return obj &&\r\n    'item' in obj &&\r\n    typeof obj.score === 'number' &&\r\n    Array.isArray(obj.matches);\r\n}\r\n\r\n// Utility type functions\r\nexport function createSearchStats(): SearchStats {\r\n  return {\r\n    totalResults: 0,\r\n    searchTime: 0,\r\n    indexSize: 0,\r\n    queryComplexity: 0\r\n  };\r\n}\r\n\r\nexport function createSearchContext(\r\n  query: string,\r\n  options: SearchOptions = {}\r\n): SearchContext {\r\n  return {\r\n    query,\r\n    options,\r\n    startTime: Date.now(),\r\n    results: [],\r\n    stats: createSearchStats()\r\n  };\r\n}\r\n\r\nexport function createTokenInfo(\r\n  value: string,\r\n  type: TokenInfo['type'],\r\n  position: number\r\n): TokenInfo {\r\n  return {\r\n    value,\r\n    type,\r\n    position,\r\n    length: value.length\r\n  };\r\n}\r\n\r\n// Default configurations\r\nexport const DEFAULT_INDEX_OPTIONS: Required<IndexOptions> = {\r\n  caseSensitive: false,\r\n  stemming: true,\r\n  stopWords: ['the', 'a', 'an', 'and', 'or', 'but'],\r\n  minWordLength: 2,\r\n  maxWordLength: 50,\r\n  fuzzyThreshold: 0.8\r\n};\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n  fuzzy: false,\r\n  maxResults: 10,\r\n  threshold: 0.5,\r\n  fields: [],\r\n  sortBy: 'score',\r\n  sortOrder: 'desc',\r\n  page: 1,\r\n  pageSize: 10\r\n};\r\n\r\n// Export a namespace for internal use\r\nexport namespace NexusSearch {\r\n  export interface InternalConfig extends IndexConfig {\r\n    _id: string;\r\n    _created: number;\r\n    _updated: number;\r\n  }\r\n\r\n  export interface QueryContext extends SearchContext {\r\n    _processed: boolean;\r\n    _cached: boolean;\r\n  }\r\n}\r\nexport interface SearchOptions {\r\n    fuzzy?: boolean;\r\n    maxResults?: number;\r\n    threshold?: number;\r\n    fields?: string[];\r\n    sortBy?: string;\r\n    sortOrder?: 'asc' | 'desc';\r\n    page?: number;\r\n    pageSize?: number;\r\n  }\r\n  \r\n  export interface SearchResult<T> {\r\n    item: T;\r\n    score: number;\r\n    matches: string[];\r\n    highlights?: Record<string, string[]>;\r\n  }\r\n  \r\n  export interface IndexConfig {\r\n    name: string;\r\n    version: number;\r\n    fields: string[];\r\n    options?: IndexOptions;\r\n  }\r\n  \r\n  export interface IndexOptions {\r\n    caseSensitive?: boolean;\r\n    stemming?: boolean;\r\n    stopWords?: string[];\r\n    minWordLength?: number;\r\n    maxWordLength?: number;\r\n    fuzzyThreshold?: number;\r\n  }\r\n  \r\n  export interface SearchStats {\r\n    totalResults: number;\r\n    searchTime: number;\r\n    indexSize: number;\r\n    queryComplexity: number;\r\n  }\r\n\r\n  ","\r\n  export class DataMapper {\r\n    private dataMap: Map<string, Set<string>>;\r\n  \r\n    constructor() {\r\n      this.dataMap = new Map();\r\n    }\r\n  \r\n    mapData(key: string, documentId: string): void {\r\n      if (!this.dataMap.has(key)) {\r\n        this.dataMap.set(key, new Set());\r\n      }\r\n      this.dataMap.get(key)!.add(documentId);\r\n    }\r\n  \r\n    getDocuments(key: string): Set<string> {\r\n      return this.dataMap.get(key) || new Set();\r\n    }\r\n  \r\n    getAllKeys(): string[] {\r\n      return Array.from(this.dataMap.keys());\r\n    }\r\n  \r\n    clear(): void {\r\n      this.dataMap.clear();\r\n    }\r\n  }\r\n  \r\n","export class TrieNode {\r\n    children: Map<string, TrieNode>;\r\n    isEndOfWord: boolean;\r\n    data: Set<string>;\r\n    \r\n    constructor() {\r\n      this.children = new Map();\r\n      this.isEndOfWord = false;\r\n      this.data = new Set();\r\n    }\r\n  }\r\n  ","import { TrieNode } from \"./TrieNode\";\r\n\r\ninterface SerializedTrieNode {\r\n  isEndOfWord: boolean;\r\n  data: string[];\r\n  children: { [key: string]: SerializedTrieNode };\r\n}\r\n\r\n\r\nexport class TrieSearch {\r\n  private root: TrieNode;\r\n\r\n  constructor() {\r\n    this.root = new TrieNode();\r\n  }\r\n\r\n  insert(word: string, documentId: string): void {\r\n    let current = this.root;\r\n    \r\n    for (const char of word.toLowerCase()) {\r\n      if (!current.children.has(char)) {\r\n        current.children.set(char, new TrieNode());\r\n      }\r\n      current = current.children.get(char)!;\r\n    }\r\n    \r\n    current.isEndOfWord = true;\r\n    current.data.add(documentId);\r\n  }\r\n\r\n  search(prefix: string, maxResults: number = 10): Set<string> {\r\n    const results = new Set<string>();\r\n    let current = this.root;\r\n\r\n    for (const char of prefix.toLowerCase()) {\r\n      if (!current.children.has(char)) {\r\n        return results;\r\n      }\r\n      current = current.children.get(char)!;\r\n    }\r\n\r\n    this.collectIds(current, results, maxResults);\r\n    return results;\r\n  }\r\n\r\n  exportState(): SerializedTrieNode {\r\n    return this.serializeNode(this.root);\r\n  }\r\n\r\n  importState(state: SerializedTrieNode): void {\r\n    this.root = this.deserializeNode(state);\r\n  }\r\n\r\n  private collectIds(node: TrieNode, results: Set<string>, maxResults: number): void {\r\n    if (node.isEndOfWord) {\r\n      for (const id of node.data) {\r\n        if (results.size >= maxResults) return;\r\n        results.add(id);\r\n      }\r\n    }\r\n\r\n    for (const child of node.children.values()) {\r\n      if (results.size >= maxResults) return;\r\n      this.collectIds(child, results, maxResults);\r\n    }\r\n  }\r\n\r\n  fuzzySearch(word: string, maxDistance: number = 2): Set<string> {\r\n    const results = new Set<string>();\r\n    this.fuzzySearchHelper(word.toLowerCase(), this.root, '', maxDistance, results);\r\n    return results;\r\n  }\r\n\r\n  private fuzzySearchHelper(\r\n    word: string,\r\n    node: TrieNode,\r\n    currentWord: string,\r\n    maxDistance: number,\r\n    results: Set<string>\r\n  ): void {\r\n    if (maxDistance < 0) return;\r\n\r\n    if (node.isEndOfWord) {\r\n      const distance = this.levenshteinDistance(word, currentWord);\r\n      if (distance <= maxDistance) {\r\n        node.data.forEach(id => results.add(id));\r\n      }\r\n    }\r\n\r\n    for (const [char, childNode] of node.children) {\r\n      this.fuzzySearchHelper(\r\n        word,\r\n        childNode,\r\n        currentWord + char,\r\n        maxDistance,\r\n        results\r\n      );\r\n    }\r\n  }\r\n\r\n  private levenshteinDistance(s1: string, s2: string): number {\r\n    const dp: number[][] = Array(s1.length + 1)\r\n      .fill(0)\r\n      .map(() => Array(s2.length + 1).fill(0));\r\n\r\n    for (let i = 0; i <= s1.length; i++) dp[i][0] = i;\r\n    for (let j = 0; j <= s2.length; j++) dp[0][j] = j;\r\n\r\n    for (let i = 1; i <= s1.length; i++) {\r\n      for (let j = 1; j <= s2.length; j++) {\r\n        dp[i][j] = Math.min(\r\n          dp[i - 1][j] + 1,\r\n          dp[i][j - 1] + 1,\r\n          dp[i - 1][j - 1] + (s1[i - 1] !== s2[j - 1] ? 1 : 0)\r\n        );\r\n      }\r\n    }\r\n\r\n    return dp[s1.length][s2.length];\r\n  }\r\n   private serializeNode(node: TrieNode): SerializedTrieNode {\r\n    const children: { [key: string]: SerializedTrieNode } = {};\r\n    \r\n    node.children.forEach((childNode, char) => {\r\n      children[char] = this.serializeNode(childNode);\r\n    });\r\n\r\n    return {\r\n      isEndOfWord: node.isEndOfWord,\r\n      data: Array.from(node.data),\r\n      children\r\n    };\r\n  }\r\n\r\n  private deserializeNode(serialized: SerializedTrieNode): TrieNode {\r\n    const node = new TrieNode();\r\n    node.isEndOfWord = serialized.isEndOfWord;\r\n    node.data = new Set(serialized.data);\r\n\r\n    Object.entries(serialized.children).forEach(([char, childData]) => {\r\n      node.children.set(char, this.deserializeNode(childData));\r\n    });\r\n\r\n    return node;\r\n  }\r\n\r\n}","import { SearchResult } from '../types';\r\nimport { DataMapper } from './DataMapper';\r\nimport { TrieSearch } from '../algorithms/trie/TrieSearch';\r\n\r\nexport class IndexMapper {\r\n  private dataMapper: DataMapper;\r\n  private trieSearch: TrieSearch;\r\n\r\n  constructor() {\r\n    this.dataMapper = new DataMapper();\r\n    this.trieSearch = new TrieSearch();\r\n  }\r\n\r\n  indexDocument(document: any, id: string, fields: string[]): void {\r\n    fields.forEach(field => {\r\n      const value = document[field];\r\n      if (typeof value === 'string') {\r\n        const words = this.tokenizeText(value);\r\n        words.forEach(word => {\r\n          this.trieSearch.insert(word, id);\r\n          this.dataMapper.mapData(word.toLowerCase(), id);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  search(query: string, options: { fuzzy?: boolean; maxResults?: number } = {}): SearchResult<string>[] {\r\n    const { fuzzy = false, maxResults = 10 } = options;\r\n    const searchTerms = this.tokenizeText(query);\r\n    \r\n    const documentScores = new Map<string, { score: number; matches: Set<string> }>();\r\n\r\n    searchTerms.forEach(term => {\r\n      const documentIds = fuzzy\r\n        ? this.trieSearch.fuzzySearch(term)\r\n        : this.trieSearch.search(term, maxResults);\r\n\r\n      documentIds.forEach(id => {\r\n        const current = documentScores.get(id) || { score: 0, matches: new Set<string>() };\r\n        current.score += this.calculateScore(id, term);\r\n        current.matches.add(term);\r\n        documentScores.set(id, current);\r\n      });\r\n    });\r\n\r\n    const results = Array.from(documentScores.entries())\r\n      .map(([id, { score, matches }]) => ({\r\n        item: id,\r\n        score: score / searchTerms.length,\r\n        matches: Array.from(matches)\r\n      }))\r\n      .sort((a, b) => b.score - a.score);\r\n\r\n    return results.slice(0, maxResults);\r\n  }\r\n\r\n  exportState(): any {\r\n    return {\r\n      trie: this.trieSearch.exportState(),\r\n      dataMap: this.dataMapper.exportState()\r\n    };\r\n  }\r\n\r\n  importState(state: any): void {\r\n    if (!state || !state.trie || !state.dataMap) {\r\n      throw new Error('Invalid index state');\r\n    }\r\n\r\n    this.trieSearch = new TrieSearch();\r\n    this.trieSearch.importState(state.trie);\r\n\r\n    this.dataMapper = new DataMapper();\r\n    this.dataMapper.importState(state.dataMap);\r\n  }\r\n\r\n  private tokenizeText(text: string): string[] {\r\n    return text\r\n      .toLowerCase()\r\n      .replace(/[^\\w\\s]/g, ' ')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 0);\r\n  }\r\n\r\n  private calculateScore(documentId: string, term: string): number {\r\n    const baseScore = this.dataMapper.getDocuments(term.toLowerCase()).has(documentId) ? 1.0 : 0.5;\r\n    return baseScore\r\n  \r\n  }\r\n  clear(): void {\r\n    this.trieSearch = new TrieSearch();\r\n    this.dataMapper = new DataMapper();\r\n  }\r\n}\r\n","import { SearchOptions } from '../types';\r\n\r\n\r\nexport function createSearchableFields<T>(\r\n  document: T,\r\n  fields: string[]\r\n): Record<string, string> {\r\n  const searchableFields: Record<string, string> = {};\r\n\r\n  fields.forEach(field => {\r\n    const value = getNestedValue(document, field);\r\n    if (value !== undefined) {\r\n      searchableFields[field] = normalizeFieldValue(value);\r\n    }\r\n  });\r\n\r\n  return searchableFields;\r\n}\r\n\r\nexport function normalizeFieldValue(value: any): string {\r\n  if (typeof value === 'string') {\r\n    return value.toLowerCase().trim();\r\n  }\r\n  if (Array.isArray(value)) {\r\n    return value.map(v => normalizeFieldValue(v)).join(' ');\r\n  }\r\n  if (typeof value === 'object' && value !== null) {\r\n    return Object.values(value).map(v => normalizeFieldValue(v)).join(' ');\r\n  }\r\n  return String(value);\r\n}\r\n\r\nexport function getNestedValue(obj: any, path: string): any {\r\n  return path.split('.').reduce((current, key) => \r\n    current && current[key] !== undefined ? current[key] : undefined, \r\n    obj\r\n  );\r\n}\r\n\r\nexport function optimizeIndex(data: any[]): any[] {\r\n  // Remove duplicates\r\n  const uniqueData = Array.from(new Set(data.map(item => \r\n    JSON.stringify(item)\r\n  ))).map(item => JSON.parse(item));\r\n\r\n  // Sort for binary search optimization\r\n  return uniqueData.sort((a, b) => \r\n    JSON.stringify(a).localeCompare(JSON.stringify(b))\r\n  );\r\n}\r\n\r\n","import { IndexMapper } from \"@/mappers/IndexMapper\";\r\nimport { IndexConfig, SearchOptions, SearchResult } from \"@/types\";\r\nimport { createSearchableFields } from \"@/utils/SearchUtils\";\r\n\r\nexport class IndexManager {\r\n    private indexMapper: IndexMapper;\r\n    private config: IndexConfig;\r\n    private documents: Map<string, any>;\r\n  \r\n    constructor(config: IndexConfig) {\r\n      this.config = config;\r\n      this.indexMapper = new IndexMapper();\r\n      this.documents = new Map();\r\n    }\r\n  \r\n    async addDocuments<T>(documents: T[]): Promise<void> {\r\n      documents.forEach((doc, index) => {\r\n        const id = this.generateDocumentId(index);\r\n        this.documents.set(id, doc);\r\n        \r\n        const searchableFields = createSearchableFields(doc, this.config.fields);\r\n        this.indexMapper.indexDocument(searchableFields, id, this.config.fields);\r\n      });\r\n    }\r\n  \r\n    async search<T>(query: string, options: SearchOptions): Promise<SearchResult<T>[]> {\r\n      const searchResults = this.indexMapper.search(query, {\r\n        fuzzy: options.fuzzy,\r\n        maxResults: options.maxResults\r\n      });\r\n  \r\n      return searchResults.map(result => ({\r\n        item: this.documents.get(result.item) as T,\r\n        score: result.score,\r\n        matches: result.matches\r\n      }));\r\n    }\r\n  \r\n    exportIndex(): any {\r\n      // Convert Map to a serializable format and include indexMapper state\r\n      return {\r\n        documents: Array.from(this.documents.entries()).map(([key, value]) => ({\r\n          key,\r\n          value: JSON.parse(JSON.stringify(value)) // Handle potential proxy objects\r\n        })),\r\n        indexState: this.indexMapper.exportState(),\r\n        config: JSON.parse(JSON.stringify(this.config)) // Ensure config is serializable\r\n      };\r\n    }\r\n  \r\n    importIndex(data: any): void {\r\n      if (!data || !data.documents || !data.indexState || !data.config) {\r\n        throw new Error('Invalid index data format');\r\n      }\r\n\r\n      try {\r\n        // Restore documents\r\n        this.documents = new Map(\r\n          data.documents.map((item: any) => [item.key, item.value])\r\n        );\r\n\r\n        // Restore config\r\n        this.config = data.config;\r\n\r\n        // Restore index mapper state\r\n        this.indexMapper = new IndexMapper();\r\n        this.indexMapper.importState(data.indexState);\r\n      } catch (error) {\r\n        throw new Error(`Failed to import index: ${error}`);\r\n      }\r\n    }\r\n  \r\n    clear(): void {\r\n      this.documents.clear();\r\n      this.indexMapper = new IndexMapper();\r\n    }\r\n  \r\n    private generateDocumentId(index: number): string {\r\n      return `${this.config.name}-${index}-${Date.now()}`;\r\n    }\r\n}","type QueryToken = {\r\n  type: 'term' | 'operator' | 'modifier';\r\n  value: string;\r\n};\r\n\r\nexport class QueryProcessor {\r\n  private readonly STOP_WORDS = new Set([\r\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for',\r\n    'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on',\r\n    'that', 'the', 'to', 'was', 'were', 'will', 'with'\r\n  ]);\r\n\r\n  process(query: string): string {\r\n    const tokens = this.tokenize(query);\r\n    const processedTokens = this.processTokens(tokens);\r\n    return this.optimizeQuery(processedTokens);\r\n  }\r\n\r\n  private tokenize(query: string): QueryToken[] {\r\n    return query\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(term => term.length > 0)\r\n      .map(term => this.classifyToken(term));\r\n  }\r\n\r\n  private classifyToken(term: string): QueryToken {\r\n    if (term.startsWith('+') || term.startsWith('-')) {\r\n      return { type: 'operator', value: term };\r\n    }\r\n    if (term.includes(':')) {\r\n      return { type: 'modifier', value: term };\r\n    }\r\n    return { type: 'term', value: term };\r\n  }\r\n\r\n  private processTokens(tokens: QueryToken[]): QueryToken[] {\r\n    return tokens\r\n      .filter(token => \r\n        token.type !== 'term' || !this.STOP_WORDS.has(token.value)\r\n      )\r\n      .map(token => this.normalizeToken(token));\r\n  }\r\n\r\n  private normalizeToken(token: QueryToken): QueryToken {\r\n    if (token.type === 'term') {\r\n      // Basic stemming (could be enhanced with proper stemming algorithm)\r\n      let value = token.value;\r\n      if (value.endsWith('ing')) value = value.slice(0, -3);\r\n      if (value.endsWith('s')) value = value.slice(0, -1);\r\n      return { ...token, value };\r\n    }\r\n    return token;\r\n  }\r\n\r\n  private optimizeQuery(tokens: QueryToken[]): string {\r\n    return tokens\r\n      .map(token => token.value)\r\n      .join(' ');\r\n  }\r\n}","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { openDB, DBSchema, IDBPDatabase } from 'idb';\r\nimport { IndexConfig } from '../types';\r\n\r\ninterface SearchDBSchema extends DBSchema {\r\n  searchIndices: {\r\n    key: string;\r\n    value: {\r\n      id: string;\r\n      data: any;\r\n      timestamp: number;\r\n    };\r\n  };\r\n  metadata: {\r\n    key: string;\r\n    value: MetadataEntry;\r\n  };\r\n}\r\n\r\ninterface MetadataEntry {\r\n  config: IndexConfig;\r\n  lastUpdated: number;\r\n}\r\n\r\nexport class SearchStorage {\r\n  private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n  private readonly DB_NAME = 'nexus_search_db';\r\n  private readonly DB_VERSION = 1;\r\n  private initPromise: Promise<void> | null = null;\r\n\r\n  constructor() {\r\n    // Initialize immediately to catch early failures\r\n    this.initPromise = this.initialize();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.db) return;\r\n\r\n    try {\r\n      this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n        upgrade(db, oldVersion, newVersion, transaction) {\r\n          // Handle version upgrades\r\n          if (!db.objectStoreNames.contains('searchIndices')) {\r\n            const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n            indexStore.createIndex('timestamp', 'timestamp');\r\n          }\r\n\r\n          if (!db.objectStoreNames.contains('metadata')) {\r\n            const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n            metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n          }\r\n        },\r\n        blocked() {\r\n          console.warn('Database upgrade was blocked');\r\n        },\r\n        blocking() {\r\n          console.warn('Current database version is blocking a newer version');\r\n        },\r\n        terminated() {\r\n          console.error('Database connection was terminated');\r\n        }\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Storage initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n    \r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n      \r\n      await this.db!.put('metadata', { id: 'config', ...metadata });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      return await this.db!.get('metadata', 'config');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}","import { SearchResult } from '../types';\r\n\r\nexport class CacheManager {\r\n  private cache: Map<string, { data: SearchResult<any>[]; timestamp: number }>;\r\n  private readonly maxSize: number;\r\n  private readonly ttl: number; // Time to live in milliseconds\r\n\r\n  constructor(maxSize: number = 1000, ttlMinutes: number = 5) {\r\n    this.cache = new Map();\r\n    this.maxSize = maxSize;\r\n    this.ttl = ttlMinutes * 60 * 1000;\r\n  }\r\n\r\n  set(key: string, data: SearchResult<any>[]): void {\r\n    if (this.cache.size >= this.maxSize) {\r\n      this.evictOldest();\r\n    }\r\n\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: Date.now(),\r\n    });\r\n  }\r\n\r\n  get(key: string): SearchResult<any>[] | null {\r\n    const entry = this.cache.get(key);\r\n    \r\n    if (!entry) return null;\r\n    \r\n    if (this.isExpired(entry.timestamp)) {\r\n      this.cache.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return entry.data;\r\n  }\r\n\r\n  private isExpired(timestamp: number): boolean {\r\n    return Date.now() - timestamp > this.ttl;\r\n  }\r\n\r\n  private evictOldest(): void {\r\n    let oldestKey: string | null = null;\r\n    let oldestTime = Infinity;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.timestamp < oldestTime) {\r\n        oldestTime = entry.timestamp;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      this.cache.delete(oldestKey);\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n}","import { SearchOptions, IndexConfig } from '@types';\r\nimport { getNestedValue } from './SearchUtils';\r\n\r\nexport function validateSearchOptions(options: SearchOptions): void {\r\n  if (options.maxResults && options.maxResults < 1) {\r\n    throw new Error('maxResults must be greater than 0');\r\n  }\r\n\r\n  if (options.threshold && (options.threshold < 0 || options.threshold > 1)) {\r\n    throw new Error('threshold must be between 0 and 1');\r\n  }\r\n\r\n  if (options.fields && !Array.isArray(options.fields)) {\r\n    throw new Error('fields must be an array');\r\n  }\r\n}\r\n\r\nexport function validateIndexConfig(config: IndexConfig): void {\r\n  if (!config.name) {\r\n    throw new Error('Index name is required');\r\n  }\r\n\r\n  if (!config.version || typeof config.version !== 'number') {\r\n    throw new Error('Valid version number is required');\r\n  }\r\n\r\n  if (!Array.isArray(config.fields) || config.fields.length === 0) {\r\n    throw new Error('At least one field must be specified for indexing');\r\n  }\r\n}\r\n\r\nexport function validateDocument(document: any, fields: string[]): boolean {\r\n  return fields.every(field => {\r\n    const value = getNestedValue(document, field);\r\n    return value !== undefined;\r\n  });\r\n}","import { SearchOptions, SearchResult, IndexConfig } from '../types';\r\nimport { IndexManager } from './IndexManager';\r\nimport { QueryProcessor } from './QueryProcessor';\r\nimport { SearchStorage } from '../storage/IndexedDB';\r\nimport { CacheManager } from '../storage/CacheManager';\r\nimport { validateSearchOptions } from '@/utils/ValidationUtils';\r\n\r\nexport class SearchEngine {\r\n  private indexManager: IndexManager;\r\n  private queryProcessor: QueryProcessor;\r\n  private storage: SearchStorage;\r\n  private cache: CacheManager;\r\n  private config: IndexConfig;\r\n\r\n  constructor(config: IndexConfig) {\r\n    this.config = config;\r\n    this.indexManager = new IndexManager(config);\r\n    this.queryProcessor = new QueryProcessor();\r\n    this.storage = new SearchStorage();\r\n    this.cache = new CacheManager();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      await this.storage.initialize();\r\n      await this.loadIndexes();\r\n    } catch (error) {\r\n      throw new Error(`Failed to initialize search engine: ${error}`);\r\n    }\r\n  }\r\n\r\n  async addDocuments<T>(documents: T[]): Promise<void> {\r\n    try {\r\n      await this.indexManager.addDocuments(documents);\r\n      await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n    } catch (error) {\r\n      throw new Error(`Failed to add documents: ${error}`);\r\n    }\r\n  }\r\n\r\n  async search<T>(query: string, options: SearchOptions = {}): Promise<SearchResult<T>[]> {\r\n    validateSearchOptions(options);\r\n    \r\n    const cacheKey = this.generateCacheKey(query, options);\r\n    const cachedResults = this.cache.get(cacheKey);\r\n    \r\n    if (cachedResults) {\r\n      return cachedResults as SearchResult<T>[];\r\n    }\r\n\r\n    const processedQuery = this.queryProcessor.process(query);\r\n    const results = await this.indexManager.search<T>(processedQuery, options);\r\n    \r\n    this.cache.set(cacheKey, results);\r\n    return results;\r\n  }\r\n\r\n  private async loadIndexes(): Promise<void> {\r\n    const storedIndex = await this.storage.getIndex(this.config.name);\r\n    if (storedIndex) {\r\n      this.indexManager.importIndex(storedIndex);\r\n    }\r\n  }\r\n\r\n  private generateCacheKey(query: string, options: SearchOptions): string {\r\n    return `${query}-${JSON.stringify(options)}`;\r\n  }\r\n\r\n  async clearIndex(): Promise<void> {\r\n    await this.storage.clearIndices();\r\n    this.indexManager.clear();\r\n    this.cache.clear();\r\n  }\r\n}\r\n"],"names":["SearchError","Error","constructor","message","super","this","name","IndexError","ValidationError","StorageError","createSearchStats","totalResults","searchTime","indexSize","queryComplexity","DataMapper","dataMap","Map","mapData","key","documentId","has","set","Set","get","add","getDocuments","getAllKeys","Array","from","keys","clear","TrieNode","children","isEndOfWord","data","TrieSearch","root","insert","word","current","char","toLowerCase","search","prefix","maxResults","results","collectIds","exportState","serializeNode","importState","state","deserializeNode","node","id","size","child","values","fuzzySearch","maxDistance","fuzzySearchHelper","currentWord","levenshteinDistance","forEach","childNode","s1","s2","dp","length","fill","map","i","j","Math","min","serialized","Object","entries","childData","IndexMapper","dataMapper","trieSearch","indexDocument","document","fields","field","value","tokenizeText","query","options","fuzzy","searchTerms","documentScores","term","score","matches","calculateScore","item","sort","a","b","slice","trie","text","replace","split","filter","createSearchableFields","searchableFields","getNestedValue","undefined","normalizeFieldValue","trim","isArray","v","join","String","obj","path","reduce","IndexManager","config","indexMapper","documents","addDocuments","doc","index","generateDocumentId","result","exportIndex","JSON","parse","stringify","indexState","importIndex","error","Date","now","QueryProcessor","STOP_WORDS","process","tokens","tokenize","processedTokens","processTokens","optimizeQuery","classifyToken","startsWith","type","includes","token","normalizeToken","endsWith","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","args","apply","unwrap","storeNames","tx","call","transformCachableValue","done","Promise","resolve","reject","unlisten","removeEventListener","complete","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","request","promise","success","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","method","async","storeName","store","shift","all","oldTraps","callback","SearchStorage","db","DB_NAME","DB_VERSION","initPromise","initialize","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","contains","createObjectStore","keyPath","createIndex","console","warn","ensureConnection","storeIndex","entry","timestamp","put","getIndex","updateMetadata","metadata","lastUpdated","getMetadata","clearIndices","close","CacheManager","maxSize","ttlMinutes","cache","ttl","evictOldest","isExpired","delete","oldestKey","oldestTime","Infinity","validateSearchOptions","threshold","caseSensitive","stemming","stopWords","minWordLength","maxWordLength","fuzzyThreshold","sortBy","sortOrder","page","pageSize","indexManager","queryProcessor","storage","loadIndexes","cacheKey","generateCacheKey","cachedResults","processedQuery","storedIndex","clearIndex","startTime","stats","position","localeCompare","every"],"mappings":"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","x_google_ignoreList":[9,10]}