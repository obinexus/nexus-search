{"version":3,"file":"index.js","sources":["../src/types/errors.ts","../src/types/index.ts","../src/mappers/DataMapper.ts","../src/algorithms/trie/TrieNode.ts","../src/algorithms/trie/TrieSearch.ts","../src/mappers/IndexMapper.ts","../src/utils/SearchUtils.ts","../src/core/IndexManager.ts","../src/core/QueryProcessor.ts","../src/storage/IndexedDB.ts","../src/storage/CacheManager.ts","../src/utils/ValidationUtils.ts","../src/core/SearchEngine.ts"],"sourcesContent":["export class SearchError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'SearchError';\r\n  }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class StorageError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'StorageError';\r\n  }\r\n}","\r\n\r\nexport * from './types';\r\nexport * from './errors';\r\nexport * from './events';\r\nexport * from './internal';\r\nexport * from './guards';\r\nexport * from './utils';\r\nexport * from './defaults';\r\n\r\n// Event types implementation\r\nexport type SearchEventType = \r\n  | 'search:start'\r\n  | 'search:complete'\r\n  | 'search:error'\r\n  | 'index:start'\r\n  | 'index:complete'\r\n  | 'index:error'\r\n  | 'storage:error';\r\n\r\nexport interface SearchEvent {\r\n  type: SearchEventType;\r\n  timestamp: number;\r\n  data?: any;\r\n  error?: Error;\r\n}\r\n\r\nexport interface SearchEventListener {\r\n  (event: SearchEvent): void;\r\n}\r\n\r\n// Internal types implementation\r\nexport interface IndexNode {\r\n  id: string;\r\n  value: any;\r\n  score: number;\r\n  children: Map<string, IndexNode>;\r\n}\r\n\r\nexport interface SearchContext {\r\n  query: string;\r\n  options: SearchOptions;\r\n  startTime: number;\r\n  results: SearchResult<any>[];\r\n  stats: SearchStats;\r\n}\r\n\r\nexport interface TokenInfo {\r\n  value: string;\r\n  type: 'word' | 'operator' | 'modifier' | 'delimiter';\r\n  position: number;\r\n  length: number;\r\n}\r\n\r\n// Type guards\r\nexport function isSearchOptions(obj: any): obj is SearchOptions {\r\n  return obj && (\r\n    typeof obj.fuzzy === 'undefined' || typeof obj.fuzzy === 'boolean'\r\n  ) && (\r\n    typeof obj.maxResults === 'undefined' || typeof obj.maxResults === 'number'\r\n  );\r\n}\r\n\r\nexport function isIndexConfig(obj: any): obj is IndexConfig {\r\n  return obj && \r\n    typeof obj.name === 'string' &&\r\n    typeof obj.version === 'number' &&\r\n    Array.isArray(obj.fields);\r\n}\r\n\r\nexport function isSearchResult<T>(obj: any): obj is SearchResult<T> {\r\n  return obj &&\r\n    'item' in obj &&\r\n    typeof obj.score === 'number' &&\r\n    Array.isArray(obj.matches);\r\n}\r\n\r\n// Utility type functions\r\nexport function createSearchStats(): SearchStats {\r\n  return {\r\n    totalResults: 0,\r\n    searchTime: 0,\r\n    indexSize: 0,\r\n    queryComplexity: 0\r\n  };\r\n}\r\n\r\nexport function createSearchContext(\r\n  query: string,\r\n  options: SearchOptions = {}\r\n): SearchContext {\r\n  return {\r\n    query,\r\n    options,\r\n    startTime: Date.now(),\r\n    results: [],\r\n    stats: createSearchStats()\r\n  };\r\n}\r\n\r\nexport function createTokenInfo(\r\n  value: string,\r\n  type: TokenInfo['type'],\r\n  position: number\r\n): TokenInfo {\r\n  return {\r\n    value,\r\n    type,\r\n    position,\r\n    length: value.length\r\n  };\r\n}\r\n\r\n// Default configurations\r\nexport const DEFAULT_INDEX_OPTIONS: Required<IndexOptions> = {\r\n  caseSensitive: false,\r\n  stemming: true,\r\n  stopWords: ['the', 'a', 'an', 'and', 'or', 'but'],\r\n  minWordLength: 2,\r\n  maxWordLength: 50,\r\n  fuzzyThreshold: 0.8\r\n};\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n  fuzzy: false,\r\n  maxResults: 10,\r\n  threshold: 0.5,\r\n  fields: [],\r\n  sortBy: 'score',\r\n  sortOrder: 'desc',\r\n  page: 1,\r\n  pageSize: 10\r\n};\r\n\r\n// Export a namespace for internal use\r\nexport namespace NexusSearch {\r\n  export interface InternalConfig extends IndexConfig {\r\n    _id: string;\r\n    _created: number;\r\n    _updated: number;\r\n  }\r\n\r\n  export interface QueryContext extends SearchContext {\r\n    _processed: boolean;\r\n    _cached: boolean;\r\n  }\r\n}\r\nexport interface SearchOptions {\r\n    fuzzy?: boolean;\r\n    maxResults?: number;\r\n    threshold?: number;\r\n    fields?: string[];\r\n    sortBy?: string;\r\n    sortOrder?: 'asc' | 'desc';\r\n    page?: number;\r\n    pageSize?: number;\r\n  }\r\n  \r\n  export interface SearchResult<T> {\r\n    item: T;\r\n    score: number;\r\n    matches: string[];\r\n    highlights?: Record<string, string[]>;\r\n  }\r\n  \r\n  export interface IndexConfig {\r\n    name: string;\r\n    version: number;\r\n    fields: string[];\r\n    options?: IndexOptions;\r\n  }\r\n  \r\n  export interface IndexOptions {\r\n    caseSensitive?: boolean;\r\n    stemming?: boolean;\r\n    stopWords?: string[];\r\n    minWordLength?: number;\r\n    maxWordLength?: number;\r\n    fuzzyThreshold?: number;\r\n  }\r\n  \r\n  export interface SearchStats {\r\n    totalResults: number;\r\n    searchTime: number;\r\n    indexSize: number;\r\n    queryComplexity: number;\r\n  }\r\n\r\n  ","\r\n  export class DataMapper {\r\n    private dataMap: Map<string, Set<string>>;\r\n  \r\n    constructor() {\r\n      this.dataMap = new Map();\r\n    }\r\n  \r\n    mapData(key: string, documentId: string): void {\r\n      if (!this.dataMap.has(key)) {\r\n        this.dataMap.set(key, new Set());\r\n      }\r\n      this.dataMap.get(key)!.add(documentId);\r\n    }\r\n  \r\n    getDocuments(key: string): Set<string> {\r\n      return this.dataMap.get(key) || new Set();\r\n    }\r\n  \r\n    getAllKeys(): string[] {\r\n      return Array.from(this.dataMap.keys());\r\n    }\r\n  \r\n    clear(): void {\r\n      this.dataMap.clear();\r\n    }\r\n  }\r\n  \r\n","export class TrieNode {\r\n    children: Map<string, TrieNode>;\r\n    isEndOfWord: boolean;\r\n    data: Set<string>;\r\n    \r\n    constructor() {\r\n      this.children = new Map();\r\n      this.isEndOfWord = false;\r\n      this.data = new Set();\r\n    }\r\n  }\r\n  ","import { TrieNode } from \"./TrieNode\";\r\n\r\nexport class TrieSearch {\r\n  private root: TrieNode;\r\n\r\n  constructor() {\r\n    this.root = new TrieNode();\r\n  }\r\n\r\n  insert(word: string, documentId: string): void {\r\n    let current = this.root;\r\n    \r\n    for (const char of word.toLowerCase()) {\r\n      if (!current.children.has(char)) {\r\n        current.children.set(char, new TrieNode());\r\n      }\r\n      current = current.children.get(char)!;\r\n    }\r\n    \r\n    current.isEndOfWord = true;\r\n    current.data.add(documentId);\r\n  }\r\n\r\n  search(prefix: string, maxResults: number = 10): Set<string> {\r\n    const results = new Set<string>();\r\n    let current = this.root;\r\n\r\n    for (const char of prefix.toLowerCase()) {\r\n      if (!current.children.has(char)) {\r\n        return results;\r\n      }\r\n      current = current.children.get(char)!;\r\n    }\r\n\r\n    this.collectIds(current, results, maxResults);\r\n    return results;\r\n  }\r\n\r\n  private collectIds(node: TrieNode, results: Set<string>, maxResults: number): void {\r\n    if (node.isEndOfWord) {\r\n      for (const id of node.data) {\r\n        if (results.size >= maxResults) return;\r\n        results.add(id);\r\n      }\r\n    }\r\n\r\n    for (const child of node.children.values()) {\r\n      if (results.size >= maxResults) return;\r\n      this.collectIds(child, results, maxResults);\r\n    }\r\n  }\r\n\r\n  fuzzySearch(word: string, maxDistance: number = 2): Set<string> {\r\n    const results = new Set<string>();\r\n    this.fuzzySearchHelper(word.toLowerCase(), this.root, '', maxDistance, results);\r\n    return results;\r\n  }\r\n\r\n  private fuzzySearchHelper(\r\n    word: string,\r\n    node: TrieNode,\r\n    currentWord: string,\r\n    maxDistance: number,\r\n    results: Set<string>\r\n  ): void {\r\n    if (maxDistance < 0) return;\r\n\r\n    if (node.isEndOfWord) {\r\n      const distance = this.levenshteinDistance(word, currentWord);\r\n      if (distance <= maxDistance) {\r\n        node.data.forEach(id => results.add(id));\r\n      }\r\n    }\r\n\r\n    for (const [char, childNode] of node.children) {\r\n      this.fuzzySearchHelper(\r\n        word,\r\n        childNode,\r\n        currentWord + char,\r\n        maxDistance,\r\n        results\r\n      );\r\n    }\r\n  }\r\n\r\n  private levenshteinDistance(s1: string, s2: string): number {\r\n    const dp: number[][] = Array(s1.length + 1)\r\n      .fill(0)\r\n      .map(() => Array(s2.length + 1).fill(0));\r\n\r\n    for (let i = 0; i <= s1.length; i++) dp[i][0] = i;\r\n    for (let j = 0; j <= s2.length; j++) dp[0][j] = j;\r\n\r\n    for (let i = 1; i <= s1.length; i++) {\r\n      for (let j = 1; j <= s2.length; j++) {\r\n        dp[i][j] = Math.min(\r\n          dp[i - 1][j] + 1,\r\n          dp[i][j - 1] + 1,\r\n          dp[i - 1][j - 1] + (s1[i - 1] !== s2[j - 1] ? 1 : 0)\r\n        );\r\n      }\r\n    }\r\n\r\n    return dp[s1.length][s2.length];\r\n  }\r\n}","import { SearchResult } from '../types';\r\nimport { DataMapper } from './DataMapper';\r\nimport { TrieSearch } from '../algorithms/trie/TrieSearch';\r\n\r\nexport class IndexMapper {\r\n  private dataMapper: DataMapper;\r\n  private trieSearch: TrieSearch;\r\n\r\n  constructor() {\r\n    this.dataMapper = new DataMapper();\r\n    this.trieSearch = new TrieSearch();\r\n  }\r\n\r\n  indexDocument(document: any, id: string, fields: string[]): void {\r\n    fields.forEach(field => {\r\n      const value = document[field];\r\n      if (typeof value === 'string') {\r\n        const words = value.split(/\\s+/);\r\n        words.forEach(word => {\r\n          this.trieSearch.insert(word, id);\r\n          this.dataMapper.mapData(word.toLowerCase(), id);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  search(query: string, options: { fuzzy?: boolean; maxResults?: number } = {}): SearchResult<string>[] {\r\n    const { fuzzy = false, maxResults = 10 } = options;\r\n    \r\n    const documentIds = fuzzy\r\n      ? this.trieSearch.fuzzySearch(query)\r\n      : this.trieSearch.search(query, maxResults);\r\n\r\n    const results: SearchResult<string>[] = Array.from(documentIds).map(id => ({\r\n      item: id as string,\r\n      score: this.calculateScore(id, query),\r\n      matches: [query]\r\n    }));\r\n\r\n    return results.slice(0, maxResults);\r\n  }\r\n\r\n  private calculateScore(documentId: string, query: string): number {\r\n    // Basic scoring implementation - can be enhanced\r\n    const exactMatch = this.dataMapper.getDocuments(query.toLowerCase()).has(documentId);\r\n    return exactMatch ? 1.0 : 0.5;\r\n  }\r\n}\r\n","import { SearchOptions } from '../types';\r\n\r\n\r\nexport function createSearchableFields<T>(\r\n  document: T,\r\n  fields: string[]\r\n): Record<string, string> {\r\n  const searchableFields: Record<string, string> = {};\r\n\r\n  fields.forEach(field => {\r\n    const value = getNestedValue(document, field);\r\n    if (value !== undefined) {\r\n      searchableFields[field] = normalizeFieldValue(value);\r\n    }\r\n  });\r\n\r\n  return searchableFields;\r\n}\r\n\r\nexport function normalizeFieldValue(value: any): string {\r\n  if (typeof value === 'string') {\r\n    return value.toLowerCase().trim();\r\n  }\r\n  if (Array.isArray(value)) {\r\n    return value.map(v => normalizeFieldValue(v)).join(' ');\r\n  }\r\n  if (typeof value === 'object' && value !== null) {\r\n    return Object.values(value).map(v => normalizeFieldValue(v)).join(' ');\r\n  }\r\n  return String(value);\r\n}\r\n\r\nexport function getNestedValue(obj: any, path: string): any {\r\n  return path.split('.').reduce((current, key) => \r\n    current && current[key] !== undefined ? current[key] : undefined, \r\n    obj\r\n  );\r\n}\r\n\r\nexport function optimizeIndex(data: any[]): any[] {\r\n  // Remove duplicates\r\n  const uniqueData = Array.from(new Set(data.map(item => \r\n    JSON.stringify(item)\r\n  ))).map(item => JSON.parse(item));\r\n\r\n  // Sort for binary search optimization\r\n  return uniqueData.sort((a, b) => \r\n    JSON.stringify(a).localeCompare(JSON.stringify(b))\r\n  );\r\n}\r\n\r\n","import { IndexMapper } from \"@/mappers/IndexMapper\";\r\nimport { IndexConfig, SearchOptions, SearchResult } from \"@/types\";\r\nimport { createSearchableFields } from \"@/utils/SearchUtils\";\r\n\r\nexport class IndexManager {\r\n    private indexMapper: IndexMapper;\r\n    private config: IndexConfig;\r\n    private documents: Map<string, any>;\r\n  \r\n    constructor(config: IndexConfig) {\r\n      this.config = config;\r\n      this.indexMapper = new IndexMapper();\r\n      this.documents = new Map();\r\n    }\r\n  \r\n    async addDocuments<T>(documents: T[]): Promise<void> {\r\n      documents.forEach((doc, index) => {\r\n        const id = this.generateDocumentId(index);\r\n        this.documents.set(id, doc);\r\n        \r\n        const searchableFields = createSearchableFields(doc, this.config.fields);\r\n        this.indexMapper.indexDocument(searchableFields, id, this.config.fields);\r\n      });\r\n    }\r\n  \r\n    async search<T>(query: string, options: SearchOptions): Promise<SearchResult<T>[]> {\r\n      const searchResults = this.indexMapper.search(query, {\r\n        fuzzy: options.fuzzy,\r\n        maxResults: options.maxResults\r\n      });\r\n  \r\n      return searchResults.map(result => ({\r\n        item: this.documents.get(result.item) as T,\r\n        score: result.score,\r\n        matches: result.matches\r\n      }));\r\n    }\r\n  \r\n    exportIndex(): any {\r\n      return {\r\n        documents: Array.from(this.documents.entries()),\r\n        config: this.config\r\n      };\r\n    }\r\n  \r\n    importIndex(data: any): void {\r\n      this.documents = new Map(data.documents);\r\n      this.config = data.config;\r\n    }\r\n  \r\n    clear(): void {\r\n      this.documents.clear();\r\n      this.indexMapper = new IndexMapper();\r\n    }\r\n  \r\n    private generateDocumentId(index: number): string {\r\n      return `${this.config.name}-${index}-${Date.now()}`;\r\n    }\r\n  }\r\n  ","type QueryToken = {\r\n  type: 'term' | 'operator' | 'modifier';\r\n  value: string;\r\n};\r\n\r\nexport class QueryProcessor {\r\n  private readonly STOP_WORDS = new Set([\r\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for',\r\n    'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on',\r\n    'that', 'the', 'to', 'was', 'were', 'will', 'with'\r\n  ]);\r\n\r\n  process(query: string): string {\r\n    const tokens = this.tokenize(query);\r\n    const processedTokens = this.processTokens(tokens);\r\n    return this.optimizeQuery(processedTokens);\r\n  }\r\n\r\n  private tokenize(query: string): QueryToken[] {\r\n    return query\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(term => term.length > 0)\r\n      .map(term => this.classifyToken(term));\r\n  }\r\n\r\n  private classifyToken(term: string): QueryToken {\r\n    if (term.startsWith('+') || term.startsWith('-')) {\r\n      return { type: 'operator', value: term };\r\n    }\r\n    if (term.includes(':')) {\r\n      return { type: 'modifier', value: term };\r\n    }\r\n    return { type: 'term', value: term };\r\n  }\r\n\r\n  private processTokens(tokens: QueryToken[]): QueryToken[] {\r\n    return tokens\r\n      .filter(token => \r\n        token.type !== 'term' || !this.STOP_WORDS.has(token.value)\r\n      )\r\n      .map(token => this.normalizeToken(token));\r\n  }\r\n\r\n  private normalizeToken(token: QueryToken): QueryToken {\r\n    if (token.type === 'term') {\r\n      // Basic stemming (could be enhanced with proper stemming algorithm)\r\n      let value = token.value;\r\n      if (value.endsWith('ing')) value = value.slice(0, -3);\r\n      if (value.endsWith('s')) value = value.slice(0, -1);\r\n      return { ...token, value };\r\n    }\r\n    return token;\r\n  }\r\n\r\n  private optimizeQuery(tokens: QueryToken[]): string {\r\n    return tokens\r\n      .map(token => token.value)\r\n      .join(' ');\r\n  }\r\n}","import { openDB, DBSchema, IDBPDatabase } from 'idb';\r\nimport { IndexConfig } from '../types';\r\n\r\ninterface SearchDBSchema extends DBSchema {\r\n  searchIndices: {\r\n    key: string;\r\n    value: {\r\n      id: string;\r\n      data: any;\r\n      timestamp: number;\r\n    };\r\n  };\r\n  metadata: {\r\n    key: string;\r\n    value: MetadataEntry;\r\n  };\r\n}\r\n\r\ninterface MetadataEntry {\r\n  config: IndexConfig;\r\n  lastUpdated: number;\r\n}\r\n\r\nexport class SearchStorage {\r\n  private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n  private readonly DB_NAME = 'nexus_search_db';\r\n  private readonly DB_VERSION = 1;\r\n\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n        upgrade(db) {\r\n          // Create stores if they don't exist\r\n          if (!db.objectStoreNames.contains('searchIndices')) {\r\n            db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n          }\r\n          if (!db.objectStoreNames.contains('metadata')) {\r\n            db.createObjectStore('metadata', { keyPath: 'id' });\r\n          }\r\n        },\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to initialize IndexedDB:', error);\r\n      throw new Error('Storage initialization failed');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    if (!this.db) throw new Error('Database not initialized');\r\n    \r\n    const entry = {\r\n      id: key,\r\n      data,\r\n      timestamp: Date.now(),\r\n    };\r\n\r\n    await this.db.put('searchIndices', entry);\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    if (!this.db) throw new Error('Database not initialized');\r\n    \r\n    const entry = await this.db.get('searchIndices', key);\r\n    return entry?.data || null;\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    if (!this.db) throw new Error('Database not initialized');\r\n    \r\n    const metadata: MetadataEntry = {\r\n      config,\r\n      lastUpdated: Date.now()\r\n    };\r\n    \r\n    await this.db.put('metadata', metadata, 'config');\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    if (!this.db) throw new Error('Database not initialized');\r\n    \r\n    await this.db.clear('searchIndices');\r\n  }\r\n\r\n\r\n}\r\n","import { SearchResult } from '../types';\r\n\r\nexport class CacheManager {\r\n  private cache: Map<string, { data: SearchResult<any>[]; timestamp: number }>;\r\n  private readonly maxSize: number;\r\n  private readonly ttl: number; // Time to live in milliseconds\r\n\r\n  constructor(maxSize: number = 1000, ttlMinutes: number = 5) {\r\n    this.cache = new Map();\r\n    this.maxSize = maxSize;\r\n    this.ttl = ttlMinutes * 60 * 1000;\r\n  }\r\n\r\n  set(key: string, data: SearchResult<any>[]): void {\r\n    if (this.cache.size >= this.maxSize) {\r\n      this.evictOldest();\r\n    }\r\n\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: Date.now(),\r\n    });\r\n  }\r\n\r\n  get(key: string): SearchResult<any>[] | null {\r\n    const entry = this.cache.get(key);\r\n    \r\n    if (!entry) return null;\r\n    \r\n    if (this.isExpired(entry.timestamp)) {\r\n      this.cache.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return entry.data;\r\n  }\r\n\r\n  private isExpired(timestamp: number): boolean {\r\n    return Date.now() - timestamp > this.ttl;\r\n  }\r\n\r\n  private evictOldest(): void {\r\n    let oldestKey: string | null = null;\r\n    let oldestTime = Infinity;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.timestamp < oldestTime) {\r\n        oldestTime = entry.timestamp;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      this.cache.delete(oldestKey);\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n}","import { SearchOptions, IndexConfig } from '@types';\r\nimport { getNestedValue } from './SearchUtils';\r\n\r\nexport function validateSearchOptions(options: SearchOptions): void {\r\n  if (options.maxResults && options.maxResults < 1) {\r\n    throw new Error('maxResults must be greater than 0');\r\n  }\r\n\r\n  if (options.threshold && (options.threshold < 0 || options.threshold > 1)) {\r\n    throw new Error('threshold must be between 0 and 1');\r\n  }\r\n\r\n  if (options.fields && !Array.isArray(options.fields)) {\r\n    throw new Error('fields must be an array');\r\n  }\r\n}\r\n\r\nexport function validateIndexConfig(config: IndexConfig): void {\r\n  if (!config.name) {\r\n    throw new Error('Index name is required');\r\n  }\r\n\r\n  if (!config.version || typeof config.version !== 'number') {\r\n    throw new Error('Valid version number is required');\r\n  }\r\n\r\n  if (!Array.isArray(config.fields) || config.fields.length === 0) {\r\n    throw new Error('At least one field must be specified for indexing');\r\n  }\r\n}\r\n\r\nexport function validateDocument(document: any, fields: string[]): boolean {\r\n  return fields.every(field => {\r\n    const value = getNestedValue(document, field);\r\n    return value !== undefined;\r\n  });\r\n}","import { SearchOptions, SearchResult, IndexConfig } from '../types';\r\nimport { IndexManager } from './IndexManager';\r\nimport { QueryProcessor } from './QueryProcessor';\r\nimport { SearchStorage } from '../storage/IndexedDB';\r\nimport { CacheManager } from '../storage/CacheManager';\r\nimport { validateSearchOptions } from '@/utils/ValidationUtils';\r\n\r\nexport class SearchEngine {\r\n  private indexManager: IndexManager;\r\n  private queryProcessor: QueryProcessor;\r\n  private storage: SearchStorage;\r\n  private cache: CacheManager;\r\n  private config: IndexConfig;\r\n\r\n  constructor(config: IndexConfig) {\r\n    this.config = config;\r\n    this.indexManager = new IndexManager(config);\r\n    this.queryProcessor = new QueryProcessor();\r\n    this.storage = new SearchStorage();\r\n    this.cache = new CacheManager();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      await this.storage.initialize();\r\n      await this.loadIndexes();\r\n    } catch (error) {\r\n      throw new Error(`Failed to initialize search engine: ${error}`);\r\n    }\r\n  }\r\n\r\n  async addDocuments<T>(documents: T[]): Promise<void> {\r\n    try {\r\n      await this.indexManager.addDocuments(documents);\r\n      await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n    } catch (error) {\r\n      throw new Error(`Failed to add documents: ${error}`);\r\n    }\r\n  }\r\n\r\n  async search<T>(query: string, options: SearchOptions = {}): Promise<SearchResult<T>[]> {\r\n    validateSearchOptions(options);\r\n    \r\n    const cacheKey = this.generateCacheKey(query, options);\r\n    const cachedResults = this.cache.get(cacheKey);\r\n    \r\n    if (cachedResults) {\r\n      return cachedResults as SearchResult<T>[];\r\n    }\r\n\r\n    const processedQuery = this.queryProcessor.process(query);\r\n    const results = await this.indexManager.search<T>(processedQuery, options);\r\n    \r\n    this.cache.set(cacheKey, results);\r\n    return results;\r\n  }\r\n\r\n  private async loadIndexes(): Promise<void> {\r\n    const storedIndex = await this.storage.getIndex(this.config.name);\r\n    if (storedIndex) {\r\n      this.indexManager.importIndex(storedIndex);\r\n    }\r\n  }\r\n\r\n  private generateCacheKey(query: string, options: SearchOptions): string {\r\n    return `${query}-${JSON.stringify(options)}`;\r\n  }\r\n\r\n  async clearIndex(): Promise<void> {\r\n    await this.storage.clearIndices();\r\n    this.indexManager.clear();\r\n    this.cache.clear();\r\n  }\r\n}\r\n"],"names":["SearchError","Error","constructor","message","super","this","name","IndexError","ValidationError","StorageError","createSearchStats","totalResults","searchTime","indexSize","queryComplexity","DataMapper","dataMap","Map","mapData","key","documentId","has","set","Set","get","add","getDocuments","getAllKeys","Array","from","keys","clear","TrieNode","children","isEndOfWord","data","TrieSearch","root","insert","word","current","char","toLowerCase","search","prefix","maxResults","results","collectIds","node","id","size","child","values","fuzzySearch","maxDistance","fuzzySearchHelper","currentWord","levenshteinDistance","forEach","childNode","s1","s2","dp","length","fill","map","i","j","Math","min","IndexMapper","dataMapper","trieSearch","indexDocument","document","fields","field","value","split","query","options","fuzzy","documentIds","item","score","calculateScore","matches","slice","createSearchableFields","searchableFields","getNestedValue","undefined","normalizeFieldValue","trim","isArray","v","join","Object","String","obj","path","reduce","IndexManager","config","indexMapper","documents","addDocuments","doc","index","generateDocumentId","result","exportIndex","entries","importIndex","Date","now","QueryProcessor","STOP_WORDS","process","tokens","tokenize","processedTokens","processTokens","optimizeQuery","filter","term","classifyToken","startsWith","type","includes","token","normalizeToken","endsWith","SearchStorage","db","DB_NAME","DB_VERSION","initialize","openDB","upgrade","objectStoreNames","contains","createObjectStore","keyPath","error","console","storeIndex","entry","timestamp","put","getIndex","updateMetadata","metadata","lastUpdated","clearIndices","CacheManager","maxSize","ttlMinutes","cache","ttl","evictOldest","isExpired","delete","oldestKey","oldestTime","Infinity","validateSearchOptions","threshold","caseSensitive","stemming","stopWords","minWordLength","maxWordLength","fuzzyThreshold","sortBy","sortOrder","page","pageSize","indexManager","queryProcessor","storage","loadIndexes","cacheKey","generateCacheKey","cachedResults","processedQuery","storedIndex","JSON","stringify","clearIndex","startTime","stats","position","version","parse","sort","a","b","localeCompare","every"],"mappings":"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"}