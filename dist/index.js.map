{"version":3,"file":"index.js","sources":["../src/types/errors.ts","../src/types/index.ts","../src/mappers/DataMapper.ts","../src/algorithms/trie/TrieNode.ts","../src/algorithms/trie/TrieSearch.ts","../src/mappers/IndexMapper.ts","../src/utils/SearchUtils.ts","../src/core/IndexManager.ts","../src/core/QueryProcessor.ts","../node_modules/idb/build/wrap-idb-value.js","../node_modules/idb/build/index.js","../src/storage/IndexedDB.ts","../src/storage/CacheManager.ts","../src/utils/ValidationUtils.ts","../src/core/SearchEngine.ts"],"sourcesContent":["export class SearchError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'SearchError';\r\n  }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class StorageError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'StorageError';\r\n  }\r\n}","\r\n\r\nexport * from './types';\r\nexport * from './errors';\r\nexport * from './events';\r\nexport * from './internal';\r\nexport * from './guards';\r\nexport * from './utils';\r\nexport * from './defaults';\r\n\r\n// Event types implementation\r\nexport type SearchEventType = \r\n  | 'search:start'\r\n  | 'search:complete'\r\n  | 'search:error'\r\n  | 'index:start'\r\n  | 'index:complete'\r\n  | 'index:error'\r\n  | 'storage:error';\r\n\r\nexport interface SearchEvent {\r\n  type: SearchEventType;\r\n  timestamp: number;\r\n  data?: any;\r\n  error?: Error;\r\n}\r\n\r\nexport interface SearchEventListener {\r\n  (event: SearchEvent): void;\r\n}\r\n\r\n// Internal types implementation\r\nexport interface IndexNode {\r\n  id: string;\r\n  value: any;\r\n  score: number;\r\n  children: Map<string, IndexNode>;\r\n}\r\n\r\nexport interface SearchContext {\r\n  query: string;\r\n  options: SearchOptions;\r\n  startTime: number;\r\n  results: SearchResult<any>[];\r\n  stats: SearchStats;\r\n}\r\n\r\nexport interface TokenInfo {\r\n  value: string;\r\n  type: 'word' | 'operator' | 'modifier' | 'delimiter';\r\n  position: number;\r\n  length: number;\r\n}\r\n\r\n// Type guards\r\nexport function isSearchOptions(obj: any): obj is SearchOptions {\r\n  return obj && (\r\n    typeof obj.fuzzy === 'undefined' || typeof obj.fuzzy === 'boolean'\r\n  ) && (\r\n    typeof obj.maxResults === 'undefined' || typeof obj.maxResults === 'number'\r\n  );\r\n}\r\n\r\nexport function isIndexConfig(obj: any): obj is IndexConfig {\r\n  return obj && \r\n    typeof obj.name === 'string' &&\r\n    typeof obj.version === 'number' &&\r\n    Array.isArray(obj.fields);\r\n}\r\n\r\nexport function isSearchResult<T>(obj: any): obj is SearchResult<T> {\r\n  return obj &&\r\n    'item' in obj &&\r\n    typeof obj.score === 'number' &&\r\n    Array.isArray(obj.matches);\r\n}\r\n\r\n// Utility type functions\r\nexport function createSearchStats(): SearchStats {\r\n  return {\r\n    totalResults: 0,\r\n    searchTime: 0,\r\n    indexSize: 0,\r\n    queryComplexity: 0\r\n  };\r\n}\r\n\r\nexport function createSearchContext(\r\n  query: string,\r\n  options: SearchOptions = {}\r\n): SearchContext {\r\n  return {\r\n    query,\r\n    options,\r\n    startTime: Date.now(),\r\n    results: [],\r\n    stats: createSearchStats()\r\n  };\r\n}\r\n\r\nexport function createTokenInfo(\r\n  value: string,\r\n  type: TokenInfo['type'],\r\n  position: number\r\n): TokenInfo {\r\n  return {\r\n    value,\r\n    type,\r\n    position,\r\n    length: value.length\r\n  };\r\n}\r\n\r\n// Default configurations\r\nexport const DEFAULT_INDEX_OPTIONS: Required<IndexOptions> = {\r\n  caseSensitive: false,\r\n  stemming: true,\r\n  stopWords: ['the', 'a', 'an', 'and', 'or', 'but'],\r\n  minWordLength: 2,\r\n  maxWordLength: 50,\r\n  fuzzyThreshold: 0.8\r\n};\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n  fuzzy: false,\r\n  maxResults: 10,\r\n  threshold: 0.5,\r\n  fields: [],\r\n  sortBy: 'score',\r\n  sortOrder: 'desc',\r\n  page: 1,\r\n  pageSize: 10\r\n};\r\n\r\n// Export a namespace for internal use\r\nexport namespace NexusSearch {\r\n  export interface InternalConfig extends IndexConfig {\r\n    _id: string;\r\n    _created: number;\r\n    _updated: number;\r\n  }\r\n\r\n  export interface QueryContext extends SearchContext {\r\n    _processed: boolean;\r\n    _cached: boolean;\r\n  }\r\n}\r\nexport interface SearchOptions {\r\n    fuzzy?: boolean;\r\n    maxResults?: number;\r\n    threshold?: number;\r\n    fields?: string[];\r\n    sortBy?: string;\r\n    sortOrder?: 'asc' | 'desc';\r\n    page?: number;\r\n    pageSize?: number;\r\n  }\r\n  \r\n  export interface SearchResult<T> {\r\n    item: T;\r\n    score: number;\r\n    matches: string[];\r\n    highlights?: Record<string, string[]>;\r\n  }\r\n  \r\n  export interface IndexConfig {\r\n    name: string;\r\n    version: number;\r\n    fields: string[];\r\n    options?: IndexOptions;\r\n  }\r\n  \r\n  export interface IndexOptions {\r\n    caseSensitive?: boolean;\r\n    stemming?: boolean;\r\n    stopWords?: string[];\r\n    minWordLength?: number;\r\n    maxWordLength?: number;\r\n    fuzzyThreshold?: number;\r\n  }\r\n  \r\n  export interface SearchStats {\r\n    totalResults: number;\r\n    searchTime: number;\r\n    indexSize: number;\r\n    queryComplexity: number;\r\n  }\r\n\r\n  ","\r\n  export class DataMapper {\r\n    private dataMap: Map<string, Set<string>>;\r\n  \r\n    constructor() {\r\n      this.dataMap = new Map();\r\n    }\r\n  \r\n    mapData(key: string, documentId: string): void {\r\n      if (!this.dataMap.has(key)) {\r\n        this.dataMap.set(key, new Set());\r\n      }\r\n      this.dataMap.get(key)!.add(documentId);\r\n    }\r\n  \r\n    getDocuments(key: string): Set<string> {\r\n      return this.dataMap.get(key) || new Set();\r\n    }\r\n  \r\n    getAllKeys(): string[] {\r\n      return Array.from(this.dataMap.keys());\r\n    }\r\n  \r\n    clear(): void {\r\n      this.dataMap.clear();\r\n    }\r\n  }\r\n  \r\n","export class TrieNode {\r\n    children: Map<string, TrieNode>;\r\n    isEndOfWord: boolean;\r\n    data: Set<string>;\r\n    \r\n    constructor() {\r\n      this.children = new Map();\r\n      this.isEndOfWord = false;\r\n      this.data = new Set();\r\n    }\r\n  }\r\n  ","import { TrieNode } from \"./TrieNode\";\r\n\r\nexport class TrieSearch {\r\n  private root: TrieNode;\r\n\r\n  constructor() {\r\n    this.root = new TrieNode();\r\n  }\r\n\r\n  insert(word: string, documentId: string): void {\r\n    let current = this.root;\r\n    \r\n    for (const char of word.toLowerCase()) {\r\n      if (!current.children.has(char)) {\r\n        current.children.set(char, new TrieNode());\r\n      }\r\n      current = current.children.get(char)!;\r\n    }\r\n    \r\n    current.isEndOfWord = true;\r\n    current.data.add(documentId);\r\n  }\r\n\r\n  search(prefix: string, maxResults: number = 10): Set<string> {\r\n    const results = new Set<string>();\r\n    let current = this.root;\r\n\r\n    for (const char of prefix.toLowerCase()) {\r\n      if (!current.children.has(char)) {\r\n        return results;\r\n      }\r\n      current = current.children.get(char)!;\r\n    }\r\n\r\n    this.collectIds(current, results, maxResults);\r\n    return results;\r\n  }\r\n\r\n  private collectIds(node: TrieNode, results: Set<string>, maxResults: number): void {\r\n    if (node.isEndOfWord) {\r\n      for (const id of node.data) {\r\n        if (results.size >= maxResults) return;\r\n        results.add(id);\r\n      }\r\n    }\r\n\r\n    for (const child of node.children.values()) {\r\n      if (results.size >= maxResults) return;\r\n      this.collectIds(child, results, maxResults);\r\n    }\r\n  }\r\n\r\n  fuzzySearch(word: string, maxDistance: number = 2): Set<string> {\r\n    const results = new Set<string>();\r\n    this.fuzzySearchHelper(word.toLowerCase(), this.root, '', maxDistance, results);\r\n    return results;\r\n  }\r\n\r\n  private fuzzySearchHelper(\r\n    word: string,\r\n    node: TrieNode,\r\n    currentWord: string,\r\n    maxDistance: number,\r\n    results: Set<string>\r\n  ): void {\r\n    if (maxDistance < 0) return;\r\n\r\n    if (node.isEndOfWord) {\r\n      const distance = this.levenshteinDistance(word, currentWord);\r\n      if (distance <= maxDistance) {\r\n        node.data.forEach(id => results.add(id));\r\n      }\r\n    }\r\n\r\n    for (const [char, childNode] of node.children) {\r\n      this.fuzzySearchHelper(\r\n        word,\r\n        childNode,\r\n        currentWord + char,\r\n        maxDistance,\r\n        results\r\n      );\r\n    }\r\n  }\r\n\r\n  private levenshteinDistance(s1: string, s2: string): number {\r\n    const dp: number[][] = Array(s1.length + 1)\r\n      .fill(0)\r\n      .map(() => Array(s2.length + 1).fill(0));\r\n\r\n    for (let i = 0; i <= s1.length; i++) dp[i][0] = i;\r\n    for (let j = 0; j <= s2.length; j++) dp[0][j] = j;\r\n\r\n    for (let i = 1; i <= s1.length; i++) {\r\n      for (let j = 1; j <= s2.length; j++) {\r\n        dp[i][j] = Math.min(\r\n          dp[i - 1][j] + 1,\r\n          dp[i][j - 1] + 1,\r\n          dp[i - 1][j - 1] + (s1[i - 1] !== s2[j - 1] ? 1 : 0)\r\n        );\r\n      }\r\n    }\r\n\r\n    return dp[s1.length][s2.length];\r\n  }\r\n}","import { SearchResult } from '../types';\r\nimport { DataMapper } from './DataMapper';\r\nimport { TrieSearch } from '../algorithms/trie/TrieSearch';\r\n\r\nexport class IndexMapper {\r\n  private dataMapper: DataMapper;\r\n  private trieSearch: TrieSearch;\r\n\r\n  constructor() {\r\n    this.dataMapper = new DataMapper();\r\n    this.trieSearch = new TrieSearch();\r\n  }\r\n\r\n  indexDocument(document: any, id: string, fields: string[]): void {\r\n    fields.forEach(field => {\r\n      const value = document[field];\r\n      if (typeof value === 'string') {\r\n        const words = value.split(/\\s+/);\r\n        words.forEach(word => {\r\n          this.trieSearch.insert(word, id);\r\n          this.dataMapper.mapData(word.toLowerCase(), id);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  search(query: string, options: { fuzzy?: boolean; maxResults?: number } = {}): SearchResult<string>[] {\r\n    const { fuzzy = false, maxResults = 10 } = options;\r\n    \r\n    const documentIds = fuzzy\r\n      ? this.trieSearch.fuzzySearch(query)\r\n      : this.trieSearch.search(query, maxResults);\r\n\r\n    const results: SearchResult<string>[] = Array.from(documentIds).map(id => ({\r\n      item: id as string,\r\n      score: this.calculateScore(id, query),\r\n      matches: [query]\r\n    }));\r\n\r\n    return results.slice(0, maxResults);\r\n  }\r\n\r\n  private calculateScore(documentId: string, query: string): number {\r\n    // Basic scoring implementation - can be enhanced\r\n    const exactMatch = this.dataMapper.getDocuments(query.toLowerCase()).has(documentId);\r\n    return exactMatch ? 1.0 : 0.5;\r\n  }\r\n}\r\n","import { SearchOptions } from '../types';\r\n\r\n\r\nexport function createSearchableFields<T>(\r\n  document: T,\r\n  fields: string[]\r\n): Record<string, string> {\r\n  const searchableFields: Record<string, string> = {};\r\n\r\n  fields.forEach(field => {\r\n    const value = getNestedValue(document, field);\r\n    if (value !== undefined) {\r\n      searchableFields[field] = normalizeFieldValue(value);\r\n    }\r\n  });\r\n\r\n  return searchableFields;\r\n}\r\n\r\nexport function normalizeFieldValue(value: any): string {\r\n  if (typeof value === 'string') {\r\n    return value.toLowerCase().trim();\r\n  }\r\n  if (Array.isArray(value)) {\r\n    return value.map(v => normalizeFieldValue(v)).join(' ');\r\n  }\r\n  if (typeof value === 'object' && value !== null) {\r\n    return Object.values(value).map(v => normalizeFieldValue(v)).join(' ');\r\n  }\r\n  return String(value);\r\n}\r\n\r\nexport function getNestedValue(obj: any, path: string): any {\r\n  return path.split('.').reduce((current, key) => \r\n    current && current[key] !== undefined ? current[key] : undefined, \r\n    obj\r\n  );\r\n}\r\n\r\nexport function optimizeIndex(data: any[]): any[] {\r\n  // Remove duplicates\r\n  const uniqueData = Array.from(new Set(data.map(item => \r\n    JSON.stringify(item)\r\n  ))).map(item => JSON.parse(item));\r\n\r\n  // Sort for binary search optimization\r\n  return uniqueData.sort((a, b) => \r\n    JSON.stringify(a).localeCompare(JSON.stringify(b))\r\n  );\r\n}\r\n\r\n","import { IndexMapper } from \"@/mappers/IndexMapper\";\r\nimport { IndexConfig, SearchOptions, SearchResult } from \"@/types\";\r\nimport { createSearchableFields } from \"@/utils/SearchUtils\";\r\n\r\nexport class IndexManager {\r\n    private indexMapper: IndexMapper;\r\n    private config: IndexConfig;\r\n    private documents: Map<string, any>;\r\n  \r\n    constructor(config: IndexConfig) {\r\n      this.config = config;\r\n      this.indexMapper = new IndexMapper();\r\n      this.documents = new Map();\r\n    }\r\n  \r\n    async addDocuments<T>(documents: T[]): Promise<void> {\r\n      documents.forEach((doc, index) => {\r\n        const id = this.generateDocumentId(index);\r\n        this.documents.set(id, doc);\r\n        \r\n        const searchableFields = createSearchableFields(doc, this.config.fields);\r\n        this.indexMapper.indexDocument(searchableFields, id, this.config.fields);\r\n      });\r\n    }\r\n  \r\n    async search<T>(query: string, options: SearchOptions): Promise<SearchResult<T>[]> {\r\n      const searchResults = this.indexMapper.search(query, {\r\n        fuzzy: options.fuzzy,\r\n        maxResults: options.maxResults\r\n      });\r\n  \r\n      return searchResults.map(result => ({\r\n        item: this.documents.get(result.item) as T,\r\n        score: result.score,\r\n        matches: result.matches\r\n      }));\r\n    }\r\n  \r\n    exportIndex(): any {\r\n      return {\r\n        documents: Array.from(this.documents.entries()),\r\n        config: this.config\r\n      };\r\n    }\r\n  \r\n    importIndex(data: any): void {\r\n      this.documents = new Map(data.documents);\r\n      this.config = data.config;\r\n    }\r\n  \r\n    clear(): void {\r\n      this.documents.clear();\r\n      this.indexMapper = new IndexMapper();\r\n    }\r\n  \r\n    private generateDocumentId(index: number): string {\r\n      return `${this.config.name}-${index}-${Date.now()}`;\r\n    }\r\n  }\r\n  ","type QueryToken = {\r\n  type: 'term' | 'operator' | 'modifier';\r\n  value: string;\r\n};\r\n\r\nexport class QueryProcessor {\r\n  private readonly STOP_WORDS = new Set([\r\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for',\r\n    'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on',\r\n    'that', 'the', 'to', 'was', 'were', 'will', 'with'\r\n  ]);\r\n\r\n  process(query: string): string {\r\n    const tokens = this.tokenize(query);\r\n    const processedTokens = this.processTokens(tokens);\r\n    return this.optimizeQuery(processedTokens);\r\n  }\r\n\r\n  private tokenize(query: string): QueryToken[] {\r\n    return query\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(term => term.length > 0)\r\n      .map(term => this.classifyToken(term));\r\n  }\r\n\r\n  private classifyToken(term: string): QueryToken {\r\n    if (term.startsWith('+') || term.startsWith('-')) {\r\n      return { type: 'operator', value: term };\r\n    }\r\n    if (term.includes(':')) {\r\n      return { type: 'modifier', value: term };\r\n    }\r\n    return { type: 'term', value: term };\r\n  }\r\n\r\n  private processTokens(tokens: QueryToken[]): QueryToken[] {\r\n    return tokens\r\n      .filter(token => \r\n        token.type !== 'term' || !this.STOP_WORDS.has(token.value)\r\n      )\r\n      .map(token => this.normalizeToken(token));\r\n  }\r\n\r\n  private normalizeToken(token: QueryToken): QueryToken {\r\n    if (token.type === 'term') {\r\n      // Basic stemming (could be enhanced with proper stemming algorithm)\r\n      let value = token.value;\r\n      if (value.endsWith('ing')) value = value.slice(0, -3);\r\n      if (value.endsWith('s')) value = value.slice(0, -1);\r\n      return { ...token, value };\r\n    }\r\n    return token;\r\n  }\r\n\r\n  private optimizeQuery(tokens: QueryToken[]): string {\r\n    return tokens\r\n      .map(token => token.value)\r\n      .join(' ');\r\n  }\r\n}","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { openDB, DBSchema, IDBPDatabase } from 'idb';\r\nimport { IndexConfig } from '../types';\r\n\r\ninterface SearchDBSchema extends DBSchema {\r\n  searchIndices: {\r\n    key: string;\r\n    value: {\r\n      id: string;\r\n      data: any;\r\n      timestamp: number;\r\n    };\r\n  };\r\n  metadata: {\r\n    key: string;\r\n    value: MetadataEntry;\r\n  };\r\n}\r\n\r\ninterface MetadataEntry {\r\n  config: IndexConfig;\r\n  lastUpdated: number;\r\n}\r\n\r\nexport class SearchStorage {\r\n  private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n  private readonly DB_NAME = 'nexus_search_db';\r\n  private readonly DB_VERSION = 1;\r\n  private initPromise: Promise<void> | null = null;\r\n\r\n  constructor() {\r\n    // Initialize immediately to catch early failures\r\n    this.initPromise = this.initialize();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.db) return;\r\n\r\n    try {\r\n      this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n        upgrade(db, oldVersion, newVersion, transaction) {\r\n          // Handle version upgrades\r\n          if (!db.objectStoreNames.contains('searchIndices')) {\r\n            const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n            indexStore.createIndex('timestamp', 'timestamp');\r\n          }\r\n\r\n          if (!db.objectStoreNames.contains('metadata')) {\r\n            const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n            metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n          }\r\n        },\r\n        blocked() {\r\n          console.warn('Database upgrade was blocked');\r\n        },\r\n        blocking() {\r\n          console.warn('Current database version is blocking a newer version');\r\n        },\r\n        terminated() {\r\n          console.error('Database connection was terminated');\r\n        }\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Storage initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n    \r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n      \r\n      await this.db!.put('metadata', { id: 'config', ...metadata });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      return await this.db!.get('metadata', 'config');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}","import { SearchResult } from '../types';\r\n\r\nexport class CacheManager {\r\n  private cache: Map<string, { data: SearchResult<any>[]; timestamp: number }>;\r\n  private readonly maxSize: number;\r\n  private readonly ttl: number; // Time to live in milliseconds\r\n\r\n  constructor(maxSize: number = 1000, ttlMinutes: number = 5) {\r\n    this.cache = new Map();\r\n    this.maxSize = maxSize;\r\n    this.ttl = ttlMinutes * 60 * 1000;\r\n  }\r\n\r\n  set(key: string, data: SearchResult<any>[]): void {\r\n    if (this.cache.size >= this.maxSize) {\r\n      this.evictOldest();\r\n    }\r\n\r\n    this.cache.set(key, {\r\n      data,\r\n      timestamp: Date.now(),\r\n    });\r\n  }\r\n\r\n  get(key: string): SearchResult<any>[] | null {\r\n    const entry = this.cache.get(key);\r\n    \r\n    if (!entry) return null;\r\n    \r\n    if (this.isExpired(entry.timestamp)) {\r\n      this.cache.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return entry.data;\r\n  }\r\n\r\n  private isExpired(timestamp: number): boolean {\r\n    return Date.now() - timestamp > this.ttl;\r\n  }\r\n\r\n  private evictOldest(): void {\r\n    let oldestKey: string | null = null;\r\n    let oldestTime = Infinity;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (entry.timestamp < oldestTime) {\r\n        oldestTime = entry.timestamp;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      this.cache.delete(oldestKey);\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n}","import { SearchOptions, IndexConfig } from '@types';\r\nimport { getNestedValue } from './SearchUtils';\r\n\r\nexport function validateSearchOptions(options: SearchOptions): void {\r\n  if (options.maxResults && options.maxResults < 1) {\r\n    throw new Error('maxResults must be greater than 0');\r\n  }\r\n\r\n  if (options.threshold && (options.threshold < 0 || options.threshold > 1)) {\r\n    throw new Error('threshold must be between 0 and 1');\r\n  }\r\n\r\n  if (options.fields && !Array.isArray(options.fields)) {\r\n    throw new Error('fields must be an array');\r\n  }\r\n}\r\n\r\nexport function validateIndexConfig(config: IndexConfig): void {\r\n  if (!config.name) {\r\n    throw new Error('Index name is required');\r\n  }\r\n\r\n  if (!config.version || typeof config.version !== 'number') {\r\n    throw new Error('Valid version number is required');\r\n  }\r\n\r\n  if (!Array.isArray(config.fields) || config.fields.length === 0) {\r\n    throw new Error('At least one field must be specified for indexing');\r\n  }\r\n}\r\n\r\nexport function validateDocument(document: any, fields: string[]): boolean {\r\n  return fields.every(field => {\r\n    const value = getNestedValue(document, field);\r\n    return value !== undefined;\r\n  });\r\n}","import { SearchOptions, SearchResult, IndexConfig } from '../types';\r\nimport { IndexManager } from './IndexManager';\r\nimport { QueryProcessor } from './QueryProcessor';\r\nimport { SearchStorage } from '../storage/IndexedDB';\r\nimport { CacheManager } from '../storage/CacheManager';\r\nimport { validateSearchOptions } from '@/utils/ValidationUtils';\r\n\r\nexport class SearchEngine {\r\n  private indexManager: IndexManager;\r\n  private queryProcessor: QueryProcessor;\r\n  private storage: SearchStorage;\r\n  private cache: CacheManager;\r\n  private config: IndexConfig;\r\n\r\n  constructor(config: IndexConfig) {\r\n    this.config = config;\r\n    this.indexManager = new IndexManager(config);\r\n    this.queryProcessor = new QueryProcessor();\r\n    this.storage = new SearchStorage();\r\n    this.cache = new CacheManager();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    try {\r\n      await this.storage.initialize();\r\n      await this.loadIndexes();\r\n    } catch (error) {\r\n      throw new Error(`Failed to initialize search engine: ${error}`);\r\n    }\r\n  }\r\n\r\n  async addDocuments<T>(documents: T[]): Promise<void> {\r\n    try {\r\n      await this.indexManager.addDocuments(documents);\r\n      await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n    } catch (error) {\r\n      throw new Error(`Failed to add documents: ${error}`);\r\n    }\r\n  }\r\n\r\n  async search<T>(query: string, options: SearchOptions = {}): Promise<SearchResult<T>[]> {\r\n    validateSearchOptions(options);\r\n    \r\n    const cacheKey = this.generateCacheKey(query, options);\r\n    const cachedResults = this.cache.get(cacheKey);\r\n    \r\n    if (cachedResults) {\r\n      return cachedResults as SearchResult<T>[];\r\n    }\r\n\r\n    const processedQuery = this.queryProcessor.process(query);\r\n    const results = await this.indexManager.search<T>(processedQuery, options);\r\n    \r\n    this.cache.set(cacheKey, results);\r\n    return results;\r\n  }\r\n\r\n  private async loadIndexes(): Promise<void> {\r\n    const storedIndex = await this.storage.getIndex(this.config.name);\r\n    if (storedIndex) {\r\n      this.indexManager.importIndex(storedIndex);\r\n    }\r\n  }\r\n\r\n  private generateCacheKey(query: string, options: SearchOptions): string {\r\n    return `${query}-${JSON.stringify(options)}`;\r\n  }\r\n\r\n  async clearIndex(): Promise<void> {\r\n    await this.storage.clearIndices();\r\n    this.indexManager.clear();\r\n    this.cache.clear();\r\n  }\r\n}\r\n"],"names":["SearchError","Error","constructor","message","super","this","name","IndexError","ValidationError","StorageError","createSearchStats","totalResults","searchTime","indexSize","queryComplexity","DataMapper","dataMap","Map","mapData","key","documentId","has","set","Set","get","add","getDocuments","getAllKeys","Array","from","keys","clear","TrieNode","children","isEndOfWord","data","TrieSearch","root","insert","word","current","char","toLowerCase","search","prefix","maxResults","results","collectIds","node","id","size","child","values","fuzzySearch","maxDistance","fuzzySearchHelper","currentWord","levenshteinDistance","forEach","childNode","s1","s2","dp","length","fill","map","i","j","Math","min","IndexMapper","dataMapper","trieSearch","indexDocument","document","fields","field","value","split","query","options","fuzzy","documentIds","item","score","calculateScore","matches","slice","createSearchableFields","searchableFields","getNestedValue","undefined","normalizeFieldValue","trim","isArray","v","join","Object","String","obj","path","reduce","IndexManager","config","indexMapper","documents","addDocuments","doc","index","generateDocumentId","result","exportIndex","entries","importIndex","Date","now","QueryProcessor","STOP_WORDS","process","tokens","tokenize","processedTokens","processTokens","optimizeQuery","filter","term","classifyToken","startsWith","type","includes","token","normalizeToken","endsWith","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","args","apply","unwrap","storeNames","tx","call","sort","transformCachableValue","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","request","promise","success","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","shift","all","oldTraps","callback","SearchStorage","db","DB_NAME","DB_VERSION","initPromise","initialize","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","contains","createObjectStore","keyPath","createIndex","console","warn","ensureConnection","storeIndex","entry","timestamp","put","getIndex","updateMetadata","metadata","lastUpdated","getMetadata","clearIndices","close","CacheManager","maxSize","ttlMinutes","cache","ttl","evictOldest","isExpired","delete","oldestKey","oldestTime","Infinity","validateSearchOptions","threshold","caseSensitive","stemming","stopWords","minWordLength","maxWordLength","fuzzyThreshold","sortBy","sortOrder","page","pageSize","indexManager","queryProcessor","storage","loadIndexes","cacheKey","generateCacheKey","cachedResults","processedQuery","storedIndex","JSON","stringify","clearIndex","startTime","stats","position","parse","a","b","localeCompare","every"],"mappings":"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","x_google_ignoreList":[9,10]}